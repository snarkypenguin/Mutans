;-  Identification and Changes

;--
;	framework -- Written by Randall Gray 
;	Initial coding: 
;		Date: 2012.11.12
;
;	History:
;


;;; #|
;;; The code in this file is supposed to make things a little easier.

;;;
;;;  This model framework uses SCLOS by Gregor Kiczales, and released
;;;  by Xerox Corp. in 1992. None of the code from sclos.scm has been 
;;;  included in the other files which form the modelling framework.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;; This file *must* be included, not loaded. ;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; |#

;-  Code 

;; See also Kiczales, Gregor; Jim des Rivieres; Daniel G. Bobrow (July
;; 30, 1991). The Art of the Metaobject Protocol. The MIT . ISBN
;; 978-0262610742.

(define-macro (excise-s-expression . body)
  `(let () #!void))

(define-macro (conditional-load yea-or-nay . body)
  `(if ,yea-or-nay
		 ,@body))

(define-macro (with-exit name . body)
  `(call-with-current-continuation
    (lambda (,name) ,@body)))

(define-macro (state-variables . lst)
  (let ((rslt `'(,@lst)))
	 ;;(pp rslt)
	 rslt))

;; This makes it clear when classes are defining state vars

(define-macro (no-state-variables) `'())
;; This makes it clear when classes are defining NO state vars

(define-macro (inherits-from . iflst) `(list ,@iflst))

;; Support for the "isa?" calls and for a mapping from the class
;; object to a name

;; Remember, if you try to unquote classtype without splicing, the
;; interpreter tries to evaluate it.


;; cpl... class precedent list
(define-macro (isa? self . classtype)
  (letrec ((orf (lambda x (if (null? x #f) (or (car x) (apply orf (cdr x)))))))
	 (let ((txt `(let ((ancestors (class-cpl (class-of ,self))))
						(if (apply orf
									  (map (lambda (x) (member x ancestors))
											 (list ,@classtype))) 
							 #t #f)
						)
					))
		;;(pp txt)
		txt)))





;;; (define-macro (register-class cname . stuff)
;;; 	 `(class-register 'add ,cname ',cname))

;;; (define-macro (register-method mname descr . stuff)
;;; 	 `(method-register 'add ,mname ',mname))

;;; (define-macro (register-generic-method mname . stuff )
;;; 	 `(generic-method-register 'add-unique ,mname ',mname )
;;;   )

(define-macro (register regname mname . val)
  (let ((txt
			(if (not (null? val))
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add ,mname ',mname ,@val)
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add ,mname ',mname)) )
		  )
	 (display "register: ") (pp txt)
	 txt))

(define-macro (register-unique regname mname . val)
  (let ((txt (if (not (null? val))
					  `(,(string->symbol (string-append (symbol->string regname) "-register"))
						 'add-unique ,mname ',mname ,@val)
					  `(,(string->symbol (string-append (symbol->string regname) "-register"))
						 'add-unique ,mname ',mname)) )
		  )
	 (display "register-unique: ") (pp txt)
	 txt))

(define-macro (make-object% class . initargs)
  `(let ((instance (allocate-instance ,class)))
	  (initialize instance ,@initargs)
	  instance))

(define-macro (make-agent% class . initargs)
  `(let ((instance (allocate-instance ,class)))
	  (for-each (lambda (x) (slot-set! instance x '<uninitialised>)) (class-slots-of instance))
	  (initialize instance ,@initargs)
	  instance))

(define-macro (define-class cname . margs)
  ;;`(define ,cname (register-unique class ,(make-class ,@margs))))
  (let ((allargs (list 'register-unique 'class `(make-class ,@margs))))
	 `(define ,cname ,allargs)))

(define-macro (declare-method name descr . otherstuff)
  `(define ,name (register-unique generic-method (make-generic)))
  )


;; Objects do not chain to their parents on initialising
(define-macro (default-object-initialization name . margs)
;(display name) (display " MARGS = ")(display margs) (display (if (null? margs) " NULL" ""))(newline)
  (let ((txt (if (null? margs)
					  `(object-method (,name) (initialize self initargs)
											(let ()
											  (if (pair? initargs) (set-state-variables self initargs))
											  ;;(display "###### dumpslots exiting init: ") (dumpslots self)
											  )
											)

					  `(object-method (,name) (initialize self initargs)
											(let ((Margs ',margs))
											  (set-state-variables self Margs)
											  (if (pair? initargs) (set-state-variables self initargs))
											  ;;(display "###### dumpslots exiting init: ") (dumpslots self)
											  )
											))))
	 ;;(pp txt)(newline)
	 txt))


(define-macro (default-attribute-initialization name . margs)
;(display name) (display " MARGS = ")(display margs) (display (if (null? margs) " NULL" ""))(newline)
  (let ((txt (if (null? margs)
					  `(attribute-method (,name) (initialize self initargs)
												(let ((margs ',margs))
												  (initialize-parent)
												  (if (pair? initargs) (set-state-variables self initargs))
												  ;;(display "###### dumpslots exiting init: ") (dumpslots self)
												  )
												)

					  `(attribute-method (,name) (initialize self initargs)
												(let ((Margs ',margs))
												  (set-state-variables self Margs)
												  (initialize-parent) 
												  (if (pair? initargs) (set-state-variables self initargs))
												  ;;(display "###### dumpslots exiting init: ") (dumpslots self)
												  )
												))))
	 ;;(pp txt)(newline)
	 txt))

(define-macro (default-initialization name . margs)
  ;;(display name) (display " MARGS = ")(display margs) (display (if (null? margs) " NULL" ""))(newline)
  (let ((txt (if (null? margs)
					  `(model-method (,name) (initialize self initargs)
										  (let ((Margs ',margs))
											 (initialize-parent)
											 (if (pair? initargs) (set-state-variables self initargs))
											 ;;(display "###### dumpslots exiting init: ") (dumpslots self)
											 )
										  )

					  `(model-method (,name) (initialize self initargs)
										  (let ((Margs ',margs))
											 (set-state-variables self Margs)
											 (initialize-parent) 
											 (if (pair? initargs) (set-state-variables self initargs))
											 ;;(display "###### dumpslots exiting init: ") (dumpslots self)
											 )
										  ))))
	 ;;(pp txt)(newline)
	 txt))



;; This works like so:
;;(model-method <parent1> (methname) body)
;;(model-method <parent1> (methname arg1 #!rest rest) body)
;;(model-method <parent1> (methname #!rest rest) body)
;;(model-method (<parent1>) (methname) body)
;;(model-method (<parent1>) (methname arg1 arg2) body)
;;(model-method (<parent1> <parent2>) (methname) body)
;;(model-method (<parent1> <parent2>) (methname arg1 arg2..) body)
;;(model-method (<parent1>) (methname arg1 arg2 #!rest rest) body)
;;(model-method (<parent1> <parent2>) (methname arg1 arg2 #!rest rest) body)


;; "(parent-body)" can be used to invoke the parent's body --- sclos
;; handles any arguments that might be needed: "self" is the name of
;; the agent within the body code "t" is the current model time dt is
;; the requested dt the state variables are not directly available --
;; use "my" or "set-my!", "slot-ref" or "slot-set!"



(define-macro (model-method #!rest madness)
  ;; Call like (model-method classname (mname * args) #!rest body) where
  ;; the args doesn't include the call-parent-method and 'self' is
  ;; the placeholder
  (if (< (length madness) 3)
		(error "model-method: bad arguments to method call " madness))
  (if (not (and (pair? (cadr madness)) (symbol? (caadr madness)) ))
		(error "model-method: bad (mname margs...) in (model-method ...) "
				 (caadr madness)))
  (if (not (eq? (cadadr madness) 'self))
		(error "model-method: missing 'self' placeholder in definition "
				 (caadr madness)))

  (let ((classlst (if (list? (car madness))
							 (car madness)
							 (list (car madness))))
		  (mname (caadr madness))
		  (star (cadadr madness))
		  (margs (cddadr madness))
		  (body (cddr madness))
		  )

	 (let ((txt `(let ((M
							  (if (and #t (not (generic-method-register 'type? ',mname)))
									(begin
									  (display "********* Instantiating the method (")
									  (display ',mname)
									  (display " ...) ********* before the method has been declared\n"))
									(make-method (list ,@classlst) ;; make-method returns a function....
													 (lambda (,(string->symbol
																	(string-append (symbol->string mname)
																						"-parent"))
																 self
																 ,@margs)

														(kdnl* 'trace-model-methods "Enteriing" (class-name-of self)":"' self `,margs)
														(let ((my (lambda (x) (slot-ref self x)))
																(set-my! (lambda (x y)
																			  (slot-set! self x y)))
																(kernel (if (member 'kernel (map car (class-slots (class-of self))))
																				(slot-ref self 'kernel)
																				#f))
																)
														  (let ((result
																	(begin 
																	  ,@body)))
															 (kdnl* 'trace-model-methods "Leaving" (class-name-of self)":"' self "with" result)
															 result)
														  )
														)
													 ))
							  ))
						(add-method ,mname M)
						(method-register 'add M ',mname )
						)
					))
		;;(pp txt) ;; Uncomment this line to dump the macro to stdout on loading
		txt)))


;; An object is a discrete component of a model which does not
;; communicate directly with the kernel -- this means that an object
;; cannot query the state or garner data from other parts of the model
;; without cheating.

(define-macro (object-method #!rest madness)
  ;; Call like (object-method classname (mname * margs) #!rest body) where
  ;; the margs doesn't include the call-parent-method and 'self' is
  ;; the placeholder
  (if (< (length madness) 3)
		(error "object-method: bad arguments to method call " madness))
  (if (not (and (pair? (cadr madness)) (symbol? (caadr madness)) ))
		(error "object-method: bad (mname margs...) in (object-method ...) "
				 (caadr madness)))
  (if (not (eq? (cadadr madness) 'self))
		(error "object-method: missing 'self' placeholder in definition "
				 (caadr madness)))

  (let ((classlst (if (list? (car madness))
							 (car madness)
							 (list (car madness))))
		  (mname (caadr madness))
		  (star (cadadr madness))
		  (margs (cddadr madness))
		  (body (cddr madness))
		  )
	 
	 (let ((txt `(let ((M
							  (if (and #t (not (generic-method-register 'type? ',mname)))
									(begin
									  (display "********* Instantiating the method (")
									  (display ',mname)
									  (display " ...) ********* before the method has been declared\n"))
									(make-method (list ,@classlst) ;; make-method returns a function....
													 (lambda (,(string->symbol
																	(string-append (symbol->string mname)
																						"-parent"))
																 self
																 ,@margs)
														(kdnl* 'trace-object-methods "Enteriing" (class-name-of self)":"' self `,margs)
														(let ((my (lambda (x) (slot-ref self x)))
																(set-my! (lambda (x y)
																			  (slot-set! self x y)))
																)
														  (let ((result
																	(begin 
																	  ,@body)))
															 (kdnl* 'trace-object-methods "Leaving" (class-name-of self)":"' self "with" result)
															 result)
														  )
														)
													 ))
							  ))
						(add-method ,mname M)
						(method-register 'add M ',mname )
						)
					))
		;;(pp txt) ;; Uncomment this line to dump the macro to stdout on loading
		txt)))

;; An attribute would usually correspond to something that wasn't a
;; completely stand-alone part of a model, but wasn't necessarily an
;; integral/necessary component (like the way food is converted to
;; mass/energy in an animal).  As much as possible, attributes which
;; represent a part of a model should have consistent interfaces.
;;
;; Attributes will probably need to be able to query the state of the
;; agent of which they are a component, but they cannot query other
;; agents directly unless they cheat.

(define-macro (attribute-method #!rest madness)
  ;; Call like (attribute-method classname (mname * margs) #!rest body) where
  ;; the margs doesn't include the call-parent-method and 'self' is
  ;; the placeholder
  (if (< (length madness) 3)
		(error "attribute-method: bad arguments to method call " madness))
  (if (not (and (pair? (cadr madness)) (symbol? (caadr madness)) ))
		(error "attribute-method: bad (mname margs...) in (attribute-method ...) "
				 (caadr madness)))
  (if (not (eq? (cadadr madness) 'self))
		(error "attribute-method: missing 'self' placeholder in definition "
				 (caadr madness)))

  (let ((classlst (if (list? (car madness))
							 (car madness)
							 (list (car madness))))
		  (mname (caadr madness))
		  (star (cadadr madness))
		  (margs (cddadr madness))
		  (body (cddr madness))
		  )

	 (let ((txt `(let ((M (if (and #t (not (generic-method-register 'type? ',mname)))
									  (begin
										 (display "********* Instantiating the method (")
										 (display ',mname)
										 (display " ...) ********* before the method has been declared\n")
										 )
									  (make-method (list ,@classlst) ;; make-method returns a function....
														(lambda (,(string->symbol
																	  (string-append (symbol->string mname)
																						  "-parent"))
																	self
																	,@margs)
														  (kdnl* 'trace-attribute-methods "Enteriing" (class-name-of self)":"' self `,margs)
														  (let ((my (lambda (x) (slot-ref self x)))
																  (set-my! (lambda (x y)
																				 (slot-set! self x y)))
																  (sup-model (if (member 'sup-model (map car (class-slots (class-of self))))
																					  (slot-ref self 'sup-model)
																					  #f))
																  )
															 (let ((result
																	  (begin 
																		 ,@body)))
																(kdnl* 'trace-attribute-methods "Leaving" (class-name-of self)":"' self "with" result)
																result)
														)
													 )
												  ))
							 ))
						(add-method ,mname M)
						(method-register 'add M ',mname )
						)
					))
		;;(pp txt) ;; Uncomment this line to dump the macro to stdout on loading
		txt)))



(define-macro (ddefine a b c d)
  `(begin
	  (define ,a ,b)
	  (define ,c ,d)))



;; "(????-parent)" can be used to invoke the parent methods in the
;; body, where ???? is the value of methname so for a method called
;; "grok" you would use "grok-parent" to invoke the parent method
;; "self" is the name of the agent within the body of the method the
;; state variables are not available but you can use "my" and
;; "set-my!" or "slot-ref" and "slot-set!"


"*** The only difference between an object-method and a model-method is
that object-methods do not keep track of a kernel.  attribute-methods 
are identical to object methods. ***"



(define-macro (model-body myclass #!rest body)
  ;; Call like (method classname (mname args) #!rest body) where the args
  ;; doesn't include the call-next-method
  (if (not (symbol? myclass))
		(aborts "model-body: the class " myclass " should be an atom"))
  `(add-method
	 run-model-body
	 (make-method (list ,myclass)
					  (lambda (parent-body self t dt)
						 (kdnl* 'trace-bodies "Entered" (class-name-of self)":"  self (slot-ref self 'name) "at time" t "+" dt)
						 (let ((my (lambda (x) (slot-ref self x)))
								 (set-my! (lambda (x y) (slot-set! self x y)))
								 (kernel (slot-ref self 'kernel))
								 (skip-parent-body
								  (lambda ()
									 (set! parent-body (lambda x result))
									 ;; forces any call to parent body to just return the indicated result

									 (if (not (slot-ref self 'agent-body-ran))
										  (begin
											 (slot-set! self 'counter
															(1+ (slot-ref self 'counter)))
											 (slot-set! self 'agent-body-ran #t)))
									 dt) )
								 )
							(let ((result
									 (begin
										,@body
										)))

							  (if (not (slot-ref self 'agent-body-ran))
									(begin
									  (slot-set! self 'counter
													 (1+ (slot-ref self 'counter)))
									  (slot-set! self 'agent-body-ran #t))
									)
							  (kdnl* 'trace-bodies "Leaving" (class-name-of self)":"' self "with" result)
							  result
							  
							  )
							)
						 )
					  )
	 )
  )

;; like model-body, but chains straight to parent
(define-macro (use-parent-body myclass) 
  `(model-body ,myclass (parent-body)))



(define-macro (sclos-setter myclass variable)
  (if (or (not (symbol? variable))
			 (not (symbol? myclass)))
		(aborts "model-body: the class " myclass " and variable "
				  variable " must be atoms"))
  `(add-method ,(string->symbol
					  (string-append "set-" (symbol->string variable) "!"))
					(make-method (list ,myclass)
									 (lambda (self arg)
										(slot-set! self ',variable arg)))))

(define-macro (sclos-getter myclass variable)
  (if (or (not (symbol? variable)) (not (symbol? myclass)))
		(aborts "model-body: the class " myclass " and variable "
				  variable " must be atoms"))
  `(add-method ,variable
					(make-method (list ,myclass) 
									 (lambda (self)
										(slot-ref self ',variable)))))

(define-macro (load-config)
  `( include "model.config"))


;-  The End 


;;; Local Variables:
;;; mode: scheme
;;; outline-regexp: ";-+"
;;; comment-column:0
;;; comment-start: ";;; "
;;; comment-end:"" 
;;; End:
