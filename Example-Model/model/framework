; -*- mode: scheme; -*-
;-  Identification and Changes

;--
;	framework -- Written by Randall Gray 
;	Initial coding: 
;		Date: 2012.11.12
;
;	History:
;


;;; #|
;;; The code in this file is supposed to make things a little easier.

;;;
;;;  This model framework uses SCLOS by Gregor Kiczales, and released
;;;  by Xerox Corp. in 1992. None of the code from sclos.scm has been 
;;;  included in the other files which form the modelling framework.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;; This file *must* be included, not loaded. ;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; |#


;; This should be true if you want UNFINISHED-BUSINESS reported.
(define UNFINISHED #f) 


;-  Code 

;; See also Kiczales, Gregor; Jim des Rivieres; Daniel G. Bobrow (July
;; 30, 1991). The Art of the Metaobject Protocol. The MIT . ISBN
;; 978-0262610742.

;; This prefixes the scheme (error...) call with a routine that spits
;; out the current file being loaded.
(define (Error #!rest args)
  `(let ()
	 (display "In ")
	 (display (load 'now-loading))
	 (display ": ")
	 (error ,@args)))


;; Calls to a closure function are of the form (name t reqvar1 reqvar2 ....)
;; Note: t is passed in, rather than dt, since we don't want accidental multiple updates
(define-macro (define-update-closure name class-id svlist reqlist . body)
  `(define ,name
	  (let* ((id ,id)
			  ,@(map (lambda (sv) (list (list sv #f))) ,svlist)
			  (Reqlist ',reqlist) ;; all possible requirements
			  (reqlist ',reqlist) ;; current reqlist
			  (T #f)
			  (this-continuation
				(lambda x
				  (cond
					((null? x)  ;; the closure with no arguments returns its requirements (which may change through time)
					 reqlist)
					((and (= 1 (length x))
							(symbol? (car x)))
					 (case (car x)
						((requirements) reqlist)
						((all-requirements) Reqlist)
						((values) #f) ;; cannot ask for values without the class-id
						((
						(else (Error "bad call to update-closure function" x)))
					 )
					((and (= 1 (length x))
							(symbol? (car x)))
					 (case (car x)
						((requirements) reqlist)
						((all-requirements) Reqlist)
						((values) #f) ;; cannot ask for values without the class-id
						(else (Error "bad call to update-closure function" x)))
					 )
					((number? (car x))
					 (if (eq? (length (cdr x)) (+ 1 (length reqlist)))
						  (let* ((dt (if (< T t) (- (car x) T) 0))
								  )
							 (let ((result (begin ,@body)))
								(set! T t)
								result)
							 )
						  (Error "Failed to pass in the necessary number of arguments!" x)))
					))
					(#t (Error "+++Incomprehensible Update+++" x)))))
			  )
		 this-continuation))
  )
					 

(define-macro (UNFINISHED-BUSINESS . body)
  (if UNFINISHED
		(dnl* (load 'now-loading) " has unfinished business:\n" body))
  `#!void)

(define-macro (excise-s-expression . body)
  `#!void)

(define-macro (conditional-load yea-or-nay . body)
  `(if ,yea-or-nay
		 ,@body))

(define-macro (code-variants select first second)
  (cond
	((member select '(first one 1)) `,first)
	((member select '(second two 2)) `,second)
	))

(define-macro (code-block-variants select first second)
  (cond
	((member select '(first one 1)) `,@first)
	((member select '(second two 2)) `,@second)
	))

(define-macro (with-exit name . body)
  `(call-with-current-continuation
    (lambda (,name) ,@body)))


(define-macro (state-variables . lst)
  (let ((rslt `'(,@lst)))
	 ;;(pp rslt)
	 rslt))

(define-macro (no-state-variables . lst)
  (let ((rslt '()))
	 rslt))


(define-macro (default-values . lst)
  (let ((rslt `'(,@lst)))
	 ;;(pp rslt)
	 rslt))

(define-macro (no-default-values . lst)
  (let ((rslt '()))
	 rslt))

(define-macro (no-values . lst)
  (let ((rslt '()))
	 rslt))


;; This makes it clear when classes are defining NO state vars

(define-macro (inherits-from . iflst) `(list ,@iflst))

;; Support for the "isa?" calls and for a mapping from the class
;; object to a name

;; Remember, if you try to unquote classtype without splicing, the
;; interpreter tries to evaluate it.


;; cpl... class precedence list
(define-macro (isa? self . classtype)
  (letrec ((orf (lambda x (if (null? x #f) (or (car x) (apply orf (cdr x)))))))
	 (let ((txt `(let ((ancestors (class-cpl (class-of ,self))))
						(if (apply orf
									  (map (lambda (x) (member x ancestors))
											 (list ,@classtype))) 
							 #t #f)
						)
					))
		;;(pp txt) ;; Uncomment to print the constructed code during the startup phase 
		txt)))



(define-macro (extend-symbol sym extn)
  `,(string->symbol (string-append (symbol->string sym) "-" extn)))


;;; (define-macro (make-object% class . initargs)
;;;   `(let ((instance (allocate-instance ,class)))
;;; 	  (initialise instance ,@initargs)
;;; 	  instance))

;;; (define-macro (make-agent% class . initargs)
;;;   `(let ((instance (allocate-instance ,class)))
;;; 	  (for-each (lambda (x) (slot-set! instance x '<uninitialized>)) (class-slots-of instance))
;;; 	  (initialise instance ,@initargs)
;;; 	  instance))

;-  Code 

(define-macro (register regname mname . val)
  ;;(display (list 'register `,regname `,mname `,val))(newline)
  (let ((txt
			(if (not (null? val))
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add ,mname ',mname ,(object->string mname) ,@val)
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add ,mname ',mname  ,(object->string mname))) )
		  )
	 ;;(display "register: ") (pp txt)  ;; Uncomment to print the constructed code during the startup phase 
	 txt))

(define-macro (register-unique regname mname . val)
  ;;(display (list 'register-unique `,regname `,mname `,val))(newline)
  (let ((txt
			(if (not (null? val))
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add-unique ,mname ',mname ,(object->string mname) ,@val)
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add-unique ,mname ,(object->string mname) ',mname)) )
		  )
	 ;;(display "register-unique: ") (pp txt) ;; Uncomment to print the constructed code during the startup phase 
	 txt))


(define-macro (define-class #!rest args)
  (let* ((cname (car args))
			;;(icname (string->symbol (string-append "<" (symbol->string cname) ">")))
			)
	 ;;(dnl "Defining " cname)
	 (let ((parents (cadr args)))
		;;(dnl "... which inherits from " parents)
		(let ((variables (caddr args) ))
		  (if (and (pair? variables) (not (memq (car variables) '(state-variables no-variables))))
				(Error "(define-class..) expects (state-variables name1...) or (no-variables)" args))
		  (let ((V (append (cdr variables)
								 (list (string->symbol (string-append (symbol->string (car args)) "-initialized"))))
					  ))
			 ;;(dnl "... with variables " variables)
			 ;;(pp V)
			 (let* ((txt `(define ,cname
								 (let ((,cname (make-class ,parents ',V)))
									(register-unique class ,cname)
									,cname
									)))
					 )
				;;(dnl "-----")
				;;(pp txt)
				;;(dnl "_____")
					  
				txt
				))))))



(define-macro (declare-method #!rest args)
  (let ((cname (car args))
		  (description (cadr args))
		  )
	 (let ((txt `(define ,cname
						(let ((,cname (make-generic)))
						  (register-unique generic-method ,cname)
						  (class-register)
						  ,cname))))
		;;(pp txt)
		txt
		)))





;; This works like so:
;;(model-method <parent1> (methname) body)
;;(model-method <parent1> (methname arg1 #!rest rest) body)
;;(model-method <parent1> (methname #!rest rest) body)
;;(model-method (<parent1>) (methname) body)
;;(model-method (<parent1>) (methname arg1 arg2) body)
;;(model-method (<parent1> <parent2>) (methname) body)
;;(model-method (<parent1> <parent2>) (methname arg1 arg2..) body)
;;(model-method (<parent1>) (methname arg1 arg2 #!rest rest) body)
;;(model-method (<parent1> <parent2>) (methname arg1 arg2 #!rest rest) body)


;; "(parent-body)" can be used to invoke the parent's body --- sclos
;; handles any arguments that might be needed: "self" is the name of
;; the agent within the body code "t" is the current model time dt is
;; the requested dt the state variables are not directly available --
;; use "my" or "set-my!", "slot-ref" or "slot-set!"



;; An object is a discrete component of a model which does not
;; communicate directly with the kernel -- this means that an object
;; cannot query the state or garner data from other parts of the model
;; without cheating.  Objects do *not* have kernel pointers, so the kernel
;; variable is set to #f.

(define-macro (model-method #!rest madness)
  ;; Call like (model-method classname (mname * args) #!rest body) where
  ;; the args doesn't include the call-parent-method and 'self' is
  ;; the placeholder
  (case (length madness)
	 ((0)
	  (Error "model-method: There is nothing here!" madness))
	 ((1) (Error "model-method: Only 1/3 elements have been supplied!\nNeeds a specifier, a function-name and args and a body, got" (cons 'model-method madness)))
	 ((2) (Error "model-method: Only 2/3 elements have been supplied!\nNeeds a specifier, a function-name and args and a body, got " (cons 'model-method madness)))
	 )
  (if (not (and (pair? (cadr madness)) (symbol? (caadr madness)) ))
		(Error "model-method: bad (mname mm-margs...) in (model-method ...) "
				 (caadr madness)))
  (if (not (eq? (cadadr madness) 'self))
		(Error "model-method: missing 'self' placeholder in the (model-method (classes) (methname self ...) ...) definition "
				 (caadr madness)))

  (let ((classlst (if (list? (car madness))
							 (car madness)
							 (list (car madness))))
		  (mname (caadr madness))
		  (star (cadadr madness))
		  (mm-margs (cddadr madness))
		  (body (cddr madness))
		  )

	 (if (and #t (not (generic-method-register 'type? ',mname)))
		  (begin
			 (display "********* Instantiating the method (")
			 (display ',mname)
			 (display " ...) ********* before the method has been declared\n")
			 (Error "instanciating without declaration" ',mname))
		  (let ((txt `(let ((M (make-method
										(list ,@classlst) ;; make-method returns a function....
										(lambda (,(string->symbol (string-append (symbol->string mname) "-parent")) self ,@mm-margs);; Provides ,mname-parent for the "best match"
										  (let ((,(string->symbol (string-append (symbol->string mname) "-parents")) (lambda (parentlst #!rest cpargs) (apply call-parents& (append (list ,mname parentlist self ) cpargs)))))
											 ;; provides ,mname-parents for arbitrary sets .. may be called more than once, and with different sets of parents
											 
											 (kdnl* 'trace-model-methods "Entering" (class-name-of self)":" self)
											 ;; this provides the setter and getter for this entities variables (they can be passed about too)
											 (let ((my (lambda (x) (slot-ref self x)))
													 (set-my! (lambda (x y)
																	(slot-set! self x y)))
													 ;; it also provides a kernel call function (if it is an <agent> rather than an <object>)
													 (kernel (if (member 'kernel (map car (class-slots (class-of self))))
																	 (slot-ref self 'kernel)
																	 #f))
													 )
												(let ((mm-result
														 (begin
															(void) ;; returns void if there is nothing there...
															,@body) ))
												  (kdnl* 'trace-model-methods "Leaving" (class-name-of self)":" self "with" mm-result)
												  mm-result)
												)
											 )
										  ))
									  ))
							 (add-method ,mname M)
							 (method-register 'add M ',mname )
							 )
						 ))
			 ;;(pp txt) ;; Uncomment this line to dump the macro to stdout on loading
			 txt)))
  )



;;;; NOTE: initialisation takes *only* the self argument and a list of alternating tags and values like: 'name "Wally" 'mass 42 ...
;; (agent-initialisation-method <wombat> (list 'name "wally" 'mass 42)) body....)
;; 
;; madness looks like


"If we take a vertical bar to denote alternatives and ... to denote zero or more of a pattern, the call must look like

   (common-initialisation-method '<object>|'<agent> <classname> (arg ...) 
                                 (no-default-values ...)|(default-values sym val ...) 
        #!rest body)

the list (arg ...) specifies arguments used in the body of the initialiser

"
(define-macro (common-initialisation-method what #!rest madness)
  (let* ((supported '((<object> . "an object") (<agent> . "an agent")))
			(sok (assq what supported)) 
			(ok (and sok (car sok)))
			(okstr (and sok (cdr sok)))
			)
	 (if (not okstr)
		  (Error "common-initialisation-method only works for members of the list" supported))
	 
	 (if (< (length madness) 3) (Error "An initialisation needs at least  three arguments!" madness))

	 (let ((madness madness))
		(if (and (pair? madness) (pair? (car madness)))
			 (begin
				(set! madness (append (list (caar madness) (cdar madness)) (cdr madness)))
				(display (load 'now-loading))
				(dnl* ": The initialiser for" (car madness) "is in a deprecated form, please fix it.")))

		(let* (
				 (cursor madness)
				 (mname 'initialise)
				 (clname #f)          ;; car
				 (args '())           ;; cadr 
				 (default-values '()) ;; caddr
				 (body '())           ;; cdddr
				 )

		  ;;(dnl* "====" what "====")
		  ;;(dnl* 'mname mname)
		  ;;(dnl* 'class-name clname)
		  ;;(dnl* 'args args)
		  ;;(dnl* 'default-values default-values)

		  ;; what is a string like "an object" or "an agent" 

		  ;; (*-initialisation <class> (args...) (no-default-values ...) body ...) ;; , no initialisers
		  ;; (*-initialisation <class> (args...) (default-values 'var val ...) body...) ;; and init vars

		  ;;if this weren't in a macro, a continuation passing style would be best; pity my head is fuzzy.

		  (if (null? cursor)(Error "Empty initialiser!"))
		  (if (pair? (car cursor))
				(Error "Missing class as first argument in definition of initialisation for " (car cursor)  (cdr cursor)))

		  (set! clname (car cursor))
		  (set! cursor (cdr cursor))

		  ;; passed in class args
		  (if (pair? (car cursor))
				(set! args (car cursor)))
		  
		  (set! cursor (cdr cursor))
		  
		  (if (and (pair? cursor)
					  (pair? (car cursor))
					  (member (caar cursor) '(default-values no-default-values)))
				(cond
				 ((eq? (caar cursor) 'default-values) (set! default-values (car cursor)))
				 ((eq? (caar cursor) 'no-default-values) (set! default-values '()))
				 (#t (Error (string-append
								 "expect a list of the form \n\"(default-values 'var val ...)\",\n"
								 "\"(no-default-values 'var val ...)\"\nor \"(no-default-values)\"") (car cursor) (cdr cursor)))
				 ))
		  (set! body (cdr cursor))

		  (if (and #t (not (generic-method-register 'type? ',mname)))
				(begin
				  (display (string-append "********* Instantiating " ,okstr " initialiser ("))
				  (dnl* ',clname ',mname)
				  (display " ...) ********* before the method has been declared (no generic-method)\n")
				  (Error "Check the files declarations.scm and *-declarations.scm" ',clname ',mname)
				  ))

		  (if display-initialisation-signatures
				(let () (display clname ) (display " ") (pp (append (list mname (string->symbol (string-append (symbol->string mname) "-parent")) 'self) args))))

		  (let ((txt `(let ((M (make-method
										(list ,clname) ;; make-method returns a function 
										(lambda (,(string->symbol (string-append (symbol->string mname) "-parent")) self ,@args) ;; Provides "initialise-parent" for the "best match"
										  (let ((initialise-parents (lambda (parentlst #!rest cpargs) (apply call-parents& (append (list ,mname parentlist self ) cpargs)))))
											 ;; provides initialise-parents for arbitrary sets .. may be called more than once, and with different sets of parents
											 (if (and (has-slot? self ',(string->symbol (string-append (symbol->string clname) "-initialized")))
														 (not (eq? #t (slot-ref self ',(string->symbol (string-append (symbol->string clname) "-initialized")) ))))
												  (begin	
													 (kdnl* 'trace-initialisation-methods "Entering initialisation" (class-name-of self)":" self)
													 ;;(dnl* 'trace-initialisation-methods "Entering initialisation" (class-name-of self)":" self)

													 ;; this provides the setter and getter for this entities variables (they can be passed about too)
													 (let ((my (lambda (x) (slot-ref self x))) 
															 (set-my! (lambda (x y)
																			(slot-set! self x y)))
															 ;; it also provides a kernel call function (if it is an <agent> rather than an <object>)
															 (kernel (if (member 'kernel (map car (class-slots (class-of self)))) ;; could use has-slot?, but this illustrates...
																			 (slot-ref self 'kernel)
																			 #f)) ;; <objects> have a kernel set to false
															 )
														(slot-set! self ',(string->symbol (string-append (symbol->string clname) "-initialized")) #t) ;; We place it here to curtail infinite recursion
														
														(if (pair? ',default-values) (set-state-variables self ',default-values) ) ;; don't bother if there are no variable value pairs.
														(let* ((object-result
																  (begin
																	 0 ;; return zero if there is no body
																	 ,@body))
																 )
														  (kdnl* 'trace-initialisation-methods "Leaving initialisation" (class-name-of self)":" self "with" object-result)
														  ;;(dnl* 'trace-initialisation-methods "Leaving initialisation" (class-name-of self)":" self "with" object-result)
														  object-result)
														))
												  0)
											 )
										  )
										))
								  )
							 (add-method ,mname M)
							 (method-register 'add M ',mname )
							 )
						 ))
			 (pp txt) ;; Uncomment this line to dump the macro to stdout on loading
			 ;;(dnl ">>>>>>>>>>>>>>>>>>>>>>>>>\n")
			 txt)
		  )
		)
	 ))

(define-macro (Xobject-initialisation-method #!rest madness)
  ;;(display "******** OBJECT ********\n")
  ;;(pp madness)
  ;;(display "------------------------\n")
  (let* ((txt `(common-initialisation-method <object> ,@madness)))
	 ;;(pp txt)
	 ;;(display "************************\n")
	 txt))
	 

(define-macro (Xagent-initialisation-method #!rest madness)
  ;;(display "******** AGENT ********\n")
  ;;(pp madness)
  ;;(display "***********************\n")
  (let* ((txt `(common-initialisation-method <agent> ,@madness)))
    ;;(display "------------------------\n")
	 ;;(pp txt)
	 ;;(display "************************\n")
	 txt))


(define-macro (Xdefault-object-initialisation clname #!rest doi-margs)
  (dnl* 'DEFAULT-OBJECT-INITIALISATION  clname doi-margs)
  (let ((mname 'initialise)
		  (args '());; Not used
		  (default-values doi-margs)
		  (body '());; Not used
		  )
	 
	 ;;(dnl* "---- default object ----")
	 ;;(dnl* 'mname mname)
	 ;;(dnl* 'class-name clname)
	 ;;(dnl* 'args args)
	 ;;(dnl* 'default-values default-values)
	 
	 (let* ((txt `(common-initialisation-method <object> ,clname ,args ,default-values)))
		;;(pp txt)
		txt)))

(define-macro (Xdefault-agent-initialisation clname #!rest dai-margs)
  (dnl* 'DEFAULT-AGENT-INITIALISATION  clname dai-margs)
  (let ((mname 'initialise)
		  (args '());; Not used
		  (default-values dai-margs)
		  (body '());; Not used
		  )
	 
	 ;;(dnl* "---- default agent ----")
	 ;;(dnl* 'mname mname)
	 ;;(dnl* 'class-name clname)
	 ;;(dnl* 'args args)
	 ;;(dnl* 'default-values default-values)

	 (let* ((txt `(common-initialisation-method <agent> ,clname ,args ,default-values)))
		;;(pp txt)
		txt)))

(define-macro (ddefine a b c d)
  `(begin
	  (define ,a ,b)
	  (define ,c ,d)))



;; "(????-parent)" can be used to invoke the parent methods in the
;; body, where ???? is the value of methname so for a method called
;; "grok" you would use "grok-parent" to invoke the parent method
;; "self" is the name of the agent within the body of the method the
;; state variables are not available but you can use "my" and
;; "set-my!" or "slot-ref" and "slot-set!"


"*** The only difference between an model-method and a model-method is
that model-methods do not keep track of a kernel. "



(define-macro (model-body myclass #!rest body)
  ;; Call like (method classname (mname args) #!rest body) where the args
  ;; doesn't include the call-next-method
  (if (not (symbol? myclass))
		(aborts "model-body: the class " myclass " should be an atom"))
  `(add-method
	 run-model-body
	 (make-method (list ,myclass)
					  (lambda (parent-body self t dt)
						 ;;(dnl* "RUNNING" (slot-ref self 'name) t dt)
						 (kdnl* 'trace-bodies "Entered" (class-name-of self)":"  self (slot-ref self 'name) "at time" t "+" dt)
						 (let ((my (lambda (x) (slot-ref self x)))
								 (set-my! (lambda (x y) (slot-set! self x y)))
								 (kernel (slot-ref self 'kernel))
								 (skip-parent-body ;; (-: We could probably do this in a snazzy way with call-cc, but then we'd have to explain it :-)
								  (lambda ()
									 (set! parent-body (lambda (rslt . args) rslt))
									 ;; forces any call to parent body to just return the indicated result

									 (if (not (slot-ref self 'agent-body-ran)) ;; we test this so that the counter isn't incremented too often
										  (begin
											 (slot-set! self 'counter
															(+ 1 (slot-ref self 'counter)))
											 (slot-set! self 'agent-body-ran #t)))
									 dt) )
								 )
							(let ((body-result
									 (begin
										,@body
										)))

							  (if (not (slot-ref self 'agent-body-ran))
									(begin
									  (slot-set! self 'counter
													 (+ 1 (slot-ref self 'counter)))
									  (slot-set! self 'agent-body-ran #t))
									)
							  (kdnl* 'trace-bodies "Leaving" (class-name-of self)":" self "with" body-result)
							  body-result
							  )
							)
						 )
					  )
	 )
  )

;; like model-body, but chains straight to parent
(define-macro (use-parent-body myclass) 
  `(model-body ,myclass (parent-body)))



(define-macro (sclos-setter myclass variable)
  (if (or (not (symbol? variable))
			 (not (symbol? myclass)))
		(aborts "model-body: the class " myclass " and variable "
				  variable " must be atoms"))
  `(add-method ,(string->symbol
					  (string-append "set-" (symbol->string variable) "!"))
					(make-method (list ,myclass)
									 (lambda (self arg)
										(slot-set! self ',variable arg)))))

(define-macro (sclos-getter myclass variable)
  (if (or (not (symbol? variable)) (not (symbol? myclass)))
		(aborts "model-body: the class " myclass " and variable "
				  variable " must be atoms"))
  `(add-method ,variable
					(make-method (list ,myclass) 
									 (lambda (self)
										(slot-ref self ',variable)))))

(define-macro (load-config)
  `( include "model.config"))


;-  The End 


;;; Local Variables:
;;; mode: scheme
;;; outline-regexp: ";-+"
;;; comment-column:0
;;; comment-start: ";;; "
;;; comment-end:"" 
;;; End:
