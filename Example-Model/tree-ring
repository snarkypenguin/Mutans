; -*- mode: scheme; -*-
;-  Identification and Changes

; Tree ring code.

;	History:
;

;--  Copyright 

;--  Discussion 


"
This implements the arithmetic operations on the ring of trees.
Implemented assuming chibi-scheme/R7RS or a similar implementation.

Test data is kept at the end of the file, since we might use
constructors to generate it.
"

;-  Configuration stuff 

;--  Included files 



(define tr-debugging #f)

;-  Code 

(load "maths.scm") ;; Includes utils.scm
(load "crossproduct.scm")

;-- Supporting code: string and list utilities, simple polynomial arithmetic
;--- Mostly convenience functions, utilities, and mathematical functions
;---- display with implicit newline
(define (dnl . args) (if (null? args) (display "") (let () (map display args) (newline))))
(define (DNL . args) (if debugging (apply dnl args)))

;---- (ddnl . args) a version of dnl that only works if tr-debugging is true
(define (ddnl . args)
  (if tr-debugging
		(apply dnl args)))

;---- Define a random-integer that accepts a "0" argument

;---- Identity function
(define I (lambda (x) x))

(let ((ri random-integer))
  (set! random-integer
		  (lambda (x)
			 (if (and (integer? x) (positive? x)) (ri x)
				  0))))

(define (andf . args)
  (if (null? args)
		#t
		(and (car args) (apply andf (cdr args)))))

(define (orf . args)
  (if (null? args)
		#f
		(or (car args) (apply orf (cdr args)))))

;--- list routines, filter and map routines 

;---- List utilities

(define (n-arity-from-2-arity op identity)
  (lambda args
	 (if (not (list? args)) (error "bad list to generalised operator" args))
	 (let loop ((a args)
					(r identity))
		(cond
		 ((null? a) r)
		 ((= (length a) 1) (op (car a) r))
		 (#t (loop (cdr a) (op (car a) r)))))))



;----- merge-sort from RosettaCode.org
(define (merge-sort l gt?) ;; From Rosetta code
  (define (merge left right)
    (cond
     ((null? left)
      right)
     ((null? right)
      left)
     ((gt? (car left) (car right))
      (cons (car right)
            (merge left (cdr right))))
     (else
      (cons (car left)
            (merge (cdr left) right)))))
  (define (take l n)
    (if (zero? n)
		  (list)
		  (cons (car l)
				  (take (cdr l) (- n 1)))))
  (let ((half (quotient (length l) 2)))
    (if (zero? half)
		  l
		  (merge (merge-sort (take      l half) gt?)
					(merge-sort (list-tail l half) gt?)))))

;----- (flatten-list l) removes all nesting
(define (flatten-list lst)
  (let loop ((l lst)
				 (r '()))
	 (cond
	  ((null? l) (reverse r))
	  ((not (pair? (car l)))
		(loop (cdr l)
				(cons (car l) r)))
	  ((and (pair? l) (pair? (car l)))
		(loop (cdr l)
				(append (reverse (flatten-list (car l))) r)))
	  ((pair? l)
		(loop (cdr l) (cons (car l) r)))
	  (#t 'boink)
	  )
	 ))


;----- (flatten-singletons lst) converts (flatten-singletons '(a)) -> '(a) ; (flatten-singletons '((a) (b) (c d) e)) -> (a b (c d) e)
(define (flatten-singletons lst)
  (cond
	((not (pair? lst)) lst)
	((and (pair? lst) (pair? (car lst)) (null? (cdr lst))) ;; This may be wrong for what I want....
	 (car lst))
	((and (pair? lst) (pair? (car lst)) (null? (cdar lst)))
	 (cons (caar lst) (flatten-singletons (cdr lst))))
	(#t (cons (flatten-singletons (car lst)) (flatten-singletons (cdr lst))))))

;----- (unique lst) returns a list containing only the unique elements

(define (unique lst)
  (let loop ((l lst)
				 (r '()))
	 (if (null? l)
		  (reverse r)
		  (if (not (member (car l) r))
				(loop (cdr l) (cons (car l) r))
				(loop (cdr l) r)))))

;----- (!filter selector lst) -- returns a list of those elements which fail the selector

(define (!filter selector lst)
  (filter (lambda x (not (apply selector x))) lst))


;---- (list-intersection a b) intersection of lists a and b
(define (list-intersection A B)
  (if (not (pair? A)) (set! A (list A)))
  (if (not (pair? B)) (set! A (list B)))
  (let ((f (filter (lambda (x) (member x B)) A)))
	 (if (null? f)
		  '()
		  f)))

;---- String utilities
;----- (string-head s n (string? integer?)) returns the first part of a string
(define (string-head s n)
  (let ((N (string-length s)))
	 (cond
	  ((zero? n) "")
	  ((< n N) (substring s 0 n))
	  (#t s))))

;----- (string-tail s n (string? integer?)) returns the last part of a string
(define (string-tail s n)
  (let* ((N (string-length s))
			(k (- N n)))
	 (cond
	  ((zero? n) "")

	  ((and (>= k 0) < k n)(substring s k N))
	  (#t s))
	 ))

;----- (string-car s) like car, but for strings
(define (string-car s)
  (string-head s 1))

;----- (string-cdr s) like cdr, but for strings
(define (string-cdr s)
  (string-tail s (- (string-length s) 1)))

(define (string-contains? str . targets) ;; (string-contains? "The quick brown fox" "ox" "hen") ==> #t (string-contains? "The quick brown fox" "oxo" "hen") ==> #f
  (if (= (length targets) 1)
      (let* ((st (car targets))
				 (n (string-length st))
				 )
		  (cond
			((< (string-length str) n) #f)
			((string=? (substring str 0 n) (substring st 0 n)) #t)
			(#t (string-contains? (substring str 1 (- (string-length str) 1)) st))))
      (let loop ((st targets))
		  (cond
			((null? st) #f)
			((string-contains? str (car st)) #t)
			(#t (loop (cdr st)))))))

(define (locate-substring str substr)
  (let ((n (string-length substr))
		  (N (string-length str))
		  )
	 (let loop ((k 0))
		(cond
		 ((< N (+ k n) ) #f)
		 ((string=? (substring str k (+ k n)) substr) k)
		 (#t (loop (+ k 1)))))))

;;
;; (strspn str set) returns index of first char not in set
;; (strcspn str set) returns index of first char in set
;;

(define (strspn str set)
  (let loop ((s str))
	 (if (zero? (string-length s))
		  (string-length str)
		  (if (let inner-loop ((chset set))
				  (if (zero? (string-length chset))
						#f
						(if (eq? (string-ref s 0)
									(string-ref chset 0))
							 #t
							 (inner-loop (substring chset 1 (string-length chset))))))
				(loop (substring s 1 (string-length s)))
				(- (string-length str) (string-length s))))))

(define (strcspn str set)
  (let loop ((s str))
	 (if (zero? (string-length s))
		  (string-length str)
		  (if (let inner-loop ((chset set))
				  (if (zero? (string-length chset))
						#t
						(if (eq? (string-ref s 0)
									(string-ref chset 0))
							 #f
							 (inner-loop (substring chset 1 (string-length chset))))))
				(loop (substring s 1 (string-length s)))
				(- (string-length str) (string-length s))))))



;; This silently collapses multiple instances of either spaces or the indicated separator
(define (collapsing-strtok str . separator)
  (if (null? separator)
		(set! separator " ")
		(set! separator (car separator)))

  (if (string? str)
		(let loop ((results '())
					  (sstr str))
		  (if (zero? (string-length sstr))
				results
				(if (zero? (strspn sstr separator))
					 (loop (append results (list (substring sstr 0 (strcspn sstr separator) )))
							 (substring sstr (strcspn sstr separator) (string-length sstr)))
					 (loop results
							 (substring sstr (strspn sstr separator) (string-length sstr)))))))
  )

;; This does not collapse multiple instances of either spaces or the indicated separator 
(define (strtok str . separator)
  (if (null? separator)
		(set! separator " ")
		(set! separator (car separator)))

  (if (string? str)
		(let loop ((results '())
					  (sstr str))
		  (if (zero? (string-length sstr))
				results
				(if (zero? (strspn sstr separator))
					 (loop (append results (list (substring sstr 0 (strcspn sstr separator) )))
							 (substring sstr (strcspn sstr separator) (string-length sstr)))

					 (loop (if (and (> (string-length sstr) 1) (zero? (strspn (substring sstr 1 (string-length sstr)) separator))) results (append results (list "")))
							 (substring sstr 1 (string-length sstr)))))))
  )



;; reconstructs the string either with spaces or the indicated separator

(define (reconstruct-string strarray . separator)
  (if (null? separator)
		(set! separator " ")
		(set! separator (car separator)))

  (if (null? strarray)
		""
		(let loop ((sa (cdr strarray))
					  (ns (car strarray)))
		  (if (null? sa)
				ns
				(loop (cdr sa) (string-append ns separator (car sa)))))))


;; Like strtok, but it separates with a string rather than a set of characters
;; defaults to ","
(define (simple-split-string-at-separator str . separatorstring)
  (let ((sep (if (null? separatorstring)
					  ","	(car separatorstring))))
	 (let ((ns (string-length sep)))
		(let loop ((s str)
					  (r '()))
		  (let ((n (locate-substring s sep)))
			 (if n
				  (loop
				 	(substring s (+ n ns) (string-length s))
					(cons (substring s 0 n) r))
				  (reverse (cons s r))))))))

;; Like strtok, but it separates with a strings rather than a set of characters
;; defaults to ","
(define (simple-split-string-at-separator+ str . separatorstring)
  (let ((sep (if (null? separatorstring)
					  ","	(car separatorstring))))
	 (let ((ns (string-length sep)))
		(let loop ((s str)
					  (r '()))
		  (let ((n (locate-substring s sep)))
			 (if n
				  (loop
				 	(substring s (+ n ns) (string-length s))
					(cons sep (cons (substring s 0 n) r)))
				  (reverse (cons s r))))))))


(define (next-split str separatorstrings)
  (let* ((d (map (lambda (x) (locate-substring str x)) separatorstrings))
			(pairings (map cons d separatorstrings))
			(dl (filter number? d))
			(k (if (null? dl) #f (assoc (apply min (filter number? d)) pairings)))
			)
	 k))


;; Like strtok, but it separates with a set of strings rather than a set of characters
(define (split-string-at-separators str separatorstrings)
  (let loop ((s str)
				 (r '()))
	 (let* ((n-s (next-split s separatorstrings))
			  (n (if n-s (car n-s) #f))
			  (sep (if n-s (cdr n-s) #f))
			  (ns (if n-s (string-length sep) #f)))
		(if n
			 (loop
			  (substring s (+ n ns) (string-length s))
			  (cons (substring s 0 n) r))
			 (reverse (cons s r))))))

;; Like strtok, but it separates with a set of strings rather than a set of characters
(define (split-string-at-separators+ str separatorstrings)
  (let loop ((s str)
				 (r '()))
	 (let* ((n-s (next-split s separatorstrings))
			  (n (if n-s (car n-s) #f))
			  (sep (if n-s (cdr n-s) #f))
			  (ns (if n-s (string-length sep) #f)))
		(if n
			 (loop
			  (substring s (+ n ns) (string-length s))
			  (cons sep (cons (substring s 0 n) r)))
			 (reverse (cons s r))))))

;----- (erode-whitespace string) erode spaces at leading and trailing ends of  strings in lists
(define (erode-whitespace string)
  (let* ((N (string-length string))
			)
	 (if (<= N 0)
		  ""
		  (let ((h (string-ref string 0))
				  (t (string-ref string (- N 1))))
			 (cond
			  ((member h '(#\space #\tab))
				(erode-whitespace (string-cdr string)))
			  ((member t '(#\space #\tab))
				(erode-whitespace (substring string 0 (max 0 (- N 1)))))
			  (#t string))))))




;--- Code for polynomials

"Polynomials are encoded as a list of terms.  Terms are either
constants (numbers), or factors.  Factors are either constants or
lists of length two which are comprised of a symbol and an integer
which represents an exponent. "


;---- Minor predicates: constant? variable? factor? term? polynomial?

(define constant? number?)
(define (variable? x) (and (list? x) (= 2 (length x)) (symbol? (car x)) (number? (cadr x))))
(define (factor? x) (or (constant? x)	(variable? x)))
(define (term? x) (or (constant? x) (apply andf (map (lambda (f) (factor? f)) x))))
(define (polynomial? x)	(or (number? x) (and (string? x) (polynomial? (string->polynomial x))) (apply andf (map term? x))))

(define plus " + ")
(define minus " - ")


;---- Comparison operators

;----- Symbols

;------ symbols: (symbol<? a b)
(define (symbol<? a b)
  (cond
	((and (symbol? a) (symbol? b)) (string<? (symbol->string a) (symbol->string b)))
	(#t (error "Something bad happened in symbol<?" a b))
	))

;------ symbols: (symbol=? a b)
(define (symbol=? a b)
  (equal? a b))

;------ symbols: (symbol<=? a b)
(define (symbol<=? a b)
  (string<=? (symbol->string a) (symbol->string b)))

;----- Factors

(define (testit) (term<? '(7 (m 3) (z 2)) '(4 (a 1) (b 3) (c 3))))


(define (rectify-numbers lst)
  (if (list? lst)
		(map (lambda (x)
				 (if (and (pair? x)
							 (null? (cdr x))
							 (number? (car x)))
					  (car x)
					  x))
			  lst)
		lst
		))



;------ (factor<? a b)  is the "less than" comparison operator for sorting factors within a term
;  This is a single multiplicative element like "4" or (x 2) === "x^2"
(define (factor<? a b) 
  (set! a (rectify-numbers a))
  (set! b (rectify-numbers b))

  (cond
	((and (number? a) (number? b)) (< a b))
	((and (number? a) (pair? b)) #t)
	((and (number? b) (pair? a)) #f)

	((and (pair? a) (pair? b) (number? (car a)) (number? (car b)))
	 (let ((v (factor<? (cadr a) (cadr b)))
			 (w (factor<? (cadr b) (cadr a))))
		
		(cond
		 ((and (not v) (not w)) ;; equality
		  (< (car a) (car b)))
		 ((and v (not w)) ;; less than
		  #t)
		 ((and (not v) w) ;; greater than
		  #f)
		 (#t (error "bad comparison" a b)))))

	((and (pair? a) (pair? b) (number? (car a)))
	 (factor<? (cadr a) b))
	
	((and (pair? a) (pair? b) (number? (car b)))
	 (factor<? a (cadr b)))
	
	((and (pair? a) (pair? b))
	 (let ((n (symbol<? (car a) (car b)))
			 (m (symbol<? (car b) (car a))))
		(cond
		 ((and (not n) (not m)) (< (cadr a) (cadr b))) ;; equality in the symbol
		 (n #t) ;; unambiguously true
		 (m #f) ;; unambiguously false
		 (#t (error "the excluded middle in factor<?" (list a b))))))
	((and (symbol? a) (symbol? b))
	 (symbol<? a b))
	(#t (error "the *other* excluded middle in factor<?" (list a b)))
	)
  )

;------ (factor>? a b)  is the "greater than" comparison operator for sorting factors within a term: good for merge-sort
(define (factor>? a b)
  (factor<? b a))

;------ (factor=? a b) is an equality test 
(define (factor=? a b)
  (if (and (factor? a) (factor? b))
		(not (or (factor>? a b) (factor<? a b)))
		(error "bad input on factor equality test" (list a b))))


;------ (sort-factor! t) side effect: sorts the factors within a term
(define (sort-factor! t)
  (sort! t factor<?))


;----- terms
;------ (fix-factors! t)  sorts (in situ) the factors within the term

(define (fix-factors! t)
  (for-each sort-factor! t))

;------ (term<? a b)  possible side effects! the "less than" comparison operator may also sort the factors in the terms
;; this is not reliable if the factors in the term are not sorted

(define (term<? a b)
  (let ((a (normalise-factors a))
		  (b (normalise-factors b))
		  )

		  ;; terms are of the form [([n] [(fac exp)...])]

		  (cond
		   ((and (null? a) (null? b)) #f)
		   ((and (null? a) (not (null? b))) #t)
		   ((and (not (null? a))  (null? b)) #f)
		  
		   ((and (number? a) (number? b)) (< a b))
		   ((and (number? a) (pair? b))  #t)
		   ((and (pair? a) (number? b))  #f)
		   (#t 
			 (cond
			  ((factor<? (car a) (car b)) #t)
			  ((factor<? (car b) (car a)) #f)
			  
			  ((and (number? (car a)) (number? (car b))) ;; must be the end of the factor
				(or (term<? (cdr a) (cdr b)) (< (car a) (car b))))

				((and (number? (car a)) (pair? (car b)))
				 (or (term<? (cdr a) b) (negative? (car a))))
				
				((and (pair? (car a)) (number? (car b)))
				 (or (term<? a (cdr b)) (not (negative? (car b)))))
				
				((and (pair? (car a)) (pair? (car b)))
					(or (symbol<? (caar a) (caar b))
					  (and (symbol=? (caar a) (caar b)) (< (cadar a) (cadar b)))))

				))
			)
		  ))
			

;------ (term>? a b)  is the "greater than" comparison operator for sorting terms within a term: good for merge-sort
(define (term>? a b)
  (term<? b a))

;------ (term=? a b) is an equality test 
(define (term=? a b)
  (if (and (term? a) (term? b))
		(not (or (term>? a b) (term<? a b)))
		(error "bad input on term equality test" (list a b))))

;------ (polynomial=? p q) -- not fast, but robust
(define (polynomial=? p q)
  (string=? (polynomial->string p) (polynomial->string q)))

(define (polynomial<? p q)
  (if (not (polynomial? p))
		(begin
		  (dnl "polynomial<?: p is buggered\n" p)
		  (error "The first argument is not a polynomial in a call to polynomial<?" p)))
  (if (not (polynomial? q))
		(begin
		  (dnl "polynomial<?: q is buggered\n" q)
		  (error "The second argument is not a polynomial in a call to polynomial<?" q)))

  (let ((a (reverse (normalise-polynomial p)))
		  (b (reverse (normalise-polynomial q))))
	 (cond
	  ((and (null? a) (null? b))  #f)
	  ((and (null? a) (not (null? b))) #t)
	  ((and (not (null? a))  (null? b))  #f)

	  ((and (number? (car a)) (number? (car b)))
		(< (car a) (car b)))
	  ((and (number? (car a)) (not (number? (car b))))
		#t)
	  ((and (not (number? (car a))) (number? (car b)))
		#f)
	  ((term<? (car a) (car b)) #t)
	  ((term=? (car a) (car b)) (polynomial<? (reverse (cdr a)) (reverse (cdr b))))
	  ((term<? (car b) (car a)) #f)
	  (#t (error "ran off the rails in polynomial comparison" p q)))))



(define (node<? n m)
  (cond
	((not (and (node? n) (node? m)))
	 (error "Passed a non-node to node<?" n m))
	((and (null? n) (null? m)) #f)
	((and (null? n) (not (null? m))) #t)
	((and (not (null? n))  (null? m)) #f)

	((polynomial<? (label n) (label m)) #t)
	((polynomial<? (label m) (label n)) #f)
	;; must have equal labels
	((< (weight n) (weight m)) #t)
	((> (weight n) (weight m)) #f)
	;; must have equal weights
	((< (absolute-value n) (absolute-value m)) #t)
	((> (absolute-value n) (absolute-value m)) #f)
	;; must have the same magnitude
	((< (card n) (card m)) #t)
	((> (card n) (card m)) #f)
	;; must have the same cardinality
	((< (depth n) (depth m)) #t)
	((> (depth n) (depth m)) #f)
	;; must have the same depth
	(#t #t)))


;---- manipulation routines for polynomials and their kin
;----- (normalise-factors x) collects common factors in a term
(define (normalise-factors x)
  ;;  (dnl "** " x " " (term? x))
  ;;  (set! x (map (lambda (y) (if (and (pair? y) (null? (cdr y))) (car y) y)) x))
  (let* ((C (filter number? x))
			(F (!filter null? (sort (!filter number? x) factor<?)))
;	(NF (filter (lambda (u) (pair? u) (equal? u (filter number? u))) x))
			(ss (map car F))
			(se (map cadr F))
			(Su (unique ss))
			(Ss (!filter null? (map (lambda (x) (map cdr (filter (lambda (y) (equal? (car y) x)) (map cons ss se)))) Su)))
			(Sr (!filter null? (map (lambda (x y) (list x (apply + y))) Su Ss)))
			)
	 ;;	 (dnl "Input = " x)
	 ;;	 (dnl "Su: " Su)
	 ;;	 (dnl "Ss" Ss)
	 ;;	 (dnl "Sr" Sr)

	 (if (null? C)
		  Sr
		  (cons (apply * C) Sr))
	 ))

;------ (normalise-term x) alias for normalise-factors
(define normalise-term normalise-factors)


;------ (normalise-terms x) collects compatible 

(define (normalise-terms x)
  (let* ((C (filter number? x))
			(T (!filter null? (map normalise-factors (!filter number? x))))
			)
	 (set! C (if (not (null? C)) (apply + C)))

    (let* ((C (filter number? x))
			  (T (!filter number? x)))
		(sort
		 (if (null? C)
			  (!filter null? (map normalise-factors T))
			  (cons (apply + C) (!filter null? (map normalise-factors T))))
		 term<?)
		))
  )


;----- (symbolic-sigs t) generates a signature/signatures for a term or terms  so we can collect compatible terms in polys

(define (symbolic-sigs x)
  (cond
	((polynomial? x)
	 (let* ((X (normalise-terms x))
			  (C (filter number? X))
			  (S (!filter null? (!filter number? X)))
			  (S (map (lambda (y) (!filter number? y)) (!filter null? (!filter number? X))))
			  (V (map (lambda (x) (map car x)) S)) ;; just get the symbolic bit
			  ;;(E (map cadr S))
			  )
		(sort S term<?))) ;; need the exponent too
	((term? x)
	 (car (symbolic-sigs (list x))))
	(#t (error "bad argument to symbolic-sigs" x))
	)	
  )



;----- (matches-sym-sig sig) generates a "filter" function

(define (matches-sym-sig sig)
  (lambda (t)
	 (if (term? t) 
		  (equal? (symbolic-sigs t) sig)
		  (error "matches-sym-sig only works for terms!" x))))

;----- (normalise-polynomial p) adds collecting terms to  normalise-terms

(define (normalise-polynomial P)
  (cond
	((string? P) (string->polynomial P))
	((and (list? P) (polynomial? P))
	 (let* ((p (sort (normalise-terms P) term<?))
			  (C (apply + (filter number? p)))
			  (T (!filter number? p))
			  (Ct (map (lambda (y) (if (null? y) 1 y)) (map (lambda (x) (filter number? x)) T)))
			  (ss (unique (symbolic-sigs T)))
			  (nc-terms (map (lambda (sig)								  
									 (let* ((fl (filter (matches-sym-sig sig) p))
											  (fc (apply + (map (lambda (x) (if (pair? (car x)) 1 (car x))) fl)))
											  )
										(cons fc sig)
										)
									 )
								  ss)))
		
		(if (zero? C)
			 nc-terms
			 (cons C nc-terms))
		
		)
	 )
	(#t (error "normalise-polynomial: Not a polynomial, cannot normalise " P))
	)
  )



;---- arithmetic ops for polynomials

;----- (p+ . ) adds polynomials
(define (_p+ . args)
  (set! args (map polynomial args))
  (if (null? args)
		0
		(normalise-polynomial (apply append (map normalise-polynomial args)))
		)) ; Just too simple for words :-)

(define p+ (n-arity-from-2-arity _p+ 0))

;----- (_t* a b) multiplies terms in polynomials


(define (_t* a b)
  (define (__t* . args)
	 ;;  (if (not (apply andf (map term? args))) (error "non-term passed to _t*" (list args (map term? args))))
	 (rectify-numbers
	  (normalise-factors (apply append (map (lambda (x) (if (pair? x) x (list x))) args)))))
  (__t* a b))

(define (ensure-list lst)
  (map (lambda (x) (if (list? x) x (cons x '()))) lst))

(define (_p* a b)
  (define (__p* . args)
	 (if (not (apply andf (map polynomial? args))) (error "non-polynomial passed to _p*" args))		

	 (set! a (polynomial a))
	 (set! b (polynomial b))

	 (if (string? (car args))
		  (let* ((cp (apply cross* (map string->polynomial args))))
			 (polynomial->string (normalise-polynomial (rectify-numbers (map (lambda (x) (apply _t* x)) cp)))))
		  (let* ((cp (apply cross* (ensure-list args))))
			 (normalise-polynomial (rectify-numbers (map (lambda (x) (apply _t* x)) cp))))))
  (__p* a b))

(define p* (n-arity-from-2-arity _p* 1))
(define (sp* . args) (apply p* (map string->polynomial args)))

;---- polynomial->string routines

;----- (string->term str) maps a term in string form to a polynomial
(define (string->term str)
  "4 a b^3 c^2 d"
  (if (not (string? str))
		str
		(begin
		  (if (or (string-contains? str plus) (string-contains? str minus)) (error "expected term, got polynomial" str))
		  (let* ((l (strtok str))
					(nl (map string->number l))
					(sl (map cadr (filter (lambda (x) (if (not (car x)) (cadr x) #f)) (map list nl l))))
					(st (map (lambda (x)
								  (let ((v (strtok x "^")))
									 (if (= 1 (length v))
										  (list (string->symbol (car v)) 1)
										  (list (string->symbol (car v)) (string->number (cadr v)))
										  ))) sl))
					)
			 (set! nl (filter I nl))
			 (cond
			  ((null? nl) st)
			  ((null? st) (apply * nl))
			  (#t (cons (apply * nl) st)))))))

;----- (string->polynomial pstr) convert a string like 4 + 2 x + 2 x^2 y^3 to (4 (2 (x 1)) (2 (x 2)(y 3)))

(define (string->polynomial pstr)
  (if (not (string? pstr))
		pstr
		(begin
		  (if (or (string-contains? pstr " ^")  (string-contains? pstr "^ "))
				(error " There should be no spaces around the caret (^) operator " pstr))

		  (let* ((str (split-string-at-separators+ pstr '(" + " " - "))))
			 ;;(apply append str-)

			 (let loop ((s str)
							(r '())
							)
				(cond
				 ((null? s) (normalise-polynomial (reverse r)))
				 ((string=? (car s) " - ")
				  (let ((t (string->term (cadr s))))
					 (loop (cddr s)
							 (cons (car (normalise-polynomial (list (append '(-1) t)))) r))
					 ))
				 ((string=? (car s) " + ")
				  (loop (cddr s)
						  (cons (string->term (cadr s)) r)
						  ))
				 (#t
				  (loop (cdr s)
						  (cons (string->term (car s)) r)
						  ))
				 )
				)
			 )
		  )
		))

;----- (latex-term t) generate a string for a term
(define (latex-term t)
  (let* ((c (filter number? t))
			(cn (if (null? c) 1 (apply * c)))
			(cs (number->string cn))
			(s (filter pair? t))
			)
	 (if (null? s)
		  (string-append cs " ") ;; Just a number, no polynomial factors
		  (string-append (if (= 1 cn) "" (string-append "" cs))
							  (apply string-append
										(cons (if (= cn 1) "" " ")
												(map (lambda (f)
														 (string-append
														  (symbol->string (car f))
														  (if (= 1 (cadr f))
																" "
																(string-append "^" (number->string (cadr f)) " ")
																)))
													  s)))
							  ))
	 ))

;----- (latex-polynomial p op cp) generate a string for a polynomial (with appropriate bracketting)
(define (latex-polynomial p op cp)
  (erode-whitespace
	(let* ((p (normalise-polynomial (if (number? p) (list p) p)))
			 (C (apply + (filter number? p)))
			 (t* (map latex-term (!filter number? p)))
			 )
	  (if (null? t*)
			(number->string C)
			;;(string-append op (number->string C) cp)

			(let loop ((t (cdr t*))
						  (s (string-append op (car t*)))
						  )
			  (cond
				((null? t)
				 (if (zero? C)
					  (string-append s cp)
					  (string-append  (number->string C) " + " s  cp)))

				;; non-negative term
				((not (char=? (string-ref (car t) 0) #\-))
				 (loop (cdr t)
						 (string-append s "+ " (car t))))

				;; negative term
				((char=? (string-ref (car t) 0) #\-)
				 (loop (cdr t)
						 (string-append
						  s "- "
						  (substring (car t) 1 (string-length (car t)))))
				 )
				(#t (error "bad polynomial" p))))))))

;----- (polynomial->string p) emit a string corresponding to the polynomial
(define (polynomial->string p)
  (cond
	((string? p) p) ;; we assume it knows what it is doing....
	((polynomial? p) (latex-polynomial p "" ""))
	((polynomial? p) (latex-polynomial p "" ""))
	(#t "")))

;----- (polynomial->inline-string p)  emit a latex inline string corresponding to the polynomial
(define (polynomial->inline-string p)
  (if (polynomial? p)
		(latex-polynomial p "\\(" "\\)")
		""))

;----- (polynomial->display-string p)  emit a latex display string corresponding to the polynomial
(define (polynomial->display-string p)
  (if (polynomial? p)
		(latex-polynomial p "\\[" "\\]")
		""))


;----- (term trm)
(define (term trm)
  (cond
	((string? trm)
	 (term (string->polynomial trm)))
	((term? trm) (normalise-factors term))
	((polynomial? trm)
	 (if (not (= (length trm) 1))
		  #f
		  (car (normalise-polynomial trm))))
	(#t #f)))

;----- (polynomial ply) construct/normalise a polynomial
(define (polynomial ply)
  (cond
	((string? ply) (string->polynomial ply))
	((term? ply) (normalise-polynomial (list ply)))
	((polynomial? ply) (normalise-polynomial ply))
	(#t #f)))


;---- Test polynomials 
(define p0 "1 + 3 y^2 x^3 + 2 + 5 c^2 a c b^3 + 7 3 z^2 m^3")
(define p1 "a b^5 c + 3 x^3 y^2")
(define p2 "1 + x")
(define p3 "3 + 5 b^3 c^3 + 7 m^3 z^2 + 2 x^3 y^2")
(define p4 "4 + 4 a b^3 c^3 + 12 m^3 z^2 + 9 x^3 y^2")
(define p5 "2 + 3 a b^5 c + 5 x^3 y^2")
(define p6 "5 + 3 a b^5 c + 2 x^3 y^2")
(define p7 "2 x^3 y^2")
(define p8 "x^3 y^2 + y^2 z")


(define ply0 (polynomial p0))
(define ply1 (polynomial p1))
(define ply2 (polynomial p2))
(define ply3 (polynomial p3))
(define ply4 (polynomial p4))
(define ply5 (polynomial p5))
(define ply6 (polynomial p6))
(define ply7 (polynomial p7))
(define ply8 (polynomial p8))

(define t0 "3 y^3 x^2")
(define t1 "3 x^3 y^2")
(define t2 "x 4")
(define t3 "y^2")
(define t4 "a")
(define t5 "5 x^3 y^2")
(define t6 "2 x^3 2 y^2 2")
(define t7 "2 x^3 x^2")
(define t8 "x^3 y^2 z")


(define trm0 (term t0))
(define trm1 (term t1))
(define trm2 (term t2))
(define trm3 (term t3))
(define trm4 (term t4))
(define trm5 (term t5))
(define trm6 (term t6))
(define trm7 (term t7))
(define trm8 (term t8))



;-- Code for rings of tree elements (nodes)
"
Nodes are lists of the form 

      (weight polynomial set-of-child-nodes)

and trees are really just collections of related nodes where there is
a root (the node which is (uniquely) the child of no other node in the set).
"


;--- Important "constants": emptyset, zerotree

(define emptyset '())
(define zerotree (list 0 0 emptyset))  ;; [Definition 1]

;--- Accessors: weight label extension extenson-set extension-element 

;---- weight, label and extension-set
(define (weight v)
  (if (null? v)
		0
		(car v)))

(define (label v)
  (if (null? v)
		0
		(cadr v)))


;---- (extension . args) construct an extension set
(define (extension . els)
  (if (apply andf (map node? els))
		(apply list els)
		(error "Bad element(s) in extension set" els)))

;---- (extension-set v) returns the extension set of v
(define (extension-set v)
  (cond
	((null? v) '())
	((node? v) (caddr v))
	((irregular-node? v) (caddr v))
	(#t (error "requested an extension set from the wrong kind of object" v))))


;---- (extension-element v l) the element of the extension set of v with a label l, or the empty set
(define (extension-element V l)
  (let ((v (if (irregular-extension-set? V)
					(normalise-extension-set V)
					V)))
	 (let* ((s (cond
					((null? v) zerotree)
					((extension-set? v) v)
					((node? v) (extension-set v))
					(#t (error "the 'v' argument is not a node or extension set" v))))
			  (r (filter (lambda (x) (equal? l (label x))) s))
			  )
		(if (= (length r) 1) ;; if it is exactly a single element just return that otherwise either a null or a list
			 (car r)
			 r))))

(define (union . args)  (unique (apply append args)))  ;; makes it nice and readable for set operations


;--- Predicates: zerotree? node? tree? simple-node? extension-set?

;---- (zerotree? t) returns #t if t is the zerotree.  We need this because "(equal? '(0 0 '()) zerotree)" may return false
(define (zerotree? t)
  (if (not (node? t)) (error "bad call to zerotree?" t))
  (and (zero? (weight t))
		 (or (null? (cdr t))
			  (null? (label t))
			  (polynomial=? (label t) "(0)"))
		 (or (null? (extension-set t))
			  (apply zerotree? (extension-set t)))))



(define (compatible? n m)
  (or (zerotree? n) (zerotree? m)
		(polynomial=? (label n) (label m))))

;---- (node? n) and (tree? n) 
(define (node? n)
  (cond
	((null? n) #t)
	((not (pair? n)) #f)
	(#t (and (= (length n) 3)
				(number? (weight n))
				(polynomial? (label n))
				(or (null? (caddr n))
					 (apply andf (map node? (caddr n))))
				))
	))

;---- (irregular-node? n) and (tree? n) 
(define (irregular-node? n)
  (and (node n) (irregular-extension-set? (extension-set n))))

(define tree? node?)


;---- (simple-node? n)  node with empty extension set
(define (simple-node? n)
  (and (= (length n) 3) (number? (weight n)) (polynomial? (label n)) (null? (extension-set n))))


;---- (extension-set? E)
(define (extension-set? E)
  (cond
	((null? E) #t)
	((and (apply andf (map node? E))
			(let ((lbls (map polynomial->string (map label E))))
			  (= (length lbls) (length (unique lbls)))))
	 #t)
	(#t #f)) )

;---- (irregular-extension-set? E)
(define (irregular-extension-set? E)
  (cond
	((null? E) #t)
	((and (apply andf (map node? E))
			(not (let ((lbls (map polynomial->string (map label E))))
			  (= (length lbls) (length (unique lbls))))))
	 #t)
	(#t #f)) )

;; (define (extension-set? E)
;;   (let ((r (cond
;; 				((null? E) #t)
;; 				((node? (car E))
;; 				 (extension-set? (cdr E)))
;; 				(#t #f))))
;; 	 r))


;--- Basic constructors: node random-node

;---- (node w p c) ; weight polynomial-label extensions 
(define (node w p c) ; weight polynomial-label extensions 
;;  (ddnl "\nnode: " w " " p " " c)
  (if (not (number? w)) (error "Weight must be a number" w))
  (if (not (polynomial? p)) (error "Label must be a polynomial" p))

  (if (irregular-extension-set? c)
		(set! c (normalise-extension-set c)))

  (if (not (or (null? c)  (apply fand (map node? c))))
		(error "Bad extension set" c))
  
  (list w (polynomial p) c))


;---- (random-polynomial-term L s E)  set-of-labels, scale, max exponent
(define (random-polynomial-term L s E) 
  (cond
	((zero? s) (list 0))
	((zero? E) (list (random-integer s)))
	(#t
	 (let ((e (random-integer E)))
		(list (+ 1 (random-integer s)) ;; we don't want zero coefficients associated with a factor!
				(normalise-polynomial-factors (map (lambda (x) (list (list-ref L (random-integer (length L)))  (+ 1 (random-integer e)))) (seq E))))
		))))


;---- (random-polynomial L S k E)  set-of-labels, Scalar, k terms,  max Exponent
(define (random-polynomial L S k E)
  (let* ((n-terms (random-integer k))
			;;(s (* 2.0 (- (random-real) 0.5) (random-integer S))) ;; scalar part
			(s (random-integer S)) ;; scalar part
			(pt (map (lambda (x) (random-polynomial-term L (+ 1 (random-integer S)) E)) (seq (random-integer k))))
			)
	 (normalise-polynomial (cons s pt))))

;; the polynomial (5 (7 ((x 2) (y 2))) (1 ((x 1) (y 1))) (1 ((x 1) (y 1))))
;; reads as 5 + 7x^2y^2 + xy + xy

;---- (random-node L W w D E z) Labels, Weight, (w)eight param for polynomials,  Depth, E= number param for extensions  terms in poly
;; The weights of nodes will naturally progressively dwindle in the extension sets since at each extension the max weight is drawn from [0-W]
(define (random-node L W w D E z )
  (if (not (and (list? L) (apply andf (map symbol? L)))) (error "bad label list" L))
  (if (not (apply andf (map integer? (list W w D W z))))
		(error "bad numeric argument to random-node" (list W w D E z)))
  
  (node (random-integer W)
		  (random-polynomial L w z)
		  (if (zero? D)
				'() ;; We have bottomed out depth wise
				(let ((e (random-integer E))) ;; 
				  (if (zero? e)
						'()
						(map (lambda (x) (random-node L (random-integer W) w (- D 1) (random-integer (* 2 e)) z)) (seq e))))))
  )

(define (make-zerotree D)
  (if (not (and (not (negative? D)) (integer? D)))
		(error "bad argument to random-zerotree" D))
  (node 0 0 (if (zero? D)	'() ;; We have bottomed out depth wise
					 (list (make-zerotree (- D 1))))))


;--- Simple mathematical functions  
;---- Functions from Definitions 2,3 and 4

;----- (depth tree)  returns the depth of the tree [Definition 2]
(define (depth tree)
  (cond
	((not (tree? tree)) #f)
	((or (null? tree) (zerotree? tree)) 0)
	((null? (extension-set tree)) 1)
	(#t (+ 1 (apply max (map depth (extension-set tree)))))) )

;----- (trim tree) returns a tree with all simple nodes excised [Definition 3]
(define (trim tree)
  (if (simple-node? tree)
		tree
		(node (weight tree) (label tree) (!filter null? (map trim (extension-set tree))))))

;----- (card tree) returns the cardinality of the tree (the number of non-zero nodes [Definition 4]
(define (card tree)
  (if (zerotree? tree)
		0
		(apply + (cons 1 (map card (extension-set tree))))))

;----- (overlap u v) the overlap between two trees [Definition 5]
(define (overlap u v)
  (if (or (null? u) (null? v) (not (equal? (label u) (label v))))
		0
		(+ 1
			(apply + (map (lambda (x) (apply overlap x)) (cross* (extension-set u) (extension-set v)))))))

;------ (shadow u v) returns the part of v in the "shadow" cast by u
(define (shadow u v)
  'nyi)


;---- Set restrictions from Definitions 7 and 8

;----- (L u) returns the set of labels associated with the elements of the set u [Definitions 7 & 8]
(define (L u)
  (cond
	((null? u) emptyset)
	((irregular-extension-set? u) (map label u))
	((extension-set? u) (map label u))
	((node? u) (map label (extension-set u)))
	(#t '())))


;----- (U_v_op f u v) is a generic routine for U_v and U_!v 
(define  (U_v_op f u v)
  (let* ((nu (node? u))
			(nv (node? v))
			(esu (if nu #f (extension-set? u)))
			(esv (if nv #f (extension-set? v)))
			)
	 (cond
	  ((or (null? u) (null? v))
		'())

	  ((and nu nv)
		(U_v_op f (extension-set u) (extension-set v)))

	  ((node? u) (U_v_op f (extension-set u) v))
	  ((node? v) (U_v_op u f (extension-set v)))

	  ((and esu esv)
		(let* ((lu (map polynomial->string (L u)))
				 (lv (map polynomial->string (L v)))
				 (r (map cdr (f (lambda (x) (member (car x) lv)) (map cons lu u)))))
		  ;;;(dnl "U labels: " lu)
		  ;;;(dnl "V labels: " lv)
        ;;;(dnl r)
		  r))
	  (#t '()))))
;----- (L* tree) construct a recursive (label)
(define (L* t)
  (cond
	((null? t) '())
	((node? t) (cons (polynomial->string (label t)) (unique (map L* (extension-set t)))))
	(#t #f)))


;----- (U_v u v) the set of elements in the extension set of u which have a label in (L v) [Definitions 7 * 8]
;;               (the labels in the extn set of v)
(define  (U_v u v)
  (U_v_op filter u v))


;----- (U_!v u v) the set of elements in the extension set of u which do not have a label in (L v) [Definitions 7 & 8]
(define  (U_!v u v)
  (U_v_op !filter u v))

;----- (UandV u v) the set of elements in the extension sets which have labels in both sets 

(define (UandV u v)
  (let ((UnV (list-intersection (map label (extension-set u)) (map label (extension-set v)))))
	 (map (lambda (x)
			  (let ((ux (extension-element u x))
					  (vx (extension-element v x)))
				 
				 (filter (lambda (x y) (pair? x) (pair? y)) ux vx)))
			UnV)))


;--- Mathematical operators on trees from Definitions 6,9
;---- (T*-scalar u v)  Multiplication of trees by scalars  [Definition 6]
(define (T*-scalar u v)
  (cond
	((and (number? u) (number? v)) (* u v))
	((and (number? u) (node? v))
	 (node (* u (weight v)) (label v) (map (lambda (x) (T*-scalar u x)) (extension-set v))))
	((and (number? v) (node? u))
	 (T*-scalar v u))
	((and (node? u) (node? v))
	 (error "Called scalar tree multiplication with two nodes" u v))
	))


(define (nodes-with-label L es)
  (let ((l (cond
				((string? L) L)
				((polynomial? L) (polynomial->string L))
				(#t (error "bad label passed to nodes-with-label" L)))))
  (filter (lambda (x) (string=? (polynomial->string (label x)) l)) es)))

;---- (normalise-extension-set S) returns an extension set which has all nodes with common labels added together
(define (normalise-extension-set S)
  (sort
	(cond
	 ((irregular-extension-set? S)
	  (let ((ll (unique (map polynomial->string (!filter null? (map cadr S))))))
		 (if (equal? (length ll) (length S))
			  S
			  (let ((lst (map (lambda (x)
									  ;;(dnl x ": " (nodes-with-label x S))
									  (nodes-with-label x S)) ll)))
				 (sort (map (lambda (x) (apply T+ x)) lst) node<?) ;; collect compatible trees, sort result
				 )
			  )))
	 ((extension-set? S) S)
	 (#t (error "Not an extension set!" S)))
	node<?)
  )
		  

;---- (_Tc+ u v) add two trees together [Definition 9] 
;; 
;; We might consider treating two trees as weakly compatible when one or both polynomial labels 
;; are zero
;;
(define (T+ u v)
  (cond
	((or (null? v) (zerotree? v)) u)
	((or (null? u) (zerotree? u)) v)
	((not (compatible? u v))
	 (error "Attempted to add incompatible trees" (label u) (label v)))
	((and (node? u) (node? v))
;;	 (dnl "U_!v: "  (U_!v u v))
;;	 (dnl "V_!u: " (U_!v v u))
;;	 (dnl "Intersection: " (list-intersection (map label (extension-set u))
;;															(map label (extension-set v))))

	 (node (+ (weight u) (weight v))
			 (label u)
			 (cond
			  ((and (pair? (extension-set u)) (pair? (extension-set v)))
				(if (list-intersection (map label (extension-set u)) (map label (extension-set u)))
					 (!filter null? (append
										  (U_!v u v)
										  (U_!v v u)
										  (map (lambda (l)
													(T+ (extension-element u l) (extension-element v l))) 
												 (list-intersection (map label (extension-set u))
																		  (map label (extension-set v))))))
					 ))
			  ((pair? (extension-set v))
				(copy-list (extension-set v)))
			  ((pair? (extension-set u))
				(copy-list (extension-set u)))
			  (#t emptyset))))
	(#t (error "Encountered a dragon in addition" u v))))


(define (*T+ . args)
  (if (null? args)
		zerotree
		(T+ (car args) (apply *T+ (cdr args)))))


;---- (box+ B C) [Definition 10]
;; NOTE: seems to work
(define (box+ B C)
  (cond
	((and (node? B) (node? C)) (box+ (extension-set B) (extension-set C)))
	((node? B) (box+ (extension-set B)  C))
	((node? C) (box+ B (extension-set C)))
	(#t  (normalise-extension-set
			(!filter null? (append (U_!v B C)
										  (U_!v C B)
										  (map (lambda (l) (*T+ (extension-element B l) (extension-element C l)))
												 (list-intersection (L B) (L C)))
										  ))))))

(define (T/Z t)
  (let ((nt (if (node? t)
					 (node (car t)
							 (cadr t)
							 (!filter zerotree? (extension-set t)))
					 (error "Got a non-tree!" t))))
	 (if (zerotree? nt)
		  zerotree
		  t)))

;---- (absolute-value t)  returns the absolute magnitude of a tree [Definition 11]
(define (absolute-value t)
  (cond
	((zerotree? t) 0)
	((null? (extension-set t))
	 (abs (weight t)))
	(#t (+ (abs (weight t)) (apply + (map absolute-value (extension-set t)))))))


;---- (boxcross B C) returns the set of trees formed by multiplying elements of B with elements of C [Definition 12]
(define (boxcross B C)
  (cond
	((or (null? B) (null? C)) '())
	((and (node? B) (node? C)) (boxcross (extension-set B) (extension-set C)))
	((node? B) (boxcross (extension-set B) C))
	((node? C) (boxcross (extension-set C) B))
	(#t
	 (if (and (apply andf (map node? B))
				 (apply andf (map node? C)))
		  (let ((b (unique (map T/Z B)))
				  (c (unique (map T/Z C)))
				  )
			 (map (lambda (x) (apply T* x)) (cross* b c))) ;;; This set may contain many nodes with the same label
		  (error "bad argument to boxcross" B C))
	 )))



;---- (sigma p B C) returns the sum of trees with a label p in (boxcross B C) [Definition 12]
(define (sigma p B C)
  "not used here"
  (if (or (null? B) (null? C))
		emptytree
		(extension-element (normalise-extension-set (boxcross B C)) p)))


;---- (box* B C) returns the set of sums for each label in (boxcross B C) [Definition 12]
(define (box* B C)
  (cond
	((or (null? B) (null? C)) '())
	((null? B) C)
	((null? C) B)
	(#t (normalise-extension-set (boxcross B C)))))



;; (define (box* . args)
;;   (if (or (null? args) (> (length args) 2)) (error "sigma requires one or two arguments" args))
;;   (let* ((BxC (if (= (length args) 1) (car args) (apply cross* args)))
;; 			(L (unique (map label BxC)))
;; 			(f (map (lambda (p) (sigma p BxC)) L))
;; 			)
;; 	 ;; each entry in f is a list of elements in a disjoint partition (by label) of B x C
;; 	 f) ;; This should be the set of the sums of the sets of polynomials in f
;;   )

;---- (T* . args) two argument multiplication of trees
(define (T* B C)
  (if (or (zerotree? B) (zerotree? C))
		zerotree
		(node (* (weight B) (weight C))
				(p* (label B) (label C))
				(box* (extension-set B) (extension-set C)))))

;---- (T* . args) n-arity multiplication of trees
(define (*T* . args)
  (case (length args)
	((0) #f)
	((1) (car args))
	((2) (T* (car args) (cadr args)))
	(else (T* (car args) (apply *T* (cdr args))))))
		



;-- Routines for use by models

(define (tree-distance p q)
  (if (compatible? p q)
		(let ((tree (T+ (T*-scalar -1 p) q)))
		  (/ (absolute-value tree)
			  (card tree)))))



;--- (tree->string t . args)

;---
(define (tree->string t . indent)
  (set! indent (if (null? indent) 0 (car indent)))
  (string-append
	(tree->string% t indent)
	"\n"))

;---- (make-space n) makes a string n spaces long for indents
(define (make-space n)
  (make-string n #\space))

;---- (tree->string% t indent) This does the heavy lifting
(define (tree->string% t indent)
  (let ((emit-space #t))
	 (string-append
	  (if (null? t)
			""
			(string-append
			 "(" (number->string (weight t)) 
			 " \"" (if (string? (label t)) (label t) (polynomial->string (label t))) "\""
			 (if (null? (extension-set t))
				  (begin
					 (set! emit-space #f)
					 " ()")
				  (extension-set->string (extension-set t) (+ 2 indent)))
			 (if emit-space (make-space (+ indent 1)) "")
			 ")"
			 )))
	 ))


;--- (extension-set->string es . indent) maps an extension set to a string
(define (extension-set->string es . indent)
  (set! indent (if (null? indent) 0 (car indent)))
  (string-append
	(if (null? es)
		 " ()"		 
		 (string-append
		  "\n"
		  (make-space indent)
		  "("
		  (tree->string (car es) (+ 2 indent))
		  (apply string-append
					(map (lambda (x)
							 (string-append " "
												 (make-space (+ 2 indent))
												 (tree->string x (+ 2 indent))))
						  (cdr es)))
		  (make-space (+ 2 indent))
		  " "
		  ")\n"))))





;--- test trees T0 T[12]a T1a[1234] 

(define T0 (node 0 0 emptyset))
(define T1a (node (random-real) "x + 1" emptyset))
(define T1a1 (node (random-real) "x + 1"
						(extension (node (random-real) "a + 1" emptyset)
									  )
						))
(define T1a2 (node (random-real) "x + 1"
						(extension (node (random-real) "a^2 + 2 a + 1" emptyset)
									  )
						))
(define T1a3 (node (random-real) "x + 1"
						 (extension (node (random-real) "a^2 + 2 a + 1" emptyset)
										(node (random-real) "b^2 + 2 a + 1" emptyset)
										(node (random-real) "b^2 + 4 b + 1" emptyset)
									  )
						))

(define T1a4 (node (random-real) "x + 1"
						 (extension (node (random-real) "a^2 + 2 a + 1" (extension
																						 (node (random-real) "x + 1"
																								 (extension (node (random-real) "a^2 + 2 a + 1" emptyset)
																												(node (random-real) "b^2 + 2 a + 1" emptyset)
																												(node (random-real) "b^2 + 4 c + 1" emptyset)
																												)
																								 )))

										(node (random-real) "b^2 + 2 a + 1" emptyset)
										(node (random-real) "b^2 + 4 c + 1" emptyset)
										)))
						 
(define T2a (node (random-real) "y + 1" emptyset))
(define T2a1 (node (random-real) "y + 1"
						(extension (node (random-real) "a + 1" emptyset)
									  )
						))
(define T2a2 (node (random-real) "y + 1"
						(extension (node (random-real) "a^2 + 2 a + 1" emptyset)
									  )
						))
(define T2a3 (node (random-real) "y + 1"
						 (extension (node (random-real) "a^2 + 2 a + 1" emptyset)
										(node (random-real) "b^2 + 2 a + 1" emptyset)
										(node (random-real) "b^2 + 4 c + 1" emptyset)
									  )
						))

(define T2a4 (node (random-real) "y + 1"
						 (extension (node (random-real) "a^2 + 2 a + 1" (extension
																						 (node (random-real) "y + 1"
																								 (extension (node (random-real) "a^2 + 2 a + 1" emptyset)
																												(node (random-real) "b^2 + 2 a + 1" emptyset)
																												(node (random-real) "b^2 + 4 c + 1" emptyset)
																												)
																								 )

																						 (node (random-real) "b^2 + 2 a + 1" emptyset)
																						 (node (random-real) "b^2 + 4 c + 1" emptyset)
																						 )
												))
						 ))
						 

(define M0 (node 2 "1 + 2 x + x^2" (extension (node 2 "1 + y" emptyset)
															 (node 3 "1 + z" emptyset))))
(define M1 (node 3 "1 + 2 x + x^2" (extension (node 5 "1 + w" emptyset)
															 (node 7 "1 + x" emptyset))))



(define U0 (node 1 "rt" emptyset))
(define V0 (node 1 "rt" emptyset))
;; (U_v U0 V0) should be '()
;; (U_!v U0 V0) should be '() -- both extension sets are empty




(define S1 (node 1 "rt" (extension (node 2.11 "ea" emptyset)
											  (node 2.21 "ea^2" emptyset)
											  (node 2.31 "ea^4" emptyset)
											  (node 2.41 "ea^8" emptyset)
											  )))

(define S2 (node 1 "rt" (extension (node 2.12 "ea" emptyset)
											  (node 2.22 "ea^2" emptyset)
											  (node 2.32 "ea^3" emptyset)
											  (node 2.42 "ea^5" emptyset)
											  )))

(define U1 (node 1 "rt" (extension (node 2.11 "ea" emptyset)
											  (node 2.21 "ea^2" emptyset)
											  (node 2.31 "ea^4" emptyset)
											  (node 2.41 "ea^8" emptyset))))

(define V1 (node 1 "rt" (extension (node 2.12 "ea" emptyset)
											  (node 2.22 "ea^2" emptyset)
											  (node 2.32 "ea^3" emptyset)
											  (node 2.42 "ea^5" emptyset))))

;;########################################################################

(define U2 (node 1 "rt" (extension (node 2.11 "ea" emptyset)
											  (node 2.21 "ea^2" emptyset)
											  (node 2.31 "ea^4" emptyset)
											  (node 2.41 "ea^8" emptyset)
											  (node 2.51 "ea^7" emptyset)
											  )
					  ))
(define V2 (node 1 "rt" (extension (node 2.12 "ea" emptyset)
											  (node 2.22 "ea^2" emptyset)
											  (node 2.32 "ea^3" emptyset)
											  (node 2.42 "ea^5" emptyset)
											  (node 2.52 "ea^7" emptyset)
											  )
					  ))

;;########################################################################

(define U3 (node 1 "rt" (extension (node 2.11 "ea" (extension (node 3.1 "ea" emptyset)))
											  (node 2.21 "ea^2" (extension (node 3.2 "ec^2" emptyset)))
											  (node 2.31 "ea^4" emptyset)
											  (node 2.41 "ea^8" emptyset))))

(define V3 (node 1 "rt" (extension (node 2.12 "ea" (extension (node 3.1 "eb" emptyset)))
											  (node 2.22 "ea^2" (extension (node 3.2 "ed^2" emptyset)))
											  (node 2.32 "ea^4" emptyset)
											  (node 2.42 "ea^8" emptyset))))





;-- Appendix: Miscellaneous routines

(define (tstdl rcg)
  (if (eq? (car rcg) 'ok)
		20160707 ;; success
		#f))



;-  The End 


;;; Local Variables: ***
;;; mode: scheme ***
;;; outline-regexp: ";-+" ***
;;; comment-column:0 ***
;;; comment-start: ";;; " ***
;;; comment-end:""  ***

;;; End:

