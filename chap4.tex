% -*- outline-regexp: "%--* ";  -*-
\message{Chapter 4}

\chapter[A RING-LIKE STRUCTURE OF TREES]{A non-unital ring-like structure of trees}\label{treering}
\section{Introduction}
The project which triggered the development of the structure in this
chapter considered using the modeling of the social dynamics
associated with policies about, and responses to climate change and to
predict the social and economic consequences of development arising
from various scenarios. This was a significant change from previous
representations of ``public'' participants, such as recreational
fishers, tourists, accomodation and other small businesses, which were
modelled in fairly simple ways (\cite{fulton2011ningaloo,gray2014}).
The specific goal was to be able to incorporate a simulation of the
way public opinion changes in response to policy actions and changes
in the economy and environment.  The starting point for this was a
corpus of responses to a survey on attitudes associated with the topic
of climate change (\cite{boschetti2012}). The data consisted of
(largely) numeric answers to individual questions which could
represented as either distinct items, or as an aggregation of symbolic
elements.  Questions like ``How much do trust the following
individuals or organisations to tell you the truth about changing
climate?'' might be encoded in a symbolic way by aggregating the
symbols \textsf{climate\_change, trust, information\_source, AustPeng}
for the trustworthiness of the \emph{Australian Penguins} as a source
of information. The actual value marked could be encoded as a scalar,
giving us an expression like ``\textsf{4/5 + climate\_change +
  information\_source + trust + AustPeng}'' -- expressing it in this
way suggested that working with more intricate relationships might be
possible.

While my involvement in the project was shortlived, the problem the
data posed was engaging, and slowly it became evident how the the
mathematical structures I was trying to construct could represent
configurations of models, and that it might be able to incorporate the
interdependencies between models and other information in a very
simple way.  My hope was to be able to construct example
configurations which were reasonable for particular conditions and to
assess how close to ``known-good'' configurations the system was at
any given point.  It also seemed possible that it might allow
strategies which were apble to interpolate between ``good''
configurations making intermediate transitions between configurations
feasible. The natural network of dependencies exhibited by some
components of past models suggested using tree structures to encode
the configuration of a model as a starting point.

The structure described in this chapter is the structure behind the
work in Chapter \ref{adaptiveselection}.  The trees are comprised of
nodes which have a label and a weight (and, of course, children).
Initially, the labels were simply symbols associated with certain
attitudes or semantic data which were taken from a nominated set.
This had the advantages of simplicity and clarity, but their very
simplicity made the multiplicative operator much more complicated. I
realised that much of the machinery associated with labels was really
just a messy version of arithmetic in commutative ring-like structure of
multinomials. I believe that using the field of rational multinomials
may be productive, but this notion has not been seriously explored.
Once labels were identified with multinomials, everything became
clear.

\section{Conventions and preliminary definitions}

Generally, we will use lower case, boldfaced symbols to denote a node
(or tree), and upper case, boldfaced symbols to denote sets  -- 
particularly sets of nodes.  Other symbols (such as \(x\)) will
typically refer to numbers or \polyrat \polyforms. Elements of a
node, \tnode{u} will be identified using an appropriate subscript,
namely \tnv{u}, for the node's value and \tnlabel{u} for its
label. Initially, the children of a node were thought of as
refinements or children of an attitude, so the children of $\node{u}$
were its children, and \tchild{u} denotes the set of children.  We will
take $\PLY{A}$ to be the \polytypes over the elements of a finite set
of symbols $\set{A}$.  Here $\FIELD$ would usually be some numeric
field such as $\mB{Q, R}$ or $\mB{C}$, for example.

\begin{definition}\label{def-of-dom}
  Given $\set{A}$ and $\PLY{A}$ and an arbitrary field, $\FIELD$, we
  define the set, $\DOMstar$ of finite (acyclic) trees where each node is
  of the form $(\nv{u}, \nlabel{u}, \child{u})$ where the value,
  $\nv{u}$, is a member of $\FIELD$, it's label, $\nlabel{u}$ is
  a member of $\PLY{A}$ and the set of children, $\child{u}$, contains
  leaf nodes with distinct labels.
\end{definition}

Nodes or trees with no children, \(\set{E} = \emptyset\), will be
called \emph{simple nodes, simple trees}, or \emph{leaf nodes}, and
simple nodes which also have scalar multinomials as their labels may
be referred to as \emph{scalar nodes} or \emph{scalar trees}. The
domain of trees, $\DOMstar$, is the collection of only those trees
with a finite number of nodes.  We will make use of a special element
in $\DOMstar$, $\zerotree = (0, 0, \emptyset)$, which is an an
analogue of zero that we will call the \emph{zerotree}.

In this work, we will largely be concerned with a subset of
$\DOMstar$, $\DOM$ which consists only of trees whose root nodes have
a label equal to zero. This subdomain obviously includes \tzerotree,
and will be closed under the arithmetic operations we define. The
other


%% \begin{definition}
%% A node, $\node{u}$, is a representative of a recursive, acyclic
%% structure of the form $(v, p, \set{E})$ where we have $v \in \FIELD, p
%% \in \PLY{A}$, and the children, $\set{E}$, contains nodes of the
%% same for, with the caveat that the labels of the elements must be
%% unique within the set. Without necessarily limiting ourselves, we will
%% take $\FIELD$ to be $\REAL$.  Nodes or trees with \(\set{E} =
%% \emptyset\), the empty set, will be called \emph{simple nodes, simple
%%   trees}, or \emph{leaf nodes}, and simple nodes which also have
%% scalar multinomials as their labels may be referred to as \emph{scalar
%%   nodes} or \emph{scalar trees}. The domain of trees, $\DOM$, is the
%% collection of only those trees with a finite number of nodes.
%% form.
%% %%%, with the caveat that we exclude nodes with \omit{scalar multinomials} and
%% %%%non-empty children.
%% We will make use of a special element in $\DOM$, $\zerotree = (0, 0,
%% \emptyset)$, an analogue of zero which we will call the
%% \emph{zerotree}.

%% The set of valid labels is taken to be a commutative ring of
%% multinomials, $\PLY{A}$. In principle, elements of \emph{any}
%% (commutative) ring could serve equally well.
%% \end{definition}

Note that the choice to use elements of the \polytypes for labels is, in a
sense, arbitrary: elements of any commutative ring will serve, though
we will see that if we use a commutative ring, $\DOM$ and the derived
domains are also commutative; here, the \polytypes provide a
simple example which is easily manipulated and printed. 
$\FIELD$ is taken to be $\mathbb{R}$ or $\mathbb{Q}$.

\begin{definition}\label{compatibility}
Two nodes or trees, $\node{u}$, $\node{v}$ are said to be
\emph{compatible\/} if they have the same label, or at least one has
a label equal to zero.
\[
  \node{u} \sim \node{v} \iff  
  \node{u}\in\set{R}_{\nlabel{v}} \iff 
  \node{v}\in\set{R}_{\nlabel{u}}.
\]
Clearly, all the trees in $\DOM$ are compatible.
\end{definition}

When there is no risk of ambiguity, we will use the same symbol to
refer to a set, $\DOM$ for example, and a vector space based on that
set. Compatibility (or lack thereof) is really only pertinent to the
addition of trees, in the same way that having the same row- and
column-rank is only necessary in matrix addition.  There is no such
constraint in the pairwise multiplication of trees.


First, the definitions for some basic tools for manipulating these
trees. Some of the functions defined below are not used in this chapter, but
play a role in the explicit model described in Chapter \ref{explicitmodel}.

\begin{definition}
  The cardinality of a tree is the number of nodes it contains. We
  define it formally as
  \begin{align*}
  \Tcard{\node{u}} = \begin{cases}
    0 & \text{ if } \node{u} = \zerotree\\
    1 + \sum_{\node{e}\in\child{u}} \Tcard{\node{e}}.
    \end{cases}
  \end{align*}

Simple nodes are the only nodes which have a cardinality of one, and \tzerotree is the only node or tree with a
cardinality of zero.
\end{definition}

\begin{definition}
  For \(\node{u} \in \DOMstar\) we define the function
  \marginnote{\Defn of \(\depth(\node{u})\)}
  \begin{align*}
    \depth(\node{u}) = \begin{cases}
      0 & \text{ if } \node{u} = (0,0,\emptyset) = \zerotree \\
      1 & \text{ if } \node{u} \text{ is a simple node} \\
      1 + \max(\lbrace\depth(\node{v}):\forall \node{v} \in \child{u}\rbrace) & otherwise
    \end{cases}
  \end{align*}
  which gives us the depth of the tree.
\end{definition}

\begin{definition}
  We will also define for \(\node{u} \in \DOMstar\),
  \marginnote{\Defn of \(\trim(\node{u})\)}
  \begin{align*}
      \trim(\node{u}) = \begin{cases}
        \zerotree & \text{ if } \node{u} = \zerotree \\
        \zerotree & \text{ if } \node{u} \text{ is simple} \\
        \Node{\nv{u}}{\nlabel{u}}{\lbrace \trim(\node{e}): \forall\node{e}\in\child{u} \rbrace \setminus \{\zerotree\}} & otherwise.
      \end{cases}
  \end{align*}
\end{definition}

Obviously the $\depth$ is an indication of how many levels of nodes
the tree possesses. Trimming essentially removes all simple nodes from the tree.
\marginnote{\Defn of \(\trim_{k}(\node{u})\)} A recursive application
of trimming will be denoted \(\trim_{k}\), indicating that the tree
\tnode{u} will be trimmed \(k\) times. Note that
\(\trim_{\depth(\node{u})}{\node{u}} = 0\) and
\(\depth(\trim_{\depth{\node{u}}-1}{\node{u}}) = 1\).

\begin{definition}
The \emph{overlap} between two trees is defined
\[
  \overlap(\node{u},\node{v}) = \begin{cases}
    0 & \text{ if } \node{u} = \zerotree \mor \node{v} = \zerotree \mor \nlabel{u} \neq \nlabel{v} \\
    1 + \displaystyle\sum_{\substack{\node{e}\in\child{u} \\
        \node{f}\in\child{v}}} \overlap(\node{e},\node{f}) & \text{otherwise}
  \end{cases}
\]

Clearly two trees, \tnode{u} and \tnode{v}, are compatible if and only if \(\overlap(\node{u},\node{v}) \neq 0 \); they will
be said to \emph{completely overlap} if \(\Tcard{\node{u}} = \Tcard{\node{v}} =
\overlap(\node{u},\node{v})\).
%We may also make use of the relative overlap of two nodes, \tnode{u} and \tnode{v}, given by \[\overlap_{r}(\node{u},\node{v})
%= \frac{2 \overlap(\node{u},\node{v})}{\Tcard{\node{u}}+\Tcard{\node{v}}}.\] The relative overlap of  \tzerotree with itself is
%not defined.
\end{definition}

\begin{definition}
The \emph{shadow} cast by a tree, \tnode{v}, onto another tree,
\tnode{u}, is given by
\[
\shadow(\node{u},\node{v}) = \begin{cases}
  \left(\nv{u},\nlabel{u},\{\shadow(\node{r},\node{s}):\node{r}\in\child{u},\node{s}\in\child{v}\}\setminus\{\zerotree\}\right)&\text{if~}\nlabel{u}=\nlabel{v}\\
  \zerotree&\text{otherwise}
\end{cases}
\]
\end{definition}
This lets us restrict our attention to those parts of a tree which
conform to some ``template'' tree.  

\begin{definition}\label{useful-set-functions}
  We will define a few useful notations for sets derived from sets of
  nodes in $\DOMstar$. Take \(\set{U}\) and \(\set{V}\) be such sets and
  \tnode{a} be a node in $\DOMstar$; then 
  \begin{align*}
      \nlabels{U} &= \{\nlabel{e}: \forall \node{e} \in \set{U}\} \notag\\
      & \notag\\
      \srestrictedto{U}{V} &= \{\node{f} \in \set{U}: \nlabel{f} \in \nlabels{V} \} \notag\\
      \nsrestrictedto{U}{V} &= \{ \node{f} \in \set{U}: \nlabel{f} \notin \nlabels{V} \} \label{restrictions}\notag\\
      \intertext{and}
      a \set{U} &= \{a \node{u}: \forall \node{u} \in \set{U}\} \notag
  \end{align*}
\end{definition}

\begin{definition}\label{useful-node-functions}
  For convenience, we define analogues of several of the above
  relations for nodes to implicitly refer to the children of
  those nodes.

  Let \tnode{u} and \tnode{v} be arbitrary nodes in $\DOMstar$.  Then we
  define the following
  \begin{align*}
      \nlabels{u} &\equiv \nlabels{\child{u}}\\
      \restrictedto{u}{v} &\equiv \restrictedto{\child{u}}{\child{v}}\\
      \nrestrictedto{u}{v} &\equiv \nrestrictedto{\child{u}}{\child{v}}
      %% \node{r} \oplus \node{s} &= \child{r} \oplus \child{s}
  \end{align*}
\end{definition}



Some of these functions are not used in this chapter, but are
presented because they may come into play in constructing software
components used to assess and trigger changes in model configuration. 

%% \begin{definition}
%%   \label{delta-function}
%%   The degree of deviation between two trees, \tnode{u} and \tnode{v} is given  by the expression

%%    \begin{equation}
%%      \delta{\node{u}}{\node{v}} = (1+\nabs{\node{u} - \node{v}})\frac{\Tcard{\node{u}}\Tcard{\node{v}}}{\overlap{\node{u},\node{v})^2} - 1 
%%    \end{equation}
    
%%   The rationale behind this definition is that if trees \tnode{u} and \tnode{v} are identical, then
%%   $\delta{\node{u}}{\node{v}}$ will be zero. We also want nodes that aren't common to both trees to
%%   count as differences.
%% \end{definition}


\section{Scalar Multiplication and addition}

The aim of this work is to be able to compare trees in a robust way
and to manipulate them as though they were vectors: trees which form
a vector space,  or -- better -- a metric space, which can be compared and
clustered. We will start by defining scalar multiplication of the trees in
$\DOM$, and then we will define a few useful mappings which will help
keep the expressions simple. Our aim, in this section, is to define
addition, and to show that the defined scalar multiplication and
addition make this a vector space. When there is no risk of ambiguity,
we will use the same symbol to refer to both the set and
a vector space based on that set.

\subsection{Scalar multiplication and some convenience functions}
\begin{definition}
  For all \(a \in \PLY{A}\) and \(\node{u} \in \DOMstar\), we
  define\marginnote{\(a \node{u}\)}
  \begin{align*}
      a \node{u} = \begin{cases}
        \zerotree  & \text{ if } a = 0 \mor \node{u} = \zerotree \\
        (a \nv{u}, \nlabel{u}, a\child{u}) & \text{ otherwise }
      \end{cases}
  \end{align*}
  where $a\set{A}$ indicates the element-wise product.  Since the
  elements of $\FIELD$ are a subset of $\PLY{A}$ this also defines scalar
  multiplication of trees by elements of $\FIELD$.
\end{definition}

\subsection{Addition}
Now we define the addition of two trees,
\begin{definition}\label{treeaddition}
  For compatible nodes \tnode{u} and \(\node{v} \in \DOMstar\),\marginnote{\(\node{u}+\node{v}\)} 
  \begin{align}
      \node{u} + \node{v} = \begin{cases}
        \node{u} &\text{ if } \node{v} = \zerotree\notag\\
        \node{v} &\text{ if } \node{u} = \zerotree\notag\\
        \Bigl(\nv{u} + \nv{v}, \nlabel{u}, 
        \bigl(\nrestrictedto{u}{v}\cup\nrestrictedto{v}{u} & {} \\
        \quad\cup\{\node{r}+\node{s}:\node{r}\in\restrictedto{u}{v}\mand\node{s}\in\restrictedto{v}{u}\mand\nlabel{r}=\nlabel{s}\}\bigr)\setminus \{\zerotree\}\Bigr) & \text{ otherwise}
      \end{cases}
  \end{align}
\end{definition}

\begin{definition}[Notation]
  We will use the following notation as a more concise representation
  of the addition of two sets, such as the sets of children in
  Eq. \ref{treeaddition}, by
  \begin{align*}
      \set{B}\stplus\set{C} = \childO{B}{C}{r}{s}{+}.
  \end{align*}
\end{definition}
\


\section{Properties of a vector space}
In this section we prove that the defined elements and operations give
us a vector space.  

\begin{proposition}\label{vspace} $\DOM$, with scalar multiplication
  and tree addition is a vector space.
  \begin{proof}
    We will assume that  \(\node{p}, \node{q}, \node{u},\node{v},\node{w} \in \DOM\)\ and \(a, b \in  \FIELD\).

    %%%%%% Delete the vspace if you remove margin notes
    %%\vspace{28pt}
    \begin{description} 
    \item[Additive identity element]\label{additiveidentity}

      This is explicit in the definition of addition between elements
      of $\DOM$.

    \item[Inverse elements with respect to addition]

      The element \(\zerotree\) is its own inverse, since \(\zerotree
      + \zerotree = \zerotree\) by definition.

      So, we consider the case of $\node{u}$, where \(\depth(\node{u})
      = 1\), then
      \begin{align*}
          \node{u} + -\node{u} &=  \Node{\nv{u}}{\nlabel{u}}{\emptyset} + \Node{-1\nv{u}}{\nlabel{u}}{\emptyset} \\
          &= (\nv{u} + -\nv{u}, \nlabel{u}, \emptyset) \\
          &= \zerotree
      \end{align*}
      so for any simple node, \(\node{u}\), \(-\node{u}\)\ is its
      inverse.

      Let \tnode{v} be a non-null node which is not simple, but has
      simple c, that is to say \(\depth(\node{v}) = 2\).  Then 
      \begin{align*}
          \node{v} + -\node{v} &= (\nv{v} - \nv{v}, \nlabel{v}, \lbrace \node{e} + -\node{e}: \forall \node{e} \in \child{v}\rbrace \setminus\{\zerotree\}) \\
          %&= (0, \nlabel{v}, \{\zerotree\} \setminus\{\zerotree\} \\
          &= (0, \nlabel{v}, \emptyset) \\
          &= \zerotree
      \end{align*}
      since the simple leaf nodes are all added to their own additive
      inverse.

      So, we can generalise to trees with a depth
      greater than two. Assuming that the proposition holds for
      elements of $\DOM$ with depth \(n\), we consider an element, \tnode{u},
      where \(\depth(\node{u}) = n+1\) added to the element
      \(-\node{u}\).
      \begin{align*}
          \node{u} + -\node{u} &= (0, \nlabel{u}, \lbrace \node{e} + -\node{e}: \forall \node{e} \in \child{u}\rbrace)
      \end{align*}

      Since the child nodes of the root node of \tnode{u} are, by
      assumption, added to their additive inverses, they then become
      \begin{align*}
          &= (\nv{v} + -\nv{v}, \nlabel{v}, \emptyset) \\
          &= \zerotree
      \end{align*}
      for each \(\node{v}\in\child{u}\) and, by induction, our inverse
      holds for all members of $\DOM$.

    \item[Multiplicative identity element]\label{multiplicativeidentity}

      First observe that \(1\/\zerotree = (1\cdot0,0,\emptyset) = \zerotree\).

      Now consider an arbitrary  non-null tree in $\DOM$, \tnode{u};
      \tnode{u} is either simple, or it has child nodes. In the
      case of a simple \tnode{u}, it is obvious that \(1 \in
      \FIELD\) acts as an identity.
      \begin{align*}
          \node{u} &= (\nv{u}, \nlabel{u}, \emptyset) \\
          &= (1 \nv{u}, \nlabel{u}, \emptyset) \\
          &= 1 (\nv{u}, \nlabel{u},\emptyset) \\
          &= 1 \node{u}
      \end{align*}

      Thus, for all leaf nodes on \tnode{u}, 1 is the identity for
      scalar multiplication. Now we take \tnode{u} to be some
      non-simple node,
      \begin{align*}
          \node{u} &= (\nv{u}, \nlabel{u},\child{u}) \\
          &= (1 \nv{u}, \nlabel{u}, 1 \child{u}) \\
          &= (1 \nv{u}, \nlabel{u}, \lbrace (1 \nv{e}, \nlabel{e}, \child{e}): \forall \node{e} \in \child{u} \rbrace),
      \end{align*}
      and, if the children are all simple nodes,
      \begin{align*}
          &= 1 (\nv{u}, \nlabel{u}, \child{u}) \\
          &= 1 \node{u}.
      \end{align*}
      so it is the case that 1 is the scalar multiplicative identity for nodes which
      have a depths of less than three. 
      
      Now suppose that \(1\) is the identity for scalar multiplication
      of all members of $\DOM$ with a depth of \(n\) or less for some
      natural number \(n\), and we consider \tnode{v} which has a
      depth of \(n+1\). Then
      \begin{align*}
          \node{v} &= (\nv{v}, \nlabel{v}, \child{v}) \\
          &=  (1 \nv{v}, \nlabel{v}, 1\child{v})
      \end{align*}.

      But each of the elements in the set \(1\child{v}\) either has a
      depth of \(n\) or less and so the the children of \(1 \node{v}\)
      is merely \tchild{v}, and so \(1 \node{v} = \node{v}\).

      By induction, we can demonstrate that \(1\) is the 
      identity for scalar multiplication of nodes of arbitrary (finite) depth.


    \item[Commutativity]\label{additivecommutativity}

      Let us consider compatible nodes \tnode{u} and \tnode{v}.

      The commutativity of addition involving \tzerotree is
      guaranteed by the definition of addition, so we first address
      the case where both addends are simple.

      Take \tnode{u} and \tnode{v} to be simple nodes; then
      \begin{align*}
          \node{u} + \node{v} &= (\nv{u}, \nlabel{u}, \emptyset) + (\nv{v}, \nlabel{v}, \emptyset) \notag\\
          &= (\nv{u} + \nv{v}, \nlabel{u}, \emptyset) \notag\\
          &= (\nv{v} + \nv{u}, \nlabel{u}, \emptyset) \notag\\
          &= \node{v} + \node{u}.
      \end{align*}

      Now suppose that there is some number \(n\) for which
      \(\depth(\node{u}) \leq n \mand \depth(\node{v}) \leq n
      \implies \node{u} + \node{v} = \node{v} + \node{u}\).

      Then if we take \tnode{u} and \tnode{v} to be nodes with depths
      of \(n+1\) or less,
      \begin{align*}
          \node{u} + \node{v} &= (\nv{u}, \nlabel{u}, \child{u}) + (\nv{v}, \nlabel{v}, \child{v}) \notag\\
          &= \Bigl(\nv{u} + \nv{v}, \nlabel{u}, \bigl(\{\node{r}+\node{s}: \node{r} \in \restrictedto{u}{v} \mand \node{s} \in \restrictedto{v}{u}\mand\nlabel{r} = \nlabel{s}\} \notag\\
          & \qquad \qquad \qquad \qquad \cup \{\node{r}: \node{r} \in \child{u}\mand\nlabel{r} \notin \nlabels{v}\} \cup \{\node{s}: \child{s} \in \node{v}\mand\nlabel{s} \notin \nlabels{u}\}\bigr) \setminus \{\zerotree\}\Bigr) \notag\\
          &= \Bigl(\nv{u} + \nv{v}, \nlabel{u}, \bigl(\{\node{r}+\node{s}: \node{r} \in \child{u} \mand \nlabel{r} \in \nlabels{v} \mand \node{s} \in \child{v}\mand\nlabel{s} \in \nlabels{u}\} \notag\\
          & \qquad \qquad \qquad \qquad         \cup \nrestrictedto{\node{u}}{v} \cup \nrestrictedto{v}{u}\bigr) \setminus \{\zerotree\}
      \end{align*}
          
      So,
      \begin{align*}
          \node{u} + \node{v} &= \Bigl(\nv{v} + \nv{u}, \nlabel{u}, \bigl(\{\node{r}+\node{s}: \node{r} \in \child{u} \mand \nlabel{r} \in \nlabels{v} \mand \node{s} \in \child{v}\mand\nlabel{s} \in \nlabels{u}\} \notag\\
          & \qquad \qquad \qquad \qquad         \cup \nrestrictedto{\node{u}}{v} \cup \nrestrictedto{v}{u}\bigr) \setminus \{\zerotree\}
      \end{align*}

      since addition in $\DOM$ is commutative. If we can demonstrate
      that the expression for the children is independent of
      order, then it must be the case that sum of the addends,
      \tnode{u} and \tnode{v}, must also be order independent.
      
      The set \(\{\node{r}+\node{s}:\node{r}\in\child{u}\mand\nlabel{r}\in\nlabels{v}\mand\node{s}\in\child{v}\mand\nlabel{s}\in\nlabels{u}\}\) must be
      order independent since each of the candidate \tnode{r} and \tnode{s} addends must have a depth of \(n\) or less. Since set union is
      commutative, the order of \(\nrestrictedto{u}{v}\) and \(\nrestrictedto{v}{u}\) doesn't affect the result, thus, addition must be commutative
      for all \(\node{u} \text{ where } \depth({\node{u}}) \leq n+1\).  By induction, this must be true for all \(n \geq 0\).

    \item[Associativity]\label{additiveassociativity}

      Let us consider compatible nodes \(\node{u}, \node{v}\) and
      \(\node{w}\) in $\DOM$. 

      First consider the situation where the depths of \(\node{u},
      \node{v}\) and \(\node{w}\) are all less than or equal to
      one. If they all have a depth of zero, the sum is trivially the
      null tree. Similarly, if any have depths of one or less is the
      zero tree, we also get a trivial result. So we take all of
      \tnode{u}, \tnode{v}, and \tnode{w} to be simple. Then
      \begin{align*}
          (\node{u}+\node{v})+\node{w} &= ((\nv{u}, \nlabel{u}, \emptyset) + (\nv{v}, \nlabel{u}, \emptyset)) + (\nv{w}, \nlabel{u}, \emptyset) \\
          &= (\nv{u} + \nv{v}, \nlabel{u}, \emptyset) + (\nv{w}, \nlabel{u}, \emptyset) \\
          &= ((\nv{u} + \nv{v}) + \nv{w}, \nlabel{u}, \emptyset) \\
          &= (\nv{u} + (\nv{v}) + \nv{w}), \nlabel{u}, \emptyset) \\
          &= \node{u} + (\node{v} + \node{w}).
      \end{align*}
      
      Let us consider the case where these may be non-simple
      trees. Suppose there is an integer \(n\) such that associativity
      holds for any three trees \(\node{u}, \node{v} \mand \node{w}\),
      whose depth is less than or equal to \(n\), that is if
      \(\depth(\node{u}) \leq n, \depth(\node{v}) \leq n \mand
      \depth(\node{w}) \leq n\),
      then it must be the case that
      \[(\node{u} + \node{v}) + \node{w} = \node{u} + (\node{v} + \node{w}).\]

      Now suppose one or more of these trees has a depth of
      \(n+1\).
      
      % Just the set
      %% \bigl\{\nrestrictedto{u}{v} \cup \nrestrictedto{v}{u} \\
      %% &\qquad\quad \cup \hspace{2pt} \{\node{r} + \node{s}:  \node{r} \in \restrictedto{u}{v}\mand \node{s} \in \restrictedto{v}{u} \} \bigr\} \setminus \{\zerotree\}

      \begin{align*}
          (\node{u}+\node{v})+\node{w} &= (\Node{\nv{u}}{\nlabel{u}}{\child{u}} + \Node{\nv{v}}{\nlabel{u}}{\child{v}}) + \Node{\nv{w}}{\nlabel{u}}{\child{w}} \\
          &= \Node{\nv{u} + \nv{v}}{\nlabel{u}}{\child{u}\stplus\child{v}} + \Node{\nv{w}}{\nlabel{u}}{\child{w}}
      \end{align*}

      Recall that 
      \begin{align*}
          \child{u}\stplus\child{v} &= \childO{u}{v}{p}{q}{+}\\
          \intertext{so, letting}
          \set{B} &= \child{u}\stplus\child{v} \\
          \intertext{we get}
          (\node{u}+\node{v})+\node{w} &=\NNNode{(\nv{u} + \nv{v}) + \nv{w}}{\nlabel{u}}{\bigl(\nsrestrictedto{B}{w}\cup\nrestrictedto{w}{B} \cup \set{B}\stplus\child{w}\bigr)\setminus\{\zerotree\}} \\
          &=\NNNode{\nv{u} + (\nv{v} + \nv{w})}{\nlabel{u}}{\bigl(\nsrestrictedto{B}{w}\cup\nrestrictedto{w}{B}\cup \set{B}\stplus\child{w}\bigr)\setminus\{\zerotree\}} \\
          \intertext{since addition in $\DOM$ is associative for nodes
          with a depth of $n$ or less}
      \end{align*}

      Notice that the elements of all the sets which comprise the children, those in \(\set{B}\) and in \tchild{w},
      must have a depth of \(n\) or less; any addition which occurs amongst the elements of these sets must be
      associative by our inductive assumption. Hence
      \begin{align*}
          (\node{u}+\node{v})+\node{w} = \node{u}+(\node{v}+\node{w}).
      \end{align*}


    \item[Compatibility of scalar multiplication and multiplication in $\FIELD$]\label{additivecompatibility}

      Observe first that \(a \zerotree = \zerotree, \forall a \in
      \FIELD\). We also dispose with the case of simple nodes:
      \begin{align*}
          a(b \node{u}) &= (a(b \nv{u}), \nlabel{u}, \emptyset) \\
          &= (a b \nv{u}, \nlabel{u}, \emptyset) \\
          &= ((a b) \nv{u}, \nlabel{u}, \emptyset) \\
          &= (a b) \node{u};
      \end{align*}

      So assuming that multiplication is compatible with nodes with
      depths of \(n\) or less, we consider \tnode{u}, where \(\depth(\node{u})
      = n+1\),
      \begin{align*}
        a (b \node{u}) &= a (b  \nv{u}, \nlabel{u}, b\child{u}) \\
        \intertext{since \(\depth(\node{e}) \leq n \forall \node{e}\in \child{u}\), multiplication of these elements is compatible, and }
          &= (a b\/ \nv{u}, \nlabel{u}, a(b\child{u})) \\
          \intertext{becomes}
          &= ((a b) \nv{u}, \nlabel{u}, (a b)\child{u}) \\
          &= (a b) \node{u}
      \end{align*}

      Thus the scalar and field multiplication operators are compatible.

      
    \item[Distribution of scalar multiplication with respect to vector addition]\label{additivedistributivity}

      Let us consider compatible trees, \tnode{u} and \tnode{v}.
      
      First, note that \[\forall \node{u} \in \DOM, a(\zerotree + \node{u}) = a \node{u} = a\zerotree + a \node{u},\]
      and that \[\forall \node{u},\node{v}\in\DOM, 0 (\node{u} + \node{v}) = \zerotree = 0 \node{u} + 0 \node{v}.\]

      The property holds for simple nodes, 
      \begin{align*}
        a(\node{u} + \node{v}) &= a (\Node{\nv{u}}{\nlabel{u}}{\emptyset} + \Node{\nv{v}}{\nlabel{v}}{\emptyset})\\ 
        &= a \Node{\nv{u} + \nv{v}}{\nlabel{u}}{\emptyset} \\
        &= \Node{a(\nv{u} + \nv{v})}{\nlabel{u}}{\emptyset} \\
        &= \Node{a\nv{u} + a\nv{v}}{\nlabel{u}}{\emptyset} \\
        &= \Node{a\nv{u}}{\nlabel{u}}{\emptyset} + \Node{a\nv{v}}{\nlabel{u}}{\emptyset} \\
        &= a \node{u} + a \node{v}
      \end{align*}.

      So, suppose that the equation \(a ( \node{p} + \node{q}) =
      a \node{p} + a \node{q}\) holds for all compatible nodes \tnode{p} and
      \tnode{q} such that \(depth(\node{p}) \leq k\), and
      \(\depth(\node{q}) \leq j\).

      Take \(n = \min(j, k)\), \(a\in\FIELD\), and nodes \tnode{u} and \tnode{v} such that
      \(\depth(\node{u}) = n+1\), and \(\depth(\node{v}) = n+1\).
      Note that \(n\) must be greater than zero since the property holds for simple
      nodes.  Then
      \begin{align*}
        a(\node{u} + \node{v}) &= a (\Node{\nv{u}}{\nlabel{u}}{\child{u}} + \Node{\nv{v}}{\nlabel{v}}{\child{v}}\\ 
        &= a \bigl(\nv{u} + \nv{v}, \nlabel{u}, \bigl\{\nrestrictedto{u}{v} \cup \nrestrictedto{v}{u} \\
        &\qquad \cup \hspace{2pt} \{\node{r} + \node{s}:  \node{r} \in \restrictedto{u}{v}\mand \node{s} \in \restrictedto{v}{u} \} \bigr\} \setminus \{\zerotree\} \bigr) \\
        &= \Bigl(a (\nv{u} + \nv{v}), \nlabel{u}, 
        \bigl\{\{a \node{e}: \node{e} \in \nrestrictedto{u}{v}\} \cup \{a \node{e}: \node{e} \in \nrestrictedto{v}{u}\} \\
        &\qquad \cup \hspace{2pt} \{a (\node{r} + \node{s}):  \node{r} \in \restrictedto{u}{v}\mand \node{s} \in \restrictedto{v}{u} \} \bigr\} \setminus \{\zerotree\} \bigr)\Bigr) \\
        &= \Bigl(a \nv{u} + a \nv{v}, \nlabel{u},  
        \bigl\{\{a \node{e}: \node{e} \in \nrestrictedto{u}{v}\} \cup \{a \node{e}: \node{e} \in \nrestrictedto{v}{u}\} \\
        &\qquad \cup \hspace{2pt} \{a (\node{r} + \node{s}):  \node{r} \in \restrictedto{u}{v}\mand \node{s} \in \restrictedto{v}{u} \} \bigr\} \setminus \{\zerotree\} \bigr)\Bigr)
      \end{align*}.

      Notice that the component sets of the set of children to \(\node{u} +
      \node{v}\), namely \(\{a \node{e}: \node{e} \in
      \nrestrictedto{u}{v}\}\),  
      \(\{a \node{e}: \node{e} \in
      \nrestrictedto{v}{u}\}\) and \(\{a (\node{r} + \node{s}):
      \node{r} \in \restrictedto{u}{v}\mand \node{s} \in
      \restrictedto{v}{u} \}\) can only contain nodes with a depth of
      \(n\) or less; Thus, we can proceed inductively, increasing
      the least upper bound, \(\min(j, k)\), for the set of trees
      that cooperate with distribution of scalar multiplication over
      vector addition, to any value we wish.

    \item[Distribution of scalar multiplication with respect to
      addition in $\FIELD$ ]\label{distribution}

      The property is clearly true when \(\node{u} = \zerotree\),
      since \((a+b)\zerotree = \zerotree = a\zerotree+b\zerotree\).

      We first consider simple nodes:
      \begin{align*}
        (a + b)\node{u} &= (a + b) ((a + b)\nv{u}, \nlabel{u}, \emptyset) \\
        &= ((a + b)\nv{u}, \nlabel{u}, \emptyset) \\
        &= (a\nv{u}, \nlabel{u}, \emptyset) + (b  \nv{u}, \nlabel{u}, \emptyset) \\
        &= a \node{u} + b \node{u}.
      \end{align*}

      Nodes with a depth of two are slightly more complicated, 
      \begin{align*}
          (a + b)\node{u} &= (a + b) ((a + b)\nv{u}, \nlabel{u}, (a + b)\child{u}) \\
          &= (a\nv{u} + b  \nv{u}, \nlabel{u}, \{(a + b)\node{e}:\node{e}\in\child{u}\}) \\
          \intertext{but \(\child{u}\) is composed of simple nodes, so,}
          &= (a\nv{u} + b  \nv{u}, \nlabel{u}, \{a \node{e} + b \node{e}:\node{e}\in\child{u}\}) \\
          &= (a\nv{u} + b  \nv{u}, \nlabel{u}, a\child{u}) + (b  \nv{u}, \nlabel{u}, b\child{u}) \\
          &= a \node{u} + b \node{u}.
      \end{align*}
      %% a \node{e} + b \node{e} = (a + b) \node{e} because nodes in the
      %% children only contribute (add to something non-zero) if they
      %% have the same label, and there are no oddities that appear in
      %% one addend and not the other.(modulo the scalars)

      
      Now suppose the property holds for nodes with a depth of \(n\).
      Then we consider node \(\node{u}\) with a depth of \(n+1\):
      \begin{align*}
          (a + b)\node{u} &= (a + b) (\nv{u}, \nlabel{u}, \child{u}) \\
          &= ((a + b)\nv{u}, \nlabel{u}, (a + b)\child{u}), \\
          &= (a\nv{u} + b  \nv{u}, \nlabel{u}, \{a \node{e} + b \node{e}:\node{e}\in\child{u}\}) \\
        \intertext{since \(\depth(\node{e}) = n\)}
          &= a \node{u} + b \node{u}.
      \end{align*}

      %% Suppose there is an element \(\node{v} \in \child{u}\)\ where
      %% this is not the case. It cannot be the case that \((a + b)\nv{v}
      %% \neq a\nv{v} + b  \nv{v}\)\ since all three addends are in $\FIELD$,
      %% so there is some must be some node in \tchild{v}, say \tnode{g},
      %% for which \((a + b)\node{g} \neq a \node{g}+b \node{g}\). This
      %% process continues till we reach a simple node (as we must) with
      %% an empty children, so we must conclude that the assumption
      %% is false; there can be no element in the an children for
      %% which \((a+b)\node{e} \neq a \node{e}+b \node{e}\).
      
      %% So 
      %% \begin{align*}\label{Dsmf4}
      %%     (a + b)\node{u} &= (a\nv{u} + b  \nv{u}, \nlabel{u}, 
      %%     \{(a\nv{e} + b  \nv{e}, \nlabel{e}, \{a \node{e} + b \node{e}):
      %%     \node{e} \in \child{u}\}) \\
      %%     &= a \node{u} + b \node{u} \\
      %% \end{align*}

      %%    (a + b)\node{u} &= (a\nv{u} + b  \nv{u}, \nlabel{u},
      %%    \{(a\nv{e} + b  \nv{e}, \nlabel{e}, a\child{e} + b\child{e}): \node{e} \in \child{u}\}), \\


      %% The justification for splitting the sum of the terms from the children rests on the observation that we may
      %% deal with the simple nodes by appealing to the first part of this section of the proof. The non-simple nodes, can
      %% be expanded and dealt with using the same strategy used for \tnode{u}, and the fact that we are dealing with
      %% finite, trees means that along any branch we must eventually exaust the supply of non-simple nodes,
      %% leaving us with simple terminal nodes which are of the form \(a \node{u} + b \node{u}\). In this way the elements of
      %% very non-simple node's children *********
    \end{description}
    By induction, the property must hold for all \(n >= 0\)
  \end{proof}
\end{proposition}


\section{Seminorms, norms and metrics} %

Now that we have a vector space, we can construct model configurations
as linear combinations of basis configurations. In the context of models
which change their configuration, we need a way for the model itself
to combine basis configuration trees by choosing from a set of
configurations that are known to exhibit suitable properties.  To this
end, we need a mechanism for judging how close or far a given
configuration is from where it needs to be -- we need a way to
decompose an extant, running configuration into its basis elements,
and then map these to some provably more appropriate configuration.
To do this, our structure needs to be a metric space.

% Seminorm: triangle inequality, |a|||v|| = ||av|| ... note |a| = 0
We will now construct a seminorm on the vector space
$\DOM$. This will induce a norm on a quotient space of $\DOM$ which we
can use as a tool for assessing the similarity of trees and,
ultimately, provide both a means of clustering trees and selecting
trees with particular properties.

\subsection{$\DOM$ and its classwise seminorm}
\begin{definition}\label{absolute-mag}
\marginnote{Absolute value: \(\nabs{\node{u}}\)} We define the absolute value of a node to be
\begin{align*}
\nabs{\node{u}} = \begin{cases}
  0 & \text{ if } \node{u} = \zerotree \\
  \abs{\nv{u}} & \text{ if }\child{u} = \emptyset \\
  \abs{\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}} & \text{ otherwise.}
\end{cases}
\end{align*}
\end{definition}
%\begin{remark}
The absolute magnitude is only based only on the values of the
nodes of trees. % This corresponds to the $L^1$ norm on the tree space.
Note that each node in a tree can only contribute a non-negative
quantity to the absolute value of the tree, it is obvious that
\(\nabs{\node{u}} \geq 0\)\ for all \(\node{u} \in \DOM\)\ and that
equality only occurs if the weight of each node in the tree \tnode{u}
is zero.\footnote{\ldots Or, alternatively, the absolute value of every subtree is zero.}
%\end{remark}

For any two trees (including those with dissimilar labels) we can
define a function analogous to a distance.

\begin{definition}\label{treenorm}\typeout{---tree-norm}
  We will define a semi-norm on the trees:
  %%If we take $\term(\poly{p})$ to be the set of terms in $\poly{p}$,
  %%then we define
  \begin{equation}
    %\prennorm{\node{u}}={\label{u} +
    %    \stsum{\poly{t}\in\term(\nlabel{u})}\abs{\coeff({t})}^2+\stsum{\node{c}\in\child{u}}\prennorm{\node{c}}},
    \prennorm{\node{u}}={\abs{\nv{u}}^2 + \stsum{\node{v}\in\child{u}} \prennorm{v}}
  \end{equation}
  and we define the norm in terms of this with
  \begin{equation}
    \nnorm{\node{u}}=\sqrt{\nnorm{\node{u}}}.
  \end{equation}
\end{definition}

Both of these functions clearly have non-negative ranges, and they
only take the value zero if all the node values and the node labels
are zero.  Since we restrict ourselves to finite, acyclic trees, we
can argue that for any finite set of $n$ trees, we can construct an
equivalent vector-based representation of the set by serialising the trees.
The defined norm is precisely equivalent to the usual length
of vectors in this set.
%% \footnote{The fact that we can construct a total order
%%   on trees makes this quite straightforward
%%   [c.f. Chapter\ref{explicitmodel}, Section \ref{partial-order}]}
In the example model discussed in Chapter~\ref{explicitmodel} we 
make use of both this norm and the distance function
$\nnorm{\node{u}-\node{v}}$.

\begin{proposition}\label{absolutehomogeneity}
  For \(a \in \FIELD\) and \(\node{u} \in \DOM, \abs{a}\nabs{\node{u}} =
  \nabs{a \node{v}}\).
\begin{proof}
  The magnitude of the empty tree is trivially zero, so \(\abs{a}\nabs{\zerotree} =
  \nabs{a\zerotree} = 0\).

  Consider simple nodes in $\DOM$:
  \begin{align*}
      \abs{a}\nabs{\node{u}} &= \abs{a}(\abs{\nv{u}} + 0) \\
      &= \abs{a}\abs{\nv{u}} \\
      &= \nabs{a \node{u}}.
  \end{align*}

  Now suppose that there is \(n \ge 1\) such that the proposition is true for
  all trees with a depth of \(n\) or less. Then, taking \(\node{u} \in
  \DOM\) where \(\depth(\node{u}) = n+1\), we have
  \begin{align*}
      \abs{a}\nabs{\node{u}} &= \abs{a}\bigl((\abs{\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}})\bigr) \\
      &= \abs{a}\abs{\nv{u}} + \sum_{\node{e}\in\child{u}}\abs{a}\nabs{\node{e}}\\
      \intertext{but all the elements in \(\child{u}\) have a depth of \(k\) or less}
      &= \abs{\abs{a}\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{\abs{a}\node{e}} \\
      &= \abs{a\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{a \node{e}} \\
      &= \nabs{a \node{u}}.
  \end{align*}

  By induction, the proposition must be true for all \(n \geq 0\).
\end{proof}
\end{proposition}


\begin{proposition}\label{triangle1}
  For \(\node{u} \mand \node{v} \in \DOM, \nabs{\node{u} + \node{v}}
  \leq \nabs{\node{u}} + \nabs{\node{v}}\).

\begin{proof}
  We start by considering trees of depths zero and one. The case for null trees is trivial: \(\nabs{\zerotree +
    \zerotree} = \abs{0 + 0} = 0\), and if only one of the trees has a depth of one, we get either \(\nabs{\node{u} +
    \zerotree} = \nabs{\node{u}}\) or \(\nabs{\zerotree + \node{u}} = \nabs{\node{u}}\).

  For \(\node{u} \mand \node{v}\)  with depths of one, \[\nabs{\node{u} + \node{v}} = \nabs{(\nv{u}+\nv{v}, \nlabel{u}, \emptyset)}= \abs{\nv{u}+\nv{v}}.\]
  Since \tnv{u} and \tnv{v} are scalars in $\FIELD$, we must have
  \(\abs{\nv{u} + \nv{v}} \leq \abs{\nv{u}}+\abs{\nv{v}}\),
  so \[\abs{\nv{u}+\nv{v}} \leq \abs{\nv{u}}+\abs{\nv{v}} = \nabs{\node{u}} + \nabs{\node{v}}.\]

  We will now proceed by induction; let \(n\) be a positive integer for which the triangle inequality holds for all
  trees with a depth of \(k\) or less.  Let's consider compatible trees, \tnode{u} and \tnode{v} whose depths are less
  than or equal to \(n+1\). Then
  \begin{align*}
      \nabs{\node{u} + \node{v}} &= \nabs{(\nv{u} + \nv{v}, \nlabel{u}, \child{u}\stplus\child{v})} \\
      &= \Bigl[\abs{\nv{u} + \nv{v}} + \mstsum{\node{e}\in{\child{u}\stplus\child{v}}}\nabs{\node{e}}\Bigr]. \\
  \end{align*}
  
  Observe that \(\abs{\nv{u} + \nv{v}} \leq \abs{\nv{u}} + \abs{\nv{v}}\), and that each 
  of the addends in \[\sum_{\node{e}\in{\child{u}\stplus\child{v}}}\nabs{\node{e}}\] has a depth of \(n\) or
  less, so 
\begin{align*}
  \sum_{\node{e}\in{\child{u}\stplus\child{v}}}\nabs{\node{e}} &\leq \sum_{\node{e}\in{\child{u}}}\nabs{\node{e}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}.\\
  \intertext{ This implies that}
   \nabs{\node{u} + \node{v}} &\leq \Bigl[\abs{\nv{u}} + \abs{\nv{v}} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}\Bigr];\\
   \intertext{rearranging we get}
   \nabs{\node{u} + \node{v}}  &\leq \Bigl[\abs{\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}}\Bigr] + \Bigl[\abs{\nv{v}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}\Bigr] \\
   \intertext{and hence}
   \nabs{\node{u} + \node{v}} \leq \nabs{\node{u}}  + \nabs{\node{v}}.
\end{align*}
\end{proof}
\end{proposition}

\begin{corollary}\label{gseminorm}
  The absolute value forms a seminorm on $\DOM$.
  \begin{proof}  
    Propositions, \ref{absolutehomogeneity} and \ref{triangle1}, are 
    sufficient for the absolute value to be a seminorm on
    $\DOM$.
  \end{proof}
\end{corollary}

At this point we should consider the elements
$\node{o} \in \DOM$
which are analogues of zero. We define the set
$\nullspace =\{\node{o}\in\DOM: \nabs{\node{o}} = 0\}$,
and observe that for any
$\node{e} \in \DOM, \mand \node{o} \in \nullspace$
the equation
$\nabs{\node{e} + \node{o}} = \nabs{\node{e}}$
must hold. 

Since $\DOM$ is a seminormed vector space, it is also a pseudometric
space and we can induce a fully fledged metric space over the quotient
space $\DOMQ = \DOM / \nullspace$.

For simplicity, we identify the coset of $\nullspace$ with respect to
$\zerotree$ with $\rzerotree$, and we take the induced metric on the
normed vector space $\DOMQ$, to be
\[\dist(\qnode{u},\qnode{v}) =
\nabs{\qnode{u} - \qnode{v}} \text{ for all }\qnode{u}, \qnode{v} \in
\DOMQ.\]  We will continue to use \(\nabs{\rnode{u}}\) to denote the
the induced absolute value of \(\rnode{u}\in\DOMR\).

%% \subsection{Multiplication of elements in $\DOMQ$}
%% \begin{definition}\label{treemultiplication}
%%   The product of two elements $qnode{u}, \qnode{v}\in \DOMQ$
%%     is defined by
%%   \begin{align*}
%%     \qnode{u} \qnode{v} = \begin{cases}
%%       \zerotree & \text{ if either factor is } \zerotree \\



\section{Element multiplication in $\DOMR$ and establishing the
  properites similar to those of a ring}

In this section, we will define a multiplicative operator for
trees. My motivation for establising these properties is mainly that
it may broaden the set of mathematical tools we have at our
disposal to analyse sets of trees (clustering, classification,
interpolation, extrapolation\ldots).  The element \((1,1,\emptyset)\)
acts as a multiplicative identity, but this will not be useful to us
since it lies outside the domain we are considering.

\begin{definition}\label{rtreemult}
  We define the multiplication of two trees (or nodes) to be
  \[
  \rnode{u} \tdot \rnode{v} = \begin{cases}
     \rzerotree & \text{ if } \rnode{u} = \rzerotree \mor \rnode{v} = \rzerotree \\
     (\rv{u} \rv{v}, \rlabel{u} \rlabel{v}, \rlabel{u} \rchild{v} \stplus \rlabel{v} \rchild{u}) & \text{  otherwise}.
  \end{cases}
  \]
  
\end{definition}    

where the notation $\rlabel{u} \rchild{v}$or $\rchild{v} \rlabel{u}$ corresponds to the set
obtained by multiplying each label in the root node of the set
$\rchild{v}$ by the label $\rlabel{u}$. Clearly, if the set in the
operation (on either side) is null, then the result is null.

\begin{proposition}
  $\iota = (1, 1, \emptyset)$ commutes with all other nodes, is the
  multiplicative identity, and it is unique, 
  \begin{proof}
    Let $\rnode{v}$ be some arbitrary tree, then
    \begin{align*}
      (\rv{v},\rlabel{v},\rchild{v})\tdot \iota &= (\rv{v}  1, \rlabel{v} 1, \rchild{v} 1 \stplus \emptyset \rlabel{v}) \\
      &= (1 \rv{v}, 1 \rlabel{v}, 1 \rchild{v} \stplus \rv{v} \emptyset) \\
      &= (1 \rv{v}, 1 \rlabel{v}, \rv{v} \emptyset \stplus 1 \rchild{v}) \\
      &= (1 \rv{v}, 1 \rlabel{v}, 1 \rchild{v}) \\
      &= \iota\tdot(\rv{v}, \rlabel{v}, \rchild{v}) \\
      &= (\rv{v}, \rlabel{v}, \rchild{v}) \\
    \end{align*}
  \end{proof}

  We can see that, since both the weight and label are members of a
  field, the only possible value for both the weight
  and the label of the identity is one.  This leaves us to consider our
  options for the set of children. Suppose we have an alternative
  identity, $I$, with a non-empty set of children; then the set of children in
  the product must be $\rchild{v} 1 \stplus \rchild{I} \rlabel{v}$. For
  this to be the identity, $\rchild{v} \stplus \rchild{I} \rlabel{v}$ must
  equal $\rchild{v}$. This means, however that $\rchild{I}
  \rlabel{v}$ contributes only trees which are members of $\nullspace$,
  but this implies that $\rv{I} = 0$ which contradicts our observation
  that it must be 1.
\end{proposition}

Now we must prove that the necessary multiplicative properties so that
we can be confident that arithmetic involving trees works in the
``normal'' way.\footnote{Ideally, we would have inverses for trees
  (and hence a multiplicative identity), but, like matrices, this may
  only be possible (if it is at all) for a comparatively small part of
  $\DOMR$.} 

\begin{proposition}\label{TMcommutativity}
Multiplication of trees in $\DOMR$ is commutative.
\begin{proof}
  Suppose there is a number $n$ such that multiplication is
  commutative for all trees $\rnode{u}, \rnode{v}$ such that
  $\depth(\rnode{u}), \depth(\rnode{v}) \le n$.

  Multiplication involving nodes with a depth of zero clearly
  commutes, so $n$ may reasonably take the value 0.

  In the case where both nodes are simple, it is evident that
  they must commute, since scalar multiplication commutes, and the
  multiplication of \polytypes is commutative.

  Suppose that one or both of the nodes has a depth of $n+1$. The
  children of the nodes all have depths of $n$ or less, so the
  elements of the children of the product must be independent of
  the order of the operators in the multiplication, and both scalar
  multiplication and multiplication in the \polytypes  commute.  Hence the
  multiplication of nodes with a depth of $n+1$ must commute.  By
  induction, we can say that trees of arbitrary depth commute with
  this definition of multiplication in $\DOMR$.
  \end{proof}
\end{proposition}

\begin{proposition}\label{TMassociativity}
Multiplication of trees in $\DOMR$ is associative.
\begin{proof}
  Let $\rnode{u}$, $\rnode{v}$, and $\rnode{w}$ be nodes in $\DOMR$. Then, 
  \begin{align*}
    \rnode{u} \tdot (\rnode{v} \tdot \rnode{w}) &=  \SNode{{u}}\tdot\Node{\rv{v}\rv{w}}{\rlabel{v}\rlabel{w}}{\rlabel{w}\rchild{v}\stplus\rlabel{v}\rchild{w}} \\
    &= \Node{\rv{u}\rv{v}\rv{w}}{\rlabel{u}\rlabel{v}\rlabel{w}}{\rlabel{u}(\rlabel{w}\rchild{v}\stplus\rlabel{v}\rchild{w})\stplus\rlabel{v}\rlabel{w}\rchild{u}} \\
    \intertext{but tree addition is both commutative and associative, and multiplication in the \polytypes also commutes, so}
    &= \Node{\rv{u}\rv{v}\rv{w}}{\rlabel{u}\rlabel{v}\rlabel{w}}{\rlabel{u}\rlabel{w}\rchild{v}\stplus\rlabel{u}\rlabel{v}\rchild{w}\stplus\rlabel{v}\rlabel{w}\rchild{u}}\\
    &= \Node{\rv{u}\rv{v}\rv{w}}{\rlabel{u}\rlabel{v}\rlabel{w}}{\rlabel{w}(\rlabel{u}\rchild{v}\stplus\rlabel{v}\rchild{u})\stplus\rlabel{u}\rlabel{v}\rchild{w}}\\
    &= \Node{\rv{u}\rv{v}}{\rlabel{u}\rlabel{v}}{\rlabel{u}\rchild{v}\stplus\rlabel{v}\rchild{u}}\tdot\SNode{w}\\
    &= (\rnode{u} \tdot \rnode{v})\tdot\rnode{w}
  \end{align*}
\end{proof}
\end{proposition}

\begin{proposition}\label{TMdistrib}
  Tree-multiplication distributes over tree-addition in $\DOMR$.
  \begin{proof}
    We want to show that for $\rnode{u}, \rnode{v}$, and $\rnode{w} \in
    \DOMR$, where nodes $\rnode{v} \mand \rnode{w}$ are compatible, 
    $\rnode{u}\tdot(\rnode{v}+\rnode{w}) = \rnode{u}\tdot\rnode{v}+\rnode{u}\tdot\rnode{w}$
    is true.
  
    Let us first consider multiplication of a sum by a node with a depth of one, $\rnode{u}$,
    over the the sum $\rnode{v}+\rnode{w}$,
    \begin{align*}
      \rnode{u}\tdot(\rnode{v}+\rnode{w}) &=
      \Node{\rv{u}}{\rlabel{u}}{\emptyset}\tdot\SNode{v}+\SNode{w}\\
      &=\Node{\rv{u}}{\rlabel{u}}{\emptyset}\tdot\Node{\rv{v}+\rv{w}}{\rlabel{v}}{\rchild{v}\stplus\rchild{w}}\\
      &=\Node{\rv{u}(\rv{v} + \rv{w})}{\rlabel{u}\rlabel{v}}{\rlabel{u}(\rchild{v}\stplus\rchild{w})\stplus(\rlabel{v}\emptyset)}\\
      &=\Node{\rv{u}(\rv{v} + \rv{w})}{\rlabel{u}\rlabel{v}}{\rlabel{u}(\rchild{v}\stplus\rchild{w})}\\
      &=\Node{\rv{u}\rv{v} + \rv{u}\rv{w}}{\rlabel{u}\rlabel{v}}{\rlabel{u}\rchild{v}\stplus\rlabel{u}\rchild{w}}\\
      &=\rnode{u}\tdot\rnode{v} + \rnode{u}\tdot\rnode{w}
    \end{align*}
    Note that this is independent of the depths of nodes $\rnode{v}$ and $\rnode{w}$.

    Suppose then that there is an integer $n$ such that multiplication
    of nodes with a depth of $n$ or less distributes over
    addition, and we consider the case where our factor, $\rnode{u}$, has 
    a depth of $n+1$ or less. Then
    \begin{align*}
      \rnode{u}\tdot(\rnode{v}+\rnode{w})&=\SNode{u}\tdot\Bigl(\SNode{v}+\SNode{w}\Bigr)\\
      &=\SNode{u}\tdot\Node{\rv{v}+\rv{w}}{\rlabel{v}}{\rchild{v}\stplus\rchild{w}}\\
      &=\Node{\rv{u}(\rv{v}+\rv{w})}{\rlabel{u}\rlabel{v}}{\rlabel{v}\child{u}\stplus\rlabel{u}(\rchild{v}\stplus\rchild{w})}\\
      \intertext{but since $\rlabel{u}\in\PLY{A}$ and polynomial multiplication distributes over addtion}
      &=\Node{\rv{u}\rv{v}+\rv{u}\rv{w}}{\rlabel{u}\rlabel{v}}{\rlabel{v}\child{u}\stplus(\rlabel{u}\rchild{v}\stplus\rlabel{u}\rchild{w})}\\
      &=\SNode{u}\tdot\SNode{v} + \SNode{u}\tdot\SNode{w}\\
      &=\rnode{u}\tdot\rnode{v}+\rnode{u}\tdot\rnode{w}.
    \end{align*}
\end{proof}
\end{proposition}





%% \begin{corollary}\label{ItsARingHarry}
%%  \(\DOMR\) with tree addition and tree multiplication is a commutative \ring.
%% \begin{proof}
%%   Propositions \ref{TMcommutativity}, \ref{TMassociativity}, and
%%   \ref{TMdistrib} are sufficient to establish that it is a commutative
%%   \polystruct.
%% \end{proof}
%% \end{corollary}

% \begin{proposition}\label{complete}
%   $\DOMR$ is a complete metric space if $\FIELD$ is a complete metric
%   space.
  
%   \begin{proof}
%     We know that trivial Cauchy sequences exist, since constant
%     sequences must be Cauchy sequences. Suppose we have an arbitrary
%     Cauchy sequence, $\{u_i\}$, which converges to a tree $\rnode{u}$.  Observe
%     that members of the sequence need not be compatible, but there
%     \emph{must} be an infinite subsequence of $\{u_i\}$ which is
%     compatible since for every $\epsilon$ there exists an $N$ such
%     that $\nabs{\rnode{u_n} - \rnode{\u_m}} < \epsilon$ for all $m, n >
%     N$.  In effect, for any Cauchy sequence of trees there must be a
%     $K\leqN$ such that all $\{u_i\}$ with $i > K$ are compatible.

%     So let us take an arbitrary value of $\epsilon$ and $\N$, and
%     consider what the condition $\epsilon > \nabs{\rnode{u_m} -
%       \rnode{u_n}}$ means. The only contributions either $\rnode{u_m}$
%     and $\rnode{u_n}$ make to the difference are those which are part
%     of the trees' overlaps. If we then consider the subsequence 
    
 



\section{Discussion}

This metric space arose from attempts to capture the nuanced
associations in survey questions like \textsl{``Thinking about the
  weather forecast, how would you rate the chances of your favourite
  sporting team in the coming match?''\/} and to be able to incorporate
the sorts of conflicting data that respondents may provide into
simulation models. Initially, the trees were no more than data
structures with a rough and ready distance function, but as the
work became more coherent, the underlying mathematical structure began
to emerge, and the realisation that the trees might be useful for
representing more than survey responses came about. The basic
heuristic comparisons used in exploring the survey data were replaced
with a better behaved metric based on the tree norm

Applying trees in this manner, in a program which might conceivably
take weeks to run or be the basis of management decisions, would
require more robust foundations than a heuristic function.

The loosely defined structure was defined and converted into a vector
space so that I could then construct model-spaces from a set of basis
elements corresponding to submodels. Extending this structure to the
assessment of configurations required a metric space.

In the example model developed later, the states of the model as a
whole, subdomains of the model and the components within the model are
represented by representative trees.  There is also a set of trees
which are identified by known-good configurations, and the
mechanism which handles switching within the model uses the metric in
its assessment.  Like the model in Chapter \ref{modelefficiency}, the
approach is quite shallow, but the hope is that, having established
the ring-like properties, more advanced clustering and
discrimination techniques can be brought to bear.

In Chapter \ref{adaptiveselection} the model developed is concerned with
demonstrating the adaptive selection of models using abstracted
representations of the model's components and of the model's
configuration. These representations are in the form of trees in
$\DOMR$ with particular forms.



%% In this context, the difference between a conditional assessment and
%% an unconditional assessment may be central to the behaviour we want
%% from simulated entities.  The labels of nodes in a tree could be
%% associated with particular preconditions, and perturbations of a
%% tree---perhaps by summation, multiplication, restriction, or
%% children---might provide appropriate ways of altering the perceptual
%% and attitudinal orientation of the modelled entities.  Alas this
%% project did not continue, but the unfolding mathematics converged with
%% the desire to control the mix of submodels as discussed in


%% \subsection{semantic coherence in the children}
%% The way the children of a node influence the value of a node can be
%% perverse if the data in these nodes aren't appropriate.  The
%% overriding rule is that children to a node \emph{must be relevant to
%%   that node}. For extrapolation from surveys this is a matter
%% associated with the coding of data, for simulation models (like MSE
%% models or evaluating climate adaptation strategies) it is a matter of
%% keeping track of influences and connections appropriately.  I don't
%% believe that this is entirely a trivial matter, but I also don't
%% believe it is a complex one.

%% Example\ldots

%% \section{Example model}

%% \section{Possible domains}
%% MSE models incorporating public opinion (surveys)

%% Relationship to Bayesian reasoning, Adaptive decision making (Baysian net?)

%% Adaptive behaviour (things can learn by adjusting weightings or
%% adding new branches)

%% Constructing or assessing phylogenetic trees? 

%% \appendix
%% \section{Appendix}

%% \subsection{Quotient sets}

%% \textbf{Is this necessary?}

%% An equivalence relation is function which takes elements from a set, say \tset{U}, 
%% and identifies them with a particular subset of some other set, \tqset{U}, so that every element of \tset{U}\ is
%% identified with an element of \tqset{U}. Members of a given subset of \tset{U} which are identified with the same
%% element in \tqset{U}\ are said to be \emph{equivalent}. We do this with even and odd integers -- from the point of view
%% of splitting a block of chocolate between two friends, a block with only two partitions is equivalent to a block with
%% thirty partitions.

%% In the context of $\DOM$, we wish to partition the set into sets whose
%% members are essentially the same from the point of view of addition
%% and scalar multiplication.  We do this by picking out all of the
%% elements which behave like ``zero'' and making them one of the
%% equivalence classes (which is a technical name for the elements of the
%% quotient space). Elements of $\DOM$ which have only zero values in
%% their constituent nodes behave essentially like zero: multiplication
%% by a scalar does not change them at all, and adding them to another
%% node doesn't alter its magnitude in any discernable way, nor is the
%% result of such an addition going to influence addition or scalar
%% multiplication in any way different from from the original.

%% \begin{example}
%%   Let us consider the sets \[\set{F}_i = \{e \in \mB{Z}: e = 12 n + i, for some n \in \mB{Z}\}\].  Can an integer be in
%%   more than one of these sets?  Suppose we pick a number, say 14;  this is clearly in \(F_2\), since \(14 = 12\times1\ + 2\). What happens if we multiply by three?
%% \begin{align*}
%%     3\times14 &= 42 \\
%%     &= 36 + 6 \\
%%     &= 3\times12 + 6 \\
%% \end{align*}    
%% so \(3\times14\) is in \(F_6\) \ldots which is just what \(3\times2\) is in.  It doesn't take much experimentation to
%% discover that addition and scalar multiplication work in the \(F_n\) sets in the way we might hope: \(F_3(F_4 + F_9)\)
%% corresponds to \(3*(4 + 9)\) \ldots \emph{and to} \(75*(888+81)\).  The number 75 is clearly in \(F_{75}\), but this
%% isn't much use to us; looking at the definition of the \{F\} sets, we can see that 75 is also in \(F_3\), so perhaps
%% we can only consider the non-negative indices which are less than 12..  The reason is that the sets are analogous to the
%% remainder on division by 12.

%% \end{example}


%% %\bibliography{biblio}
%% %\bibliographystyle{harvard}
%% %\biboptions{}

%% %% The influence of a node contributes to the assessment of the
%% %% weighted distance between two attitudes: the distance between them
%% %% incorporates the influence as a multiplicative term



%% %%  The ``inertia'', \(r\)\ will typically be propagated from the root
%% %% node (though it can be different and may change with interactions)


%% %% We need a dereferencing function which takes a path comprised of
%% %% symbols and returns the subtree, as well as the excision operator
%% %% (which we can use \setminus for).  Pruning a limb  that doesn't exist
%% %% returns the tree, pruning the null tree returns the null tree. 

%% %% \(\node{a} \setminus \subtree(\node{a},(\nlabel{a}))  = \zerotree.

%% %%\begin{definition}
%% %% In a similar vein, we define, the domain \TPDOM\ whose elements are
%% %% finite sequences \(\lbrace s_i \rbrace\) where \(s_i \in \PLY\), and
%% %% the function \(\prune(\node{u},s): (\DOM, \PDOM) \mapsto \DOM)\).
%% %% \[
%% %%    \prune(\node{u}) = \begin{cases}
%% %%      \zerotree & \text{ if } \node{u} = \zerotree \\
%% %%      \zerotree & \text{ if } \nlabel{u} 
%% %%      (\nv{u}, \nlabel{u}, \lbrace \prune(\node{e}):
%% %%      \node{e}\in\child{u} \rbrace) & otherwise \\
%% %% \end{cases}
%% %% \].
%% %% \end{definition}
