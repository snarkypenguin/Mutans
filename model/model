; -*- mode: scheme; -*-
;--
; Test model configuration
;-  Code 

;; Omit the following or adjust them for local conditions, they are
;; needed for SLIB

(setenv "GAMBIT_IMPLEMENTATION_PATH" "/usr/lib/gambit-c/")
(setenv "SCHEME_LIBRARY_PATH" "/usr/share/slib/")

;; SLIB can be a bit of a devil to set up.  You need to run something like
;;
;;      # gambit
;;      > (load "/usr/lib/gambit-c/gambit.init")
;;      > (load "mklibcat.scm")
;;
;; when you are installing it. The important thing here is that the
;; SCHEME_LIBRARY_PATH is where SLIB is located and the
;; *_IMPLEMENTATION_PATH is where the scheme implementation's files
;; are.


;; comment this out if you want "predictable" rng sequences
(random-source-randomize! default-random-source)

;(dump wally)(newline)
;(aborts "Incomplete initialisation is making things fail when it runs")


;; This loads the framework
;;(include "framework") ;; this is for the time-probe macros

(load "loadem.scm")


;; Mention if slib is loaded
(if SLIB (dnl* "*** SLIB is present ***"))


;-- Configure the informational output (e.g. for debugging)

;(enable-timers)
;(disable-timers)

(set! indicate-progress #t) ;; print an indication of how far the run has progressed.  Should be #t or #f

(define kdebug-mode 'full/no-wildcards)

(case 'full
  ((full)
	(kdebug-development! #t) ;; if #t bypass all kdebug bits (they can be slow to process)
	(kdebug-message-state #t) ;; if #f this suppresses the messages, kdebug? still works
	(kdebug-wildcards! #t) ;; use wildcard tests (slower)
	)
  ((full/no-wildcards)
	(kdebug-development! #t) ;; if #t bypass all kdebug bits (they can be slow to process)
	(kdebug-message-state #t) ;; if #f this suppresses the messages, kdebug? still works
	(kdebug-wildcards! #f) ;; use wildcard tests (slower)
	)
  ((record)
	(kdebug-development! #t) ;; if #t bypass all kdebug bits (they can be slow to process)
	(kdebug-message-state #f) ;; if #f this suppresses the messages, kdebug? still works
	(kdebug-wildcards! #t) ;; use wildcard tests (slower)
	)
  ((record/no-wildcards)
	(kdebug-development! #t) ;; if #t bypass all kdebug bits (they can be slow to process)
	(kdebug-message-state #f) ;; if #f this suppresses the messages, kdebug? still works
	(kdebug-wildcards! #f) ;; use wildcard tests (slower)
	)
  ((production)
	(kdebug-development! #f) ;; if #t bypass all kdebug bits (they can be slow to process)
	(kdebug-message-state #f) ;; if #f this suppresses the messages, kdebug? still works
	(kdebug-wildcards! #f) ;; use wildcard tests (slower)
	)
  (else
	(kdebug-development! #t) ;; if #t bypass all kdebug bits (they can be slow to process)
	(kdebug-message-state #f) ;; if #f this suppresses the messages, kdebug? still works
	(kdebug-wildcards! #f) ;; use wildcard tests (slower)
	))

	
(clear-kdebug-msg-tags)

(add-kdebug-msg-tag 'emit-page)
(add-kdebug-msg-tag 'page-preamble)
(add-kdebug-msg-tag 'page-epilogue)
(add-kdebug-msg-tag 'log-data)
(add-kdebug-msg-tag 'chaintrack)



;(define kdebug? (lambda x #f)) ;; This shorts it out as rapidly as possible.
;(define kdebug kdebug?)        ;; We might later convert it to a macro that just "disappears"

;(add-kdebug-msg-tag 'logger-redundancy-check)
;(add-kdebug-msg-tag 'B.exemplarii)
;(add-kdebug-msg-tag 'fruit)
;(add-kdebug-msg-tag 'seeds)
;(add-kdebug-msg-tag 'run)
;(add-kdebug-msg-tag 'PSsst)

;;(add-kdebug-msg-tag 'q-manipulation)
;;(add-kdebug-msg-tag 'track-run-agent)
;;(add-kdebug-msg-tag 'run-agent)
;;(add-kdebug-msg-tag 'run-agent-result)
;;(add-kdebug-msg-tag 'run)
;;(add-kdebug-msg-tag 'running)
;;(add-kdebug-msg-tag 'temporal-check)
;;(add-kdebug-msg-tag 'passing-control-to-model)


;(debugkdebug #t)
;(debugkdebug #f)


;; This needs to be done before we start loading agent into things,
;; else they may set up their filenames incorrectly
(set! time-field-width 8)
;; defaults to 8, needs to be 12 to accomodate 3000 years from t = 0sec


;-- --------------- Load parameters from the parameters directory -------

;; This should be the first thing in a model configuration file after
;; the framework is loaded.
(load-parameter-set "parameters") ;; params is the directory which
											 ;; contains the parameter files

;-- Global data ---------------------------------------------------------
;========================================================================

(set! default-margins 10) ;; this is for "map" output and is always in mm


(define missing-value 0+1e-347i)
;; things arrived at by mortality are 
;; likely to be inexact

;-- Set kernel flags ----------------------------------------------------

;; The kernel will emit messages (with kdebug) which have a label which
;; matches something in the kdebug-messages list

;(set! kdebug-messages (append '(*) kdebug-messages))

;; Indicate which agents are "nested"; as an example patches may be
;; present either as independent things or as components within a
;; habitat

;(set! nested-agents '(nested-habitat)) ;; No, run simply for the moment

;(add-kdebug-msg-tag 'introspection)
;(add-kdebug-msg-tag 'log-*)


;-- load the specific model configuration ------------------------------------------------

"The following code takes the list of registered submodels and loads any files they may be 
dependent on.  Loggers must be loaded after the other submodels, so we take two passes."

(define startinittime #f)
(define endinittime #f)
(define startpreptime #f)
(define endpreptime #f)
(define startqueuetime #f)
(define endqueuetime #f)
(define finished #f)

(set! startinittime (process-times))
(load "specific-model.scm")
;;(load "sm.scm")

(set! endinittime (process-times))

(define Dunnit #f)
(define *dunnit* #f)

(define final-Q 'not-run-yet)

(random-source-randomize! default-random-source)


(define (doit q #!rest n)
  (set! Dunnit (lambda () (shutdown-agents q)))
  (set! n (if (pair? n) (car n) 1))
  (if (not *dunnit*)
		(begin
		  (dnl* "Prepping")
		  (set! startpreptime (process-times))
		  (prep-agents q start end)
		  (set! endpreptime (process-times))
		  (set! *dunnit* 0))
		)

  (set! startqueuetime (process-times))
  (set! final-Q (queue *dunnit* (+ *dunnit* n) (if (pair? final-Q) final-Q q)))
  (set! endqueuetime (process-times))

  (set! *dunnit* (+ *dunnit* n))
  )


;; Run till end without pause.  If you are a penguin, run without paws.
(define (Doit q #!optional nend)
  (if nend (set! end (* nend weeks)))
  (display "Ok.\n")
  (let ((state (kdebug-message-state))
		  )
	 (kdebug-message-state #f)

	 (if #f
		  (check-service-data-lists service-name-list
											 service-type-list
											 service-eqn-sym-list))
	 (dnl* "Prepping")
	 (set! startpreptime (process-times))
	 (prep-agents q start end)
	 (set! endpreptime (process-times))
	 (dnl* "Running")
	 
	 (set! startqueuetime (process-times))
	 (set! final-Q (queue start end q))
	 (set! endqueuetime (process-times))
	 (kdebug-message-state state)
	 
	 (if #f
		  (dnl* "Remember to run (shutdown-agents Q)")
		  (shutdown-agents Q))
	 )
  )

(define (cputime-entry vec)
  (f64vector-ref vec 0))
(define (systime-entry vec)
  (f64vector-ref vec 1))
(define (realtime-entry vec)
  (f64vector-ref vec 2))
  


(define (times)
  (let ((sicpu (cputime-entry startinittime))
		  (eicpu (cputime-entry endinittime))
		  (spcpu (cputime-entry startpreptime))
		  (epcpu (cputime-entry endpreptime))
		  (sqcpu (cputime-entry startqueuetime))
		  (eqcpu (cputime-entry endqueuetime))
		  (sireal (realtime-entry startinittime))
		  (eireal (realtime-entry endinittime))
		  (spreal (realtime-entry startpreptime))
		  (epreal (realtime-entry endpreptime))
		  (sqreal (realtime-entry startqueuetime))
		  (eqreal (realtime-entry endqueuetime))
		  )
	 (dnl* "Initialisation took   " (- eicpu sicpu) "cpu seconds")
	 (dnl* "Agent prep took       " (- epcpu spcpu) "cpu seconds")
	 (dnl* "Running the queue took" (- eqcpu sqcpu) "cpu seconds")

	 (dnl* "Initialisation took   " (- eireal sireal) "real seconds")
	 (dnl* "Agent prep took       " (- epreal spreal) "real seconds")
	 (dnl* "Running the queue took" (- eqreal sqreal) "real seconds")
	 ))



;;======================================================================

(dnl "Run with (Doit Q) to run from the start to the end\n")
(dnl "Run with (doit Q n) to run for n weeks")
(dnl "             so you can run the next step in a similar fashion\n")
(dnl "Close up shop with (shutdown-agents Q) -- this closes files and things.")
(dnl "Runtime data can be printed with (times), more detailed data comes with (timer-report)")


(display "Loaded: ")
(apply dnl* (map (lambda (x) (slot-ref x 'name)) Q))

;-  The End 


;;; Local Variables:
;;; mode: scheme
;;; outline-regexp: ";-+"
;;; comment-column:0
;;; comment-start: ";;; "
;;; comment-end:"" 
;;; End:
