; -*- mode: scheme; -*-
;-  Identification and Changes

;--
;	framework -- Written by Randall Gray 
;	Initial coding: 
;		Date: 2012.11.12
;
;	History:
;

;;; The code in this file is supposed to make things a little easier.

;;;
;;;  This model framework uses SCLOS by Gregor Kiczales, and released
;;;  by Xerox Corp. in 1992. None of the code from sclos.scm has been 
;;;  included in the other files which form the modelling framework.

"
NOTE: The lower case word 'INITIALIZE' and its derivatives have been 
changed to a lower case 'INITIALISE' in SCLOS.
There were two reasons:
    - the debugging got very tedious when trying to use the two
      forms together (yes, foolish)
and
    - my primitive brain rebelled when I tried to adopt the 'z' (OED)
      form.  Muscle memory being what it is, I again spent far too
      much time correcting (or uncorrecting) the words. 

I have included normalizing/normalising programs so that future users
can choose their preferred spelling.  The programs in question are 

	Normalize  ... which converts the code to OED spellings, and 
   Normalise  ... converts the code to the standard Australian
                  spelling. 

It is not hard to change it to catch specializer as well. 
"







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;; This file *must* be included, not loaded. ;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; This should be true if you want UNFINISHED-BUSINESS reported.
(define UNFINISHED #f) 
(define monitor-inits #f)
(include "framework-flags.scm")

;-  Code 

;; See also Kiczales, Gregor; Jim des Rivieres; Daniel G. Bobrow (July
;; 30, 1991). The Art of the Metaobject Protocol. The MIT . ISBN
;; 978-0262610742.

;; This prefixes the scheme (error...) call with a routine that spits
;; out the current file being loaded.
(define (Error #!rest args)
  `(let ()
	 (display "In ")
	 (display (load 'now-loading))
	 (display ": ")
	 (error ,@args)))



(define-macro (define-debug formals #!rest body)
  (let ((txt (if (list? formals)
					  `(define ,formals
						  "first clause"
						  (kdnl* 'deep-debugging  "Function:" (,(car formals) ,@(cdr formals)))
						  (let ((result (begin	,@body)))
							 (kdnl* 'deep-debugging "Exiting" ,@formals " ==> " result)
							 result))
					  `(define ,formals (let ((result (begin ,@body)))
												 (kdnl* 'deep-debugging "Defining " ',formals " = " result)
												 result))
					  )))
	 (pp txt)
	 txt))

;; Calls to a closure function are of the form (name t reqvar1 reqvar2 ....)
;; Note: t is passed in, rather than dt, since we don't want accidental multiple updates
(define-macro (define-update-closure name class-id svlist reqlist . body)
  `(define ,name
	  (let* ((id ,id)
			  ,@(map (lambda (sv) (list (list sv #f))) ,svlist)
			  (Reqlist ',reqlist) ;; all possible requirements
			  (reqlist ',reqlist) ;; current reqlist
			  (T #f)
			  (this-continuation
				(lambda x
				  (cond
					((null? x)  ;; the closure with no arguments returns its requirements (which may change through time)
					 reqlist)
					((and (= 1 (length x))
							(symbol? (car x)))
					 (case (car x)
						((requirements) reqlist)
						((all-requirements) Reqlist)
						((values) #f) ;; cannot ask for values without the class-id
						((
						(else (Error "bad call to update-closure function" x)))
					 )
					((and (= 1 (length x))
							(symbol? (car x)))
					 (case (car x)
						((requirements) reqlist)
						((all-requirements) Reqlist)
						((values) #f) ;; cannot ask for values without the class-id
						(else (Error "bad call to update-closure function" x)))
					 )
					((number? (car x))
					 (if (eq? (length (cdr x)) (+ 1 (length reqlist)))
						  (let* ((dt (if (< T t) (- (car x) T) 0))
								  )
							 (let ((result (begin ,@body)))
								(set! T t)
								result)
							 )
						  (Error "Failed to pass in the necessary number of arguments!" x)))
					))
					(#t (Error "+++Incomprehensible Update+++" x)))))
			  )
		 this-continuation))
  )
					 

(define-macro (UNFINISHED-BUSINESS . body)
  (if UNFINISHED
		(dnl* (load 'now-loading) " has unfinished business:\n" body))
  `#!void)

(define-macro (excise-s-expression . body)
  `#!void)

(define-macro (conditional-load yea-or-nay . body)
  `(if ,yea-or-nay
		 ,@body))

(define-macro (code-variants:use select A B)
  (cond
	((member select '(first one 1)) `,A)
	((member select '(second two 2)) `,B)
	))

(define-macro (code-block-variants:use select A B)
  (cond
	((member select '(first one 1)) `,@A)
	((member select '(second two 2)) `,@B)
	))

(define-macro (with-exit name . body)
  `(call-with-current-continuation
    (lambda (,name) ,@body)))


(define-macro (state-variables . svlst)
  (let ((rslt `'(,@svlst)))
	 ;;(pp rslt)
	 rslt))

(define-macro (no-state-variables . nsvlst)
  (let ((rslt '()))
	 rslt))


(define-macro (default-values . dvlst)
  (let ((rslt `'(,@dvlst)))
	 ;;(pp rslt)
	 rslt))

(define-macro (no-default-values . lst)
  (let ((rslt '()))
	 rslt))

(define-macro (no-values . lst)
  (let ((rslt '()))
	 rslt))


;; This makes it clear when classes are defining NO state vars

(define-macro (inherits-from . iflst) `(list ,@iflst))

(define-macro (default-initialisation class . iflst)
  `(add-default-initialisation
	 ,class ;; uses actual class as the key
	 '(,@iflst)))

;; Support for the "isa?" calls and for a mapping from the class
;; object to a name

;; Remember, if you try to unquote classtype without splicing, the
;; interpreter tries to evaluate it.


;; cpl... class precedence list
(define-macro (isa? self . classtype)
  (letrec ((orf (lambda x (if (null? x #f) (or (car x) (apply orf (cdr x)))))))
	 (let ((txt `(let ((ancestors (class-cpl (class-of ,self))))
						(if (apply orf
									  (map (lambda (x) (member x ancestors))
											 (list ,@classtype))) 
							 #t #f)
						)
					))
		;;(pp txt) ;; Uncomment to print the constructed code during the startup phase 
		txt)))



(define-macro (extend-symbol sym extn)
  `,(string->symbol (string-append (symbol->string sym) "-" extn)))


;;; (define-macro (make-object% class . initargs)
;;;   `(let ((instance (allocate-instance ,class)))
;;; 	  (initialise instance ,@initargs)
;;; 	  instance))

;;; (define-macro (make-agent% class . initargs)
;;;   `(let ((instance (allocate-instance ,class)))
;;; 	  (for-each (lambda (x) (slot-set! instance x '<uninitialised>)) (class-slots-of instance))
;;; 	  (initialise instance ,@initargs)
;;; 	  instance))

;-  Code 

(define-macro (register regname mname . val)
  ;;(display (list 'register `,regname `,mname `,val))(newline)
  (let ((txt
			(if (not (null? val))
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add ,mname ',mname ,(object->string mname) ,@val)
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add ,mname ',mname  ,(object->string mname))) )
		  )
	 ;;(display "register: ") (pp txt)  ;; Uncomment to print the constructed code during the startup phase 
	 txt))

(define-macro (register-unique regname mname . val)
  ;;(display (list 'register-unique `,regname `,mname `,val))(newline)
  (let ((txt
			(if (not (null? val))
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add-unique ,mname ',mname ,(object->string mname) ,@val)
				 `(,(string->symbol (string-append (symbol->string regname) "-register")) 'add-unique ,mname ,(object->string mname) ',mname)) )
		  )
	 ;;(display "register-unique: ") (pp txt) ;; Uncomment to print the constructed code during the startup phase 
	 txt))


(define-macro (define-class #!rest args)
  (if #f (dnl (load 'current-file)": ""Defining class: " args)) ;; set to #t to display model classes
  (let* ((cname (car args))
			;;(icname (string->symbol (string-append "<" (symbol->string cname) ">")))
			)
	 ;;(dnl "Defining " cname)
	 (let ((parents (cadr args)))
		;;(dnl "... which inherits from " parents)
		(let ((variables (caddr args) ))
		  (if (and (pair? variables) (not (memq (car variables) '(state-variables no-variables default-initialisation))))
				(Error "(define-class..) expects (state-variables name1...) or (no-variables)" args))
		  (let ((V  (append (cdr variables)
								  	 (if (or #t (and #t (not (eqv? cname  '<object>))))
										  (list (string->symbol (string-append (symbol->string (car args)) "-initialised")))
										  '())
								  )))
			 ;;(dnl "... with variables " variables)
			 ;;(pp V)
			 (let* ((txt `(define ,cname
								 (let ((,cname (make-class ,parents ',V)))
									(register-unique class ,cname)
									,cname
									)))
					 )
				;;(dnl "-----")
				;;(pp txt)
				;;(dnl "_____")
					  
				txt
				))))))



(define-macro (declare-method #!rest args)
  (if #f (dnl (load 'current-file) ": Declaring method: " args)) ;; set to #t to announce method declarations
  (let ((cname (car args))
		  (description (cadr args))
		  )
	 (if (eqv? cname 'initialise)
		  (error "You must not declare the initialise generic-method, doing so breaks things badly." args))
	 (if (eqv? cname 'initialise)
		  (dnl "It may be a bad idea to use 'initialise' as a method name."))
	 (let ((txt `(define ,cname
						(let ((,cname (make-generic)))
						  (register-unique generic-method ,cname)
						  (class-register)
						  ,cname))))
		;;(pp txt)
		txt
		)))





;; This works like so:
;;(model-method <parent1> (methname) body)
;;(model-method <parent1> (methname arg1 #!rest rest) body)
;;(model-method <parent1> (methname #!rest rest) body)
;;(model-method (<parent1>) (methname) body)
;;(model-method (<parent1>) (methname arg1 arg2...) body)
;;(model-method (<parent1> <parent2>...) (methname) body)
;;(model-method (<parent1> <parent2>...) (methname arg1 arg2..) body)
;;(model-method (<parent1>) (methname arg1 arg2 #!rest rest) body)
;;(model-method (<parent1> <parent2>...) (methname arg1 arg2 #!rest rest) body)


;; "(parent-methname)" can be used to invoke the parent's body --- sclos
;; handles any arguments that might be needed: "self" is the name of
;; the agent within the body code "t" is the current model time dt is
;; the requested dt the state variables are not directly available --
;; use "my" or "set-my!", "slot-ref" or "slot-set!"
;; (parents-methods clss clss...) can be used to invoke the  methods
;; associated with the


;; An object is a discrete component of a model which does not
;; communicate directly with the kernel -- this means that an object
;; cannot query the state or garner data from other parts of the model
;; without cheating.  Objects do *not* have kernel pointers, so the kernel
;; variable is set to #f.

(define-macro (model-method #!rest madness)
  ;; Call like (model-method classname (mname * args) #!rest body) where
  ;; the args doesn't include the call-parent-method and 'self' is
  ;; the placeholder
  (case (length madness)
	 ((0)
	  (Error "model-method: There is nothing here!" madness))
	 ((1) (Error "model-method: Only 1/3 elements have been supplied!\nNeeds a specifier, a function-name and args, and a body, got" (cons 'model-method madness)))
	 ((2) (Error "model-method: Only 2/3 elements have been supplied!\nNeeds a specifier, a function-name and args, and a body, got " (cons 'model-method madness)))
	 )
  (if (not (and (pair? (cadr madness)) (symbol? (caadr madness)) ))
		(Error "model-method: bad (mname mm-margs...) in (model-method ...) "
				 (caadr madness)))
  (if (not (eq? (cadadr madness) 'self))
		(Error "model-method: missing 'self' placeholder in the (model-method (classes) (methname self ...) ...) definition "
				 (caadr madness)))

  (let* ((classlst (if (list? (car madness))
							  (car madness)
							  (list (car madness))))
			(mname (caadr madness))
			(mm-margs (cddadr madness))
			(body (cddr madness))
			(method-id (string-append (object->string classlst) ": " (object->string mname)))
			)

	 (if #f (begin ;; set to #t to announce method definitions
										  (dnl "************************************************************")
										  (dnl (load 'current-file)": Defining method: " classlst mname)
										  (pp body)))

	 (if (and #t (not (generic-method-register 'type? ',mname)))
		  (begin
			 (display "********* Instantiating the method (")
			 (display ',mname)
			 (display " ...) ********* before the method has been declared\n")
			 (Error "instantiating without declaration" ',mname))
		  (let ((txt `(let* ((M (make-method
										 (list ,@classlst) ;; make-method returns a function....
										 (lambda (,(string->symbol (string-append (symbol->string mname) "-parent")) self ,@mm-margs);; Provides ,mname-parent for the "best match"
											
											(let* ((method-id ,method-id)
													 ;; note: the only args accepted by the call-parents routine are the parents to call.
													 (call-parents ;; this returns amount of time used for each parent in the list
													  (lambda plist
														 (let* ((parents (if (or (eqv? plist 'all) (eqv? plist '*)) (parent-classes self) plist))
																  (methods (get-methods parents ,mname self t dt))
																  )
															(map (lambda (x) (x self t dt)) methods))))
													 )
											  ;; provides ,mname-parents for arbitrary sets .. may be called more than once, and with different sets of parents
											  
											  (kdnl* 'trace-model-methods "Entering" ',mname (class-name-of self)":" (if (agent? self) (slot-ref self 'name) "<object>"))
											  ;; this provides the setter and getter for this entities variables (they can be passed about too)
											  (let ((my (lambda (x) (slot-ref self x)))
													  (set-my! (lambda (x y)
																	 (slot-set! self x y)))
													  ;; it also provides a kernel call function (if it is an <agent> rather than an <object>)
													  (kernel (if (member 'kernel (map car (class-slots (class-of self))))
																	  (slot-ref self 'kernel)
																	  #f))
													  )
												 (let ((mm-result
														  (begin
															 dt ;; If there is no body, then we just assume that doing nothing is easy.
															 ,@body) ))
													(kdnl* 'trace-model-methods "Leaving" ',mname (class-name-of self)":" (if (agent? self) (slot-ref self 'name) "<object>") "with" mm-result)
													mm-result)
												 )
											  )
											))
										))
							 (add-method ,mname M)
							 (method-register 'add M ',mname )
							 )
						 ))
			 (if #f ;; set to #t to display the expanded method (useful for debugging cryptic problems)
				  (begin
					 (dnl "------------------------------------------------------------")
					 (pp txt)))

			 (if #f (dnl "************************************************************")) ;;; set it to #t to make output pretty
			 txt))))



"*** The biggest differences between an model-method and a model-body is
that model-methods do not keep track of a kernel, and model bodies should return 
how much time they have actually used."

(define-macro (model-body myclass #!rest body)
  (if #f (begin ;; set to #t to announce the model bodies
									  (dnl "************************************************************")
									  (dnl (load 'current-file)": Defining body: " myclass) (pp body)))
  (if (not (symbol? myclass))
		(aborts "model-body: the class " myclass " should be an atom"))
  (if (eqv? myclass 'self) (error "No, I don't think that _self_ is a class...." myclass ) )

  (let ((method-id (string-append (object->string myclass) ": model-body")))
		  `(if (and #t (not (generic-method-register 'type? 'run-model-body)))
				 (Error "instantiating model-body with a declaration of run-model-body"))
		  (let* ((txt `(let ((M (make-method (list ,myclass <number> <number>)
														 (lambda (call-next-parent-body self t dt)
															;;(dnl* "RUNNING" (slot-ref self 'name) t dt)
															(kdnl* 'run-model-body (slot-ref self 'name) "entered model-body at time" t "+" dt) ;;; 
															(let* ((method-id ,method-id)
																	 (my (lambda (x) (slot-ref self x)))
																	 (set-my! (lambda (x y) (slot-set! self x y)))
																	 (initialised? (lambda () (slot-ref! self 'initialised)))
																	 (initialised! (lambda () (slot-set! self 'initialised #t)))
																	 (initialise (lambda  state (dnl* (class-name-of (class-of self)) "/" (my 'name) "called initialise in body?")))
																	 (reset-taxon (lambda (newtax) (slot-set! self 'taxon newtax)))
																	 (kernel (slot-ref self 'kernel))
																	 ;;; (call-parents ;; this returns amount of time used for each parent in the list
																	 ;;;  (lambda plist
																	 ;;; 	 (let* ((parents (if (or (eqv? plist 'all) (eqv? plist '*)) (parent-classes self) plist))
																	 ;;; 			  (methods (get-methods parents run-model-body self t dt))
																	 ;;; 			  )
																	 ;;; 		;; I am sure there is a more elegant way, but this seems to work...
																	 ;;; 		(let ((r '()))
																	 ;;; 		  (for-each
																	 ;;; 			(lambda (x)
																	 ;;; 			  (kdnl* 'chaining (my 'name) "calling parent" 
																	 ;;; 		(dnl* PARENTS: 
																	 ;;; 		(map (lambda (x) ((slot-ref x 'procedure) next-parent-body self t dt)) methods) 
 																	 ;;;	)))
																	 )
															  (kdnl* 'time-team "Entering wrapper with st of " (my 'subjective-time) ":" (my 'dt) "|" t ":"dt)
															  (if (> (abs (- (slot-ref self 'subjective-time) t)) (slot-ref self 'agent-epsilon))
																	(error "Too much lost time! Possibly uncontrolled numeric error or a bug\n" 'st: (slot-ref self 'subjective-time) 't: t ))
															  (set! dt (min (my 'dt) dt))

															  (kdnl* 'time-team "About to enter submodel with st of " (my 'subjective-time) ":" (my 'dt) "|" t ":"dt)
															  (let ((body-result
																		(begin
																		  dt ;; if there is no body , the whole timestep needs to be used (but no more than the agent can chew)
																		  ,@body
																		  )))
																 															  (kdnl* 'time-team "About to enter submodel with st of " (my 'subjective-time) ":" (my 'dt) "|" t ":"dt)

																 (kdnl* 'model-body "returns with dt" dt " and with result" body-result)

																 (if (and (> dt 0) (not (slot-ref self 'agent-body-ran)))
																	  (begin
																		 ;; DO NOT DO THIS -- this is handled in the "run" method in framework.methods.  If
																		 ;; times are not being adjusted, it indicates that there is a break in the chaining back through parent classes
																		 ;;**** (slot-set! self 'subjective-time (+ (slot-ref self 'subjective-time) dt))  ****
																		 (slot-set! self 'counter
																						(+ 1 (slot-ref self 'counter)))
																		 (slot-set! self 'agent-body-ran #t))
																	  )
																 (kdnl* 'run-model-body "Leaving" (class-name-of self)": " self "with" body-result)
																 body-result
																 )
															  )
															;; exit point
															)
														 )
										))
							  (add-method run-model-body M)
							  (method-register 'add M ',run-model-body)
							  )
						  ))
			 (if #f ;; set to #t to emit the expanded model bodies (useful for debugging cryptic behaviour)
				  (begin
					 (dnl "------------------------------------------------------------")
					 (pp txt)))

			 (if #f (dnl "************************************************************")) ;; set to  #t to make it prettier

			 txt)))
	 
;; like model-body, but chains straight to parent
(define-macro (use-parent-body myclass) 
  `(model-body ,myclass (call-next-parent-body)))



(define-macro (sclos-setter myclass variable)
  (if (or (not (symbol? variable))
			 (not (symbol? myclass)))
		(aborts "model-body: the class " myclass " and variable "
				  variable " must be atoms"))
  `(add-method ,(string->symbol
					  (string-append "set-" (symbol->string variable) "!"))
					(make-method (list ,myclass)
									 (lambda (self arg)
										(slot-set! self ',variable arg)))))

(define-macro (sclos-getter myclass variable)
  (if (or (not (symbol? variable)) (not (symbol? myclass)))
		(aborts "model-body: the class " myclass " and variable "
				  variable " must be atoms"))
  `(add-method ,variable
					(make-method (list ,myclass) 
									 (lambda (self)
										(slot-ref self ',variable)))))

(define-macro (load-config)
  `( include "model.config"))


;-  The End 


;;; Local Variables:
;;; mode: scheme
;;; outline-regexp: ";-+"
;;; comment-column:0
;;; comment-start: ";;; "
;;; comment-end:"" 
;;; End:
