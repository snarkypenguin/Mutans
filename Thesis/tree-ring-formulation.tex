% -*- outline-regexp: "%--* ";  -*-
\chapter[A RING OF TREES]{A Ring of Trees}
\section{Introduction}
The project which triggered the development of the structure in this
chapter considered using the modeling of the social dynamics
associated with policies about, and responses to climate change and to
predict the social and economic consequences of development arising
from various scenarios. This was a significant change from previous
representations of ``public'' participants, such as recreational
fishers, tourists, accomodation and other small businesses, which were
modelled in fairly simple ways (\cite{Fulton2011ningaloo,Gray2014}).
The specific goal was to be able to incorporate a simulation of the
way public opinion changes in response to policy actions and changes
in the economy and environment.  The starting point for this was a
corpus of responses to a survey on attitudes associated with the topic
of climate change (\cite{boschetti2012}). The data consisted of
(largely) numeric answers to individual questions which could
represented as either distinct items, or as an aggregation of symbolic
elements.  Questions like ``How much do trust the following
individuals or organisations to tell you the truth about changing
climate?'' might be encoded in a symbolic way by aggregating the
symbols \textsf{climate\_change, trust, information\_source, AustPeng}
for the trustworthiness of the \emph{Australian Penguins} as a source
of information. The actual value marked could be encoded as a scalar,
giving us an expression like ``\textsf{4/5 + climate\_change +
  information\_source + trust + AustPeng}''---expressing it in this
way suggested that working with more intricate relationships might be
possible.

While my involvement in the project was shortlived, the problem the
data posed was engaging, and slowly it became evident how the the
mathematical structures I was trying to construct could represent
configurations of models, and that it might be able to incorporate
the interdependencies between models and other information in a very
simple way.  My hope was to be able to construct example
configurations which were reasonable for particular conditions and to
assess how close to ``known-good'' configurations the system was
at any given point.  It also seemed possible that it might allow
strategies which were able to interpolate between ``good'' 
configurations making intermediate transitions between configurations
feasible. The natural network of dependencies exhibited by some
components of past models suggested using tree structures to encode
the configuration of a model as a starting point.  

The structure described in this chapter is the structure behind the
work in Chapter \ref{adaptiveselection}.  The trees are comprised of
nodes which have a label and a weight (and, of course, children).
Initially, the labels were simply symbols associated with certain
attitudes or semantic data which were taken from a nominated set.
This had the advantages of simplicity and clarity, but their very
simplicity made the multiplicative operator much more complicated. I
realised that much of the machinery associated with labels was really
just a messy version of arithmetic in commutative ring of
multinomials. I believe that using the field of rational multinomials
may be productive, but this notion has not been seriously explored.
Once labels were identified with multinomials, everything became
clear.

\section{Conventions and preliminary definitions}

Generally, we will use lower case, boldfaced symbols to denote a node
(or tree), and upper case, boldfaced symbols to denote sets ---
particularly sets of nodes.  Other symbols (such as \(x\)) will
typically refer to numbers or \polyrat\ \polyforms. Elements of a
node, \tnode{u} will be identified using an appropriate subscript,
namely \tnv{u}, for the node's value and \tnlabel{u} for its
label. Initially, the children of a node were thought of as
refinements or children of an attitude, so the children of $\node{u}$
were its children, and \tchild{u} denotes the set of children.  We will
take $\PLY{A}$ to be the \polytypes\ over the elements of a finite set
of symbols $\set{A}$.  Here $\FIELD$\ would usually be some numeric
field such as $\mB{Q, R}$ or $\mB{C}$, for example.

\begin{definition}\label{def-of-dom}
  Given $\set{A}$ and $\PLY{A}$ and an arbitrary field, $\FIELD$, we
  define the set, $\DOM$ of finite (acyclic) trees where each node is
  of the form $(\nv{u}, \nlabel{u}, \child{u})$ where the value,
  $\nv{u}$, is a member of $\FIELD$, it's label, $\nlabel{u}$ is
  a member of $\PLY{A}$ and the set of children, $\child{u}$, contains
  leaf nodes with distinct labels.

  Nodes or trees with no children, \(\set{E} = \emptyset\), will be
  called \emph{simple nodes, simple trees}, or \emph{leaf nodes}, and
  simple nodes which also have scalar multinomials as their labels may
  be referred to as \emph{scalar nodes} or \emph{scalar trees}. The
  domain of trees, $\DOM$, is the collection of only those trees with
  a finite number of nodes.  form.
  %%%, with the caveat that we exclude nodes with \omit{scalar multinomials} and
  %%%non-empty children.
  We will make use of two special elements in $\DOM$,
  $\zerotree = (0, 0, \emptyset)$, an analogue of zero which we will call the
  \emph{zerotree}, and $\onetree = \iota = (1, 1, \emptyset)$, which will turn
  out to be the multiplicative identity.
\end{definition}

%% \begin{definition}
%% A node, $\node{u}$, is a representative of a recursive, acyclic
%% structure of the form $(v, p, \set{E})$ where we have $v \in \FIELD, p
%% \in \PLY{A}$, and the children, $\set{E}$, contains nodes of the
%% same for, with the caveat that the labels of the elements must be
%% unique within the set. Without necessarily limiting ourselves, we will
%% take $\FIELD$ to be $\REAL$.  Nodes or trees with \(\set{E} =
%% \emptyset\), the empty set, will be called \emph{simple nodes, simple
%%   trees}, or \emph{leaf nodes}, and simple nodes which also have
%% scalar multinomials as their labels may be referred to as \emph{scalar
%%   nodes} or \emph{scalar trees}. The domain of trees, $\DOM$, is the
%% collection of only those trees with a finite number of nodes.
%% form.
%% %%%, with the caveat that we exclude nodes with \omit{scalar multinomials} and
%% %%%non-empty children.
%% We will make use of a special element in $\DOM$, $\zerotree = (0, 0,
%% \emptyset)$, an analogue of zero which we will call the
%% \emph{zerotree}.

%% The set of valid labels is taken to be a commutative ring of
%% multinomials, $\PLY{A}$. In principle, elements of \emph{any}
%% (commutative) ring could serve equally well.
%% \end{definition}

Note that the choice to use elements of the \polytypes\ for labels is, in a
sense, arbitrary: elements of any commutative ring will serve, though
we will see that if we use a commutative ring, $\DOM$ and the derived
domains are also commutative rings,; here, the \polytypes\ provide a
simple example which is easily manipulated and printed. Similarly,
$\FIELD$ could be any field.

When there is no risk of ambiguity, we will use the same symbol to
refer to a set, $\DOM$ for example, and a vector space based on that
set. Compatibility (or lack thereof) is really only pertinent to the
addition of trees, in the same way that having the same row- and
column-rank is only necessary in matrix addition.  There is no such
constraint in the pairwise multiplication of trees.


First, the definitions for some basic tools for manipulating these trees.
\begin{definition}
  We define the relation which partitions $\DOM$ into
  \emph{compatible} sets of trees. Two nodes or trees, $\node{u}$, $\node{v}$
  are said to be compatible if they have the same label or at least
  one of them is $\zerotree$
  \[
  \sigma(\set{R}) = \{\set{R}_p: \forall \node{u} \in \set{R}, \nlabel{u} = p \iff \node{u} \in \set{R}_p\},
  \]
  which we may denote
  \[
  \node{u} \sim \node{v} \iff  
  \node{u}\in\set{R}_{\nlabel{v}} \iff 
  \node{v}\in\set{R}_{\nlabel{u}}.
  \]
  
  Compatibility is analogous to compatibility in matrices, and nodes
  may only be added if they are compatible.
\end{definition}

\begin{definition}
  For \(\node{u} \in \DOM\)\ we define the function
  \marginnote{\Defn\ of \(\depth(\node{u})\)}
  \begin{align*}
    \depth(\node{u}) = \begin{cases}
      0 & \text{ if } \node{u} = (0,0,\emptyset) = \zerotree \\
      1 & \text{ if } \node{u} \text{ is a simple node} \\
      1 + \max(\lbrace\depth(\node{v}):\forall \node{v} \in \child{u}\rbrace) & otherwise
    \end{cases}
  \end{align*}
  which gives us the depth of the tree.
\end{definition}

\begin{definition}
  We will also define for \(\node{u} \in \DOM\),
  \marginnote{\Defn\ of \(\trim(\node{u})\)}
  \begin{align*}
      \trim(\node{u}) = \begin{cases}
        \zerotree & \text{ if } \node{u} = \zerotree \\
        \zerotree & \text{ if } \node{u} \text{ is simple} \\
        \Node{\nv{u}}{\nlabel{u}}{\lbrace \trim(\node{e}): \forall\node{e}\in\child{u} \rbrace \setminus \{\zerotree\}} & otherwise.
      \end{cases}
  \end{align*}
\end{definition}

Obviously the $\depth$ is an indication of how many levels of nodes
the tree possesses.

Trimming essentially removes all simple nodes from the tree.
\marginnote{\Defn\ of \(\trim_{k}(\node{u})\)} A recursive application
of trimming will be denoted \(\trim_{k}\), indicating that the tree
\tnode{u} will be trimmed \(k\)\ times. Note that
\(\trim_{\depth(\node{u})}{\node{u}} = 0\)\ and
\(\depth(\trim_{\depth{\node{u}}-1}{\node{u}}) = 1\).

\begin{definition}
  The cardinality of a tree is the number of nodes it contains. We define it formally as
  \begin{align*}
  \Tcard{\node{u}} = \begin{cases}
    0 & \text{ if } \node{u} = \zerotree\\
    1 + \sum_{\node{e}\in\child{u}} \Tcard{\node{e}}.
    \end{cases}
  \end{align*}

Simple nodes are the only nodes which have a cardinality of one, and \tzerotree\ is the only node or tree with a
cardinality of zero.
\end{definition}



\begin{definition}
The \emph{overlap} between two trees is defined
\[
  \overlap(\node{u},\node{v}) = \begin{cases}
    0 & \text{ if } \node{u} = \zerotree \mor \node{v} = \zerotree \mor \nlabel{u} \neq \nlabel{v} \\
    1 + \displaystyle\sum_{\substack{\node{e}\in\child{u} \\ \node{f}\in\child{v}}} \overlap(\node{e},\node{f}) & \text{otherwise}
  \end{cases}
\]

Clearly two trees, \tnode{u} and \tnode{v}, are compatible if and only if \(\overlap(\node{u},\node{v}) \neq 0 \) ; they will
be said to \emph{completely overlap} if \(\Tcard{\node{u}} = \Tcard{\node{v}} =
\overlap(\node{u},\node{v})\).
%We may also make use of the relative overlap of two nodes, \tnode{u} and \tnode{v}, given by \[\overlap_{r}(\node{u},\node{v})
%= \frac{2 \overlap(\node{u},\node{v})}{\Tcard{\node{u}}+\Tcard{\node{v}}}.\] The relative overlap of  \tzerotree\ with itself is
%not defined.
\end{definition}

%% \begin{definition}
%%   \label{delta-function}
%%   The degree of deviation between two trees, \tnode{u} and \tnode{v} is given  by the expression

%%    \begin{equation}
%%      \delta{\node{u}}{\node{v}} = (1+\nabs{\node{u} - \node{v}})\frac{\Tcard{\node{u}}\Tcard{\node{v}}}{\overlap{\node{u},\node{v})^2} - 1 
%%    \end{equation}
    
%%   The rationale behind this definition is that if trees \tnode{u} and \tnode{v} are identical, then
%%   $\delta{\node{u}}{\node{v}}$ will be zero. We also want nodes that aren't common to both trees to
%%   count as differences.
%% \end{definition}


\section{Addition and Scalar Multiplication}

Fundamental to the notion of using these trees for either attitudinal
changes or for adjusting the state of a representation switching model
is that we must be able to combine the trees mathematically, and that
the mathematics behaves in some reasonably standard way.  It would be
nice to be able to merely add a tree representing a new agent to the
existing state tree, or to remove one in an analogous fashion.

We will define \marginnote{Scalar multiplication and addition with
  trees} scalar multiplication of the trees in $\DOM$, then we will
define a few useful mappings which will help keep the expressions
simple. Our aim, in this section, is to define addition, and to show
that the defined scalar multiplication and addition make this a vector
space.

\begin{definition}
  For all \(a \in \PLY{A}\)\ and \(\node{u} \in \DOM\), we
  define\marginnote{\(a \node{u}\)}
  \begin{align*}
      a \node{u} = \begin{cases}
        \zerotree  & \text{ if } a = 0 \mor \node{u} = \zerotree \\
        (a \nv{u}, \nlabel{u}, a\child{u}) & \text{ otherwise }
      \end{cases}
  \end{align*}
  where $a\set{A}$ indicates the element-wise product.  Since the
  elements of $\FIELD$ are a subset of $\PLY{A}$ this also defines scalar
  multiplication of trees by elements of $\FIELD$.
\end{definition}



\begin{definition}\label{useful-set-functions}
  We will define a few useful notation or relations on sets of nodes
  in $\DOM$. Take \(\set{U}\) and \(\set{V}\) be such sets and
  \tnode{a} be a node in $\DOM$; then 
  \begin{align*}
      \nlabels{U} &= \{\nlabel{e}: \forall \node{e} \in \set{U}\} \notag\\
      & \notag\\
      \srestrictedto{U}{V} &= \{\node{f} \in \set{U}: \nlabel{f} \in \nlabels{V} \} \notag\\
      \nsrestrictedto{U}{V} &= \{ \node{f} \in \set{U}: \nlabel{f} \notin \nlabels{V} \} \label{restrictions}\notag\\
      \intertext{and}
      a \set{U} &= \{a \node{u}: \forall \node{u} \in \set{U}\} \notag
  \end{align*}
\end{definition}


\begin{definition}\label{useful-node-functions}
  For convenience, we define analogues of several of the above
  relations for nodes to implicitly refer to the children of
  those nodes.

  Let \tnode{u} and \tnode{v} be arbitrary nodes in $\DOM$.  Then we
  define the following
  \begin{align*}
      \nlabels{u} &\equiv \nlabels{\child{u}}\\
      \restrictedto{u}{v} &\equiv \restrictedto{\child{u}}{\child{v}}\\
      \nrestrictedto{u}{v} &\equiv \nrestrictedto{\child{u}}{\child{v}}
      %% \node{r} \oplus \node{s} &= \child{r} \oplus \child{s}
  \end{align*}
\end{definition}


Now we define the addition of two trees,
\begin{definition}
  \label{treeaddition}
  For compatible nodes \tnode{u} and \(\node{v} \in \DOM\),\marginnote{\(\node{u}+\node{v}\)} 
  \begin{align*}
      \node{u} + \node{v} = \begin{cases}
        \node{u} &\text{ if } \node{v} = \zerotree \\
        \node{v} &\text{ if } \node{u} = \zerotree \\
%%%???        \zerotree &\text{ if } \child{u} = \emptyset \mand \child{v} = \emptyset \mand \nv{u} + \nv{v} = 0 \\
%%%%%%        \Node{\nv{u} + \nv{v}}{\nlabel{u}}{\emptyset} & \text{ if } \child{u} = \emptyset \mand \child{v} = \emptyset \\
        %% &\NNNode{\nv{u} + \nv{v}}{\nlabel{u}}{\bigl(\{\node{r}+\node{s} : \node{r} \in \child{u} \mand \node{s} \in \child{v}\mand\nlabel{r} = \nlabel{s}\} \\
        %% & \qquad \qquad \qquad \qquad \cup \{\node{r} : \node{r} \in \child{u}\mand\nlabel{r} \notin \nlabels{v}\} \cup \{\node{s} : \node{s} \in \child{v}\mand\nlabel{s} \notin \nlabels{u}\}\bigr) \setminus \{\zerotree\} \\
        \Bigl(\nv{u} + \nv{v}, \nlabel{u}, 
        \bigl(\nrestrictedto{u}{v}\cup\nrestrictedto{v}{u} & {} \\
        \quad\cup\{\node{r}+\node{s}:\node{r}\in\restrictedto{u}{v}\mand\node{s}\in\restrictedto{v}{u}\mand\nlabel{r}=\nlabel{s}\}\bigr)\setminus \{\zerotree\}\Bigr) & \text{ otherwise}
      \end{cases}
  \end{align*}
\end{definition}

{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \blockcomment{
    Here we extend the notion to the addition of the elements of two sets

    \begin{definition}
      For sets \(\set{B}, \set{C}\) with elements from $\DOM$, we define
      the set 
      \[
      \set{B}\capplus\set{C} = \{\node{r} + \node{s}: \node{r} \in \set{B}, \node{s} \in \set{C}
      \mand \nlabel{r} = \nlabel{s}.\}
      \]
    \end{definition}

    With these definitions, we can express the value of the sum of two
    non-null trees, \tnode{u} and \tnode{v}, as 
    \[
    \node{u} + \node{v} = \Bigl(\nv{u} + \nv{v}, \nlabel{u}, 
    \bigl(\nrestrictedto{u}{v} \cup \nrestrictedto{v}{u} \cup (\child{u} \capplus \child{v})\bigr)\setminus \{\zerotree\}\Bigr),
    \]
    and we note that the children of the sum is the disjoint union of the sets
    \(\nrestrictedto{u}{v}, \nrestrictedto{v}{u}\), and \((\child{u} \capplus \child{v})\).
  }
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here we extend the notion to the addition of the elements of two
sets. This allows us to be a little more concise in dealing with the
children.

\begin{definition}[Notation]
  We define a mapping which takes two sets, each comprised of nodes in
  $\DOM$, to another set of nodes.The resulting set contains the nodes
  of the each of the operands which are incompatible with all the
  nodes in the other and the set obtained by applying addition to
  compatible pairs from the first and second set. This notation is
  used to express the restriction of addition to compatible nodes in
  the children of the root nodes.  Let
  \begin{align*}
      \set{B}\stplus\set{C} = \childO{B}{C}{r}{s}{+}.
  \end{align*}
  Notice that $\stplus$ must commute by the symmetry of its construction and the
  commutativity of tree addition. Moreover, it must also be associative, since both tree 
  addition and set intersection are associative.
\end{definition}

\section{Vector space}
In this section we prove that the defined elements and operations give
us a vector space.  

\begin{proposition}\label{vspace} $\DOM$, with scalar multiplication and addition is a vector space.
  \begin{proof}
    We will assume that  \(\node{p}, \node{q}, \node{u},\node{v},\node{w} \in \DOM\)\ and \(a, b \in  \FIELD\), and that
    addition $\node{u} \sim \node{v} \sim \node{w}$ (they are all compatible).

    %%%%%% Delete the vspace if you remove margin notes
    \vspace{28pt}
    \begin{description} 
    \item[Additive identity element]
      \imarginnote{\(\zerotree+\node{u}=\node{u}\)}

      This is explicit in the definition of addition between elements
      of $\DOM$.

    \item[Inverse elements with respect to addition]
      \imarginnote{\(\node{u} - \node{u} = \zerotree\)}

      The element \(\zerotree\) is its own inverse, since \(\zerotree
      + \zerotree = \zerotree\) by definition.

      So, we consider the case of $\node{u}$, where \(\depth(\node{u})
      = 1\), then
      \begin{align*}
          \node{u} + -\node{u} &=  \Node{\nv{u}}{\nlabel{u}}{\emptyset} + \Node{-1\nv{u}}{\nlabel{u}}{\emptyset} \\
          &= (\nv{u} + -\nv{u}, \nlabel{u}, \emptyset) \\
          &= \zerotree
      \end{align*}
      so for any simple node, \(\node{u}\), \(-\node{u}\)\ is its
      inverse.

      Let \tnode{v} be a non-null node which is not simple, but has
      simple c, that is to say \(\depth(\node{v}) = 2)\).  Then 
      \begin{align*}
          \node{v} + -\node{v} &= (\nv{v} - \nv{v}, \nlabel{v}, \lbrace \node{e} + -\node{e}: \forall \node{e} \in \child{v}\rbrace \setminus\{\zerotree\}) \\
          %&= (0, \nlabel{v}, \{\zerotree\} \setminus\{\zerotree\} \\
          &= (0, \nlabel{v}, \emptyset) \\
          &= \zerotree
      \end{align*}
      since the simple leaf nodes are all added to their own additive
      inverse.

      Having established this, we can generalise to trees with a depth
      greater than two. Assuming that the proposition holds for
      elements of $\DOM$ with depth \(n\), we consider an element, \tnode{u},
      where \(\depth(\node{u}) = n+1\) added to the element
      \(-\node{u}\).
      \begin{align*}
          \node{u} + -\node{u} &= (0, \nlabel{u}, \lbrace \node{e} + -\node{e}: \forall \node{e} \in \child{u}\rbrace)
      \end{align*}

      Since the child nodes of the root node of \tnode{u} are, by
      assumption, added to their additive inverses, they then become
      \begin{align*}
          &= (\nv{v} + -\nv{v}, \nlabel{v}, \emptyset) \\
          &= \zerotree
      \end{align*}
      for each \(\node{v}\in\child{u}\) and, by induction, our inverse
      holds for all members of $\DOM$.


    \item[Multiplicative identity element]
      \imarginnote{\(1 \node{u} = \node{u}\)}

      First observe that \(1\/\zerotree\)\ is by definition \tzerotree.

      Now consider an arbitrary  non-null tree in $\DOM$, \tnode{u};
      \tnode{u} is either simple, or it has child nodes. In the
      case of a simple \tnode{u}, it is obvious that \(1 \in
      \FIELD\)\ acts as an identity.
      \begin{align*}
          \node{u} &= (\nv{u}, \nlabel{u}, \emptyset) \\
          &=  (1 \nv{u}, \nlabel{u}, \emptyset) \\
          &=  1 ( \nv{u}, \nlabel{u},\emptyset) \\
          &= 1 \node{u}
      \end{align*}

      Thus, for all leaf nodes on \tnode{u}, 1 is the identity for
      scalar multiplication. Now we take \tnode{u}\ to be some
      non-simple node,
      \begin{align*}
          \node{u} &= (\nv{u}, \nlabel{u},\child{u}) \\
          &=  (1 \nv{u}, \nlabel{u}, 1 \child{u}) \\
          &=  (1 \nv{u}, \nlabel{u}, \lbrace (1 \nv{e}, \nlabel{e}, \child{e}): \forall \node{e} \in \child{u} \rbrace),
      \end{align*}
      and, if the children are all simple nodes,
      \begin{align*}
          &=  1 (\nv{u}, \nlabel{u}, \child{u}) \\
          &= 1 \node{u}.
      \end{align*}
      so it is the case that 1 is the scalar multiplicative identity for nodes which
      have a depths of less than three. 
      
      Now suppose that \(1\) is the identity for scalar multiplication
      of all members of $\DOM$ with a depth of \(n\) or less for some
      natural number \(n\), and we consider \tnode{v}\ which has a
      depth of \(n+1\). Then
      \begin{align*}
          \node{v} &= (\nv{v}, \nlabel{v}, \child{v}) \\
          &=  (1 \nv{v}, \nlabel{v}, 1\child{v})
      \end{align*}.

      But each of the elements in the set \(1\child{v}\) either has a
      depth of \(n\) or less and so the the children of \(1 \node{v}\)
      is merely \tchild{v}, and so \(1 \node{v} = \node{v}\).

      By induction, we can demonstrate that \(1\) is the 
      identity for scalar multiplication of nodes of arbitrary (finite) depth.



    \item[Commutativity]
      \imarginnote{\(\node{u} + \node{v} = \node{v} + \node{u}\)}

      Let us consider compatible nodes \tnode{u} and \tnode{v}.

      The commutativity of addition involving \tzerotree\ is
      guaranteed by the definition of addition. so we first address
      the case where both addends are simple.

      Take \tnode{u} and \tnode{v} to be simple nodes; then
      \begin{align*}
          \node{u} + \node{v} &= (\nv{u}, \nlabel{u}, \emptyset) + (\nv{v}, \nlabel{v}, \emptyset) \notag\\
          &= (\nv{u} + \nv{v}, \nlabel{u}, \emptyset) \notag\\
          &= (\nv{v} + \nv{u}, \nlabel{u}, \emptyset) \notag\\
          &= \node{v} + \node{u}.
      \end{align*}

      Now suppose that there is some number \(n\) for which
      \(\depth(\node{u}) \leq n \mand \depth(\node{v}) \leq n
      \implies \node{u} + \node{v} = \node{v} + \node{u}\).

      Then if we take \tnode{u} and \tnode{v} to be nodes with depths
      of \(n+1\) or less,
      \begin{align*}
          \node{u} + \node{v} &= (\nv{u}, \nlabel{u}, \child{u}) + (\nv{v}, \nlabel{v}, \child{v}) \notag\\
          &= \Bigl(\nv{u} + \nv{v}, \nlabel{u}, \bigl(\{\node{r}+\node{s} : \node{r} \in \restrictedto{u}{v} \mand \node{s} \in \restrictedto{v}{u}\mand\nlabel{r} = \nlabel{s}\} \notag\\
          & \qquad \qquad \qquad \qquad \cup \{\node{r} : \node{r} \in \child{u}\mand\nlabel{r} \notin \nlabels{v}\} \cup \{\node{s} : \child{s} \in \node{v}\mand\nlabel{s} \notin \nlabels{u}\}\bigr) \setminus \{\zerotree\}\Bigr) \notag\\
          &= \Bigl(\nv{u} + \nv{v}, \nlabel{u}, \bigl(\{\node{r}+\node{s} : \node{r} \in \child{u} \mand \nlabel{r} \in \nlabels{v} \mand \node{s} \in \child{v}\mand\nlabel{s} \in \nlabels{u}\} \notag\\
          & \qquad \qquad \qquad \qquad         \cup \nrestrictedto{\node{u}}{v} \cup \nrestrictedto{v}{u}\bigr) \setminus \{\zerotree\}
      \end{align*}
          
      So,
      \begin{align*}
          \node{u} + \node{v} &= \Bigl(\nv{v} + \nv{u}, \nlabel{u}, \bigl(\{\node{r}+\node{s} : \node{r} \in \child{u} \mand \nlabel{r} \in \nlabels{v} \mand \node{s} \in \child{v}\mand\nlabel{s} \in \nlabels{u}\} \notag\\
          & \qquad \qquad \qquad \qquad         \cup \nrestrictedto{\node{u}}{v} \cup \nrestrictedto{v}{u}\bigr) \setminus \{\zerotree\}
      \end{align*}

      since addition in $\DOM$ is commutative. If we can demonstrate
      that the expression for the children is independent of
      order, then it must be the case that sum of the addends,
      \tnode{u}\ and \tnode{v}, must also be order independent.
      
      The set \(\{\node{r}+\node{s}:\node{r}\in\child{u}\mand\nlabel{r}\in\nlabels{v}\mand\node{s}\in\child{v}\mand\nlabel{s}\in\nlabels{u}\}\) must be
      order independent since each of the candidate \tnode{r}\ and \tnode{s}\ addends must have a depth of \(n\) or less. Since set union is
      commutative, the order of \(\nrestrictedto{u}{v}\) and \(\nrestrictedto{v}{u}\) doesn't affect the result, thus, addition must be commutative
      for all \(\node{u} \text{ where } \depth({\node{u}}) \leq n+1\).  By induction, this must be true for all \(n \geq 0\).

    \item[Associativity]
      \imarginnote{\((\node{u}+\node{v})+\node{w} = \node{u}+(\node{v}+\node{w})\)}

      Let us consider compatible nodes \(\node{u}, \node{v}\) and
      \(\node{w}\) in $\DOM$. 

      First consider the situation where the depths of \(\node{u}, \node{v}\) and
      \(\node{w}\) are all less than or equal to one. If they all have
      a depth of zero, the sum is almost trivially the null
      tree. Similarly, if only one is the null tree, it rapidly
      degenerates to simple addition. So we take \tnode{u}, \tnode{v},
      and \tnode{w} to be simple. Then
      \begin{align*}
          (\node{u}+\node{v})+\node{w} &= ((\nv{u}, \nlabel{u}, \emptyset) + (\nv{v}, \nlabel{u}, \emptyset)) + (\nv{w}, \nlabel{u}, \emptyset) \\
          &= (\nv{u} + \nv{v}, \nlabel{u}, \emptyset) + (\nv{w}, \nlabel{u}, \emptyset) \\
          &= ((\nv{u} + \nv{v}) + \nv{w}, \nlabel{u}, \emptyset) \\
          &= (\nv{u} + (\nv{v}) + \nv{w}), \nlabel{u}, \emptyset) \\
          &= \node{u} + (\node{v} + \node{w}).
      \end{align*}
      
      Let us consider the case where these may be non-simple
      trees. Suppose there is an integer \(n\) such that associativity
      holds for any three trees \(\node{u}, \node{v} \mand \node{w}\),
      whose depth is less than or equal to \(n\), that is if
      \(\depth(\node{u}) \leq n, \depth(\node{v}) \leq n \mand
      \depth(\node{w}) \leq n\),
      then it must be the case that \[(\node{u} + \node{v}) + \node{w} = \node{u} + (\node{v} + \node{w})\].

      Now suppose one or more of these trees has a depth of
      \(n+1\).
      
      % Just the set
      %% \bigl\{\nrestrictedto{u}{v} \cup \nrestrictedto{v}{u} \\
      %% &\qquad\quad \cup \hspace{2pt} \{\node{r} + \node{s}:  \node{r} \in \restrictedto{u}{v}\mand \node{s} \in \restrictedto{v}{u} \} \bigr\} \setminus \{\zerotree\}

      \begin{align*}
          (\node{u}+\node{v})+\node{w} &= (\Node{\nv{u}}{\nlabel{u}}{\child{u}} + \Node{\nv{v}}{\nlabel{u}}{\child{v}}) + \Node{\nv{w}}{\nlabel{u}}{\child{w}} \\
          &= \Node{\nv{u} + \nv{v}}{\nlabel{u}}{\child{u}\stplus\child{v}} + \Node{\nv{w}}{\nlabel{u}}{\child{w}}
      \end{align*}

      Recall that 
      \begin{align*}
          \child{u}\stplus\child{v} &= \childO{u}{v}{p}{q}{+}\\
          \intertext{so, letting}
          \set{B} &= \child{u}\stplus\child{v} \\
          \intertext{we get}
          (\node{u}+\node{v})+\node{w} &=\NNNode{(\nv{u} + \nv{v}) + \nv{w}}{\nlabel{u}}{\bigl(\nsrestrictedto{B}{w}\cup\nrestrictedto{w}{B} \cup \set{B}\stplus\child{w}\bigr)\setminus\{\zerotree\}} \\
          &=\NNNode{\nv{u} + (\nv{v} + \nv{w})}{\nlabel{u}}{\bigl(\nsrestrictedto{B}{w}\cup\nrestrictedto{w}{B}\cup \set{B}\stplus\child{w}\bigr)\setminus\{\zerotree\}} \\
          \intertext{since addition in $\DOM$ is associative}
      \end{align*}

      Notice that the elements of all the sets which comprise the children, those in \(\set{B}\) and in \tchild{w},
      must have a depth of \(n\) or less; any addition which occurs amongst the elements of these sets must be
      associative by our inductive assumption. Hence
      \begin{align*}
          (\node{u}+\node{v})+\node{w} = \node{u}+(\node{v}+\node{w}).
      \end{align*}


    \item[Compatibility of scalar multiplication and multiplication in $\FIELD$]
      \imarginnote{\(a(b \node{u}) = (a b) \node{u}\)}

      Observe first that \(a \zerotree = \zerotree, \forall a \in
      \FIELD\). We also dispose with the case of simple nodes:
      \begin{align*}
          a(b \node{u}) &= (a(b \nv{u}), \nlabel{u}, \emptyset) \\
          &= (a b \nv{u}, \nlabel{u}, \emptyset) \\
          &= ((a b) \nv{u}, \nlabel{u}, \emptyset) \\
          &= (a b) \node{u};
      \end{align*}

      So assuming that multiplication is compatible with nodes with
      depths of \(n\) or less, we consider \tnode{u}, where \(\depth(\node{u})
      = n+1\),
      \begin{align*}
        a (b \node{u}) &= a (b  \nv{u}, \nlabel{u}, b\child{u}) \\
        \intertext{since \(\depth(\node{e}) \leq n \forall \node{e}\in \child{u},\) multiplication of these elements is compatible, and }
          &= (a b\/ \nv{u}, \nlabel{u}, a(b\child{u})) \\
          \intertext{becomes}
          &= ((a b) \nv{u}, \nlabel{u}, (a b)\child{u}) \\
          &= (a b) \node{u}
      \end{align*}

      Thus the scalar and field multiplication operators are compatible.

      
    \item[Distribution of scalar multiplication with respect to vector addition]
      \imarginnote{\(a(\node{u}+\node{v}) = a \node{u}+a \node{v}\)}

      Let us consider compatible trees, \tnode{u}\ and \tnode{v}.
      
      First, note that \[\forall \node{u} \in \DOM, a(\zerotree + \node{u}) = a \node{u} = a\zerotree + a \node{u},\]
      and that \[\forall \node{u},\node{v}\in\DOM, 0 (\node{u} + \node{v}) = \zerotree = 0 \node{u} + 0 \node{v}.\]

      The property holds for simple nodes, 
      \begin{align*}
        a(\node{u} + \node{v}) &= a (\Node{\nv{u}}{\nlabel{u}}{\emptyset} + \Node{\nv{v}}{\nlabel{v}}{\emptyset})\\ 
        &= a \Node{\nv{u} + \nv{v}}{\nlabel{u}}{\emptyset} \\
        &= \Node{a(\nv{u} + \nv{v})}{\nlabel{u}}{\emptyset} \\
        &= \Node{a\nv{u} + a\nv{v}}{\nlabel{u}}{\emptyset} \\
        &= \Node{a\nv{u}}{\nlabel{u}}{\emptyset} + \Node{a\nv{v}}{\nlabel{u}}{\emptyset} \\
        &= a \node{u} + a \node{v}
      \end{align*}.

      So, suppose that the equation \(a ( \node{p} + \node{q}) =
      a \node{p} + a \node{q}\) holds for all compatible nodes \tnode{p} and
      \tnode{q} such that \(depth(\node{p}) \leq k\), and
      \(\depth(\node{q}) \leq j\).

      Take \(n = \min(j, k)\), \(a\in\FIELD\), and nodes \tnode{u} and \tnode{v} such that
      \(\depth(\node{u}) = n+1\), and \(\depth(\node{v}) = n+1\).
      Note that \(n\) must be greater than zero since the property holds for simple
      nodes.  Then
      \begin{align*}
        a(\node{u} + \node{v}) &= a (\Node{\nv{u}}{\nlabel{u}}{\child{u}} + \Node{\nv{v}}{\nlabel{v}}{\child{v}}\\ 
        &= a \bigl(\nv{u} + \nv{v}, \nlabel{u}, \bigl\{\nrestrictedto{u}{v} \cup \nrestrictedto{v}{u} \\
        &\qquad \cup \hspace{2pt} \{\node{r} + \node{s}:  \node{r} \in \restrictedto{u}{v}\mand \node{s} \in \restrictedto{v}{u} \} \bigr\} \setminus \{\zerotree\} \bigr) \\
        &= \Bigl(a (\nv{u} + \nv{v}), \nlabel{u}, 
        \bigl\{\{a \node{e}: \node{e} \in \nrestrictedto{u}{v}\} \cup \{a \node{e}: \node{e} \in \nrestrictedto{v}{u}\} \\
        &\qquad \cup \hspace{2pt} \{a (\node{r} + \node{s}):  \node{r} \in \restrictedto{u}{v}\mand \node{s} \in \restrictedto{v}{u} \} \bigr\} \setminus \{\zerotree\} \bigr)\Bigr) \\
        &= \Bigl(a \nv{u} + a \nv{v}, \nlabel{u},  
        \bigl\{\{a \node{e}: \node{e} \in \nrestrictedto{u}{v}\} \cup \{a \node{e}: \node{e} \in \nrestrictedto{v}{u}\} \\
        &\qquad \cup \hspace{2pt} \{a (\node{r} + \node{s}):  \node{r} \in \restrictedto{u}{v}\mand \node{s} \in \restrictedto{v}{u} \} \bigr\} \setminus \{\zerotree\} \bigr)\Bigr)
      \end{align*}.

      Notice that the component sets of the set of children to \(\node{u} +
      \node{v}\), namely \(\{a \node{e}: \node{e} \in
      \nrestrictedto{u}{v}\}\),  
      \(\{a \node{e}: \node{e} \in
      \nrestrictedto{v}{u}\}\) and \(\{a (\node{r} + \node{s}):
      \node{r} \in \restrictedto{u}{v}\mand \node{s} \in
      \restrictedto{v}{u} \}\) can only contain nodes with a depth of
      \(n\) or less; Thus, we can proceed inductively, increasing
      the least upper bound, (\(\min(j, k)\), for the set of trees
      that cooperate with distribution of scalar multiplication over
      vector addition, to any value we wish.

    \item[Distribution of scalar multiplication with respect to
      addition in $\FIELD$ ]
      \imarginnote{\(a+b)\node{u}) = a \node{u}+b \node{u}\)}

      The property is clearly true when \(\node{u} = \zerotree\),
      since \((a+b)\zerotree = \zerotree = a\zerotree+b\zerotree\).

      We first consider simple nodes:
      \begin{align*}
        (a + b)\node{u} &= (a + b) ((a + b)\nv{u}, \nlabel{u}, \emptyset) \\
        &= ((a + b)\nv{u}, \nlabel{u}, \emptyset) \\
        &= (a\nv{u}, \nlabel{u}, \emptyset) + (b  \nv{u}, \nlabel{u}, \emptyset) \\
        &= a \node{u} + b \node{u}.
      \end{align*}

      Nodes with a depth of two are slightly more complicated, 
      \begin{align*}
          (a + b)\node{u} &= (a + b) ((a + b)\nv{u}, \nlabel{u}, (a + b)\child{u}) \\
          &= (a\nv{u} + b  \nv{u}, \nlabel{u}, \{(a + b)\node{e}:\node{e}\in\child{u}\}) \\
          \intertext{but \(\child{u}\) is composed of simple nodes, so,}
          &= (a\nv{u} + b  \nv{u}, \nlabel{u}, \{a \node{e} + b \node{e}:\node{e}\in\child{u}\}) \\
          &= (a\nv{u} + b  \nv{u}, \nlabel{u}, a\child{u}) + (b  \nv{u}, \nlabel{u}, b\child{u}) \\
          &= a \node{u} + b \node{u}.
      \end{align*}
      %% a \node{e} + b \node{e} = (a + b) \node{e} because nodes in the
      %% children only contribute (add to something non-zero) if they
      %% have the same label, and there are no oddities that appear in
      %% one addend and not the other.(modulo the scalars)

      
      Now suppose the property holds for nodes with a depth of \(n\).
      Then we consider node \(\node{u}\) with a depth of \(n+1\):
      \begin{align*}
          (a + b)\node{u} &= (a + b) (\nv{u}, \nlabel{u}, \child{u}) \\
          &= ((a + b)\nv{u}, \nlabel{u}, (a + b)\child{u}), \\
          &= (a\nv{u} + b  \nv{u}, \nlabel{u}, \{a \node{e} + b \node{e}:\node{e}\in\child{u}\}) \\
        \intertext{since \(\depth(\node{e}) = n\)}
          &= a \node{u} + b \node{u}.
      \end{align*}

      %% Suppose there is an element \(\node{v} \in \child{u}\)\ where
      %% this is not the case. It cannot be the case that \((a + b)\nv{v}
      %% \neq a\nv{v} + b  \nv{v}\)\ since all three addends are in $\FIELD$,
      %% so there is some must be some node in \tchild{v}, say \tnode{g},
      %% for which \((a + b)\node{g} \neq a \node{g}+b \node{g}\). This
      %% process continues till we reach a simple node (as we must) with
      %% an empty children, so we must conclude that the assumption
      %% is false; there can be no element in the an children for
      %% which \((a+b)\node{e} \neq a \node{e}+b \node{e}\).
      
      %% So 
      %% \begin{align*}\label{Dsmf4}
      %%     (a + b)\node{u} &= (a\nv{u} + b  \nv{u}, \nlabel{u}, 
      %%     \{(a\nv{e} + b  \nv{e}, \nlabel{e}, \{a \node{e} + b \node{e}):
      %%     \node{e} \in \child{u}\}) \\
      %%     &= a \node{u} + b \node{u} \\
      %% \end{align*}

      %%    (a + b)\node{u} &= (a\nv{u} + b  \nv{u}, \nlabel{u},
      %%    \{(a\nv{e} + b  \nv{e}, \nlabel{e}, a\child{e} + b\child{e}): \node{e} \in \child{u}\}), \\


      %% The justification for splitting the sum of the terms from the children rests on the observation that we may
      %% deal with the simple nodes by appealing to the first part of this section of the proof. The non-simple nodes, can
      %% be expanded and dealt with using the same strategy used for \tnode{u}, and the fact that we are dealing with
      %% finite, trees means that along any branch we must eventually exaust the supply of non-simple nodes,
      %% leaving us with simple terminal nodes which are of the form \(a \node{u} + b \node{u}\). In this way the elements of
      %% very non-simple node's children *********
    \end{description}
    By induction, the property must hold for all \(n >= 0\)
  \end{proof}
\end{proposition}


\section{Seminorms, norms and metrics} %

Now that we have a vector space, we can construct model configurations
as linear combinations of basis configurations. In the context of models
which change their configuration, we need a way for the model itself
to combine basis configuration trees by choosing from a set of
configurations that are known to exhibit suitable properties.  To this
end, we need a mechanism for judging how close or far a given
configuration is from where it needs to be -- we need a way to
decompose an extant, running configuration into its basis elements,
and then map these to some provably more appropriate configuration.
To do this, our structure needs to be a metric space.

% Seminorm: triangle inequality, |a|||v|| = ||av|| ... note |a| = 0
We will now construct a seminorm on the vector space
$\DOM$. This will induce a norm on a quotient space of $\DOM$ which we
can use as a tool for assessing the similarity of trees and,
ultimately, provide both a means of clustering trees and selecting
trees with particular properties.

\subsection{$\DOM$ and its seminorm}
\begin{definition}\label{absolute-mag}
\marginnote{Absolute value: \(\nabs{\node{u}}\)} We define the absolute value of a node to be
\begin{align*}
\nabs{\node{u}} = \begin{cases}
  0 & \text{ if } \node{u} = \zerotree \\
  \abs{\nv{u}} & \text{ if }\child{u} = \emptyset \\
  \abs{\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}} & \text{ otherwise.}
\end{cases}
\end{align*}
\end{definition}
%\begin{remark}
The absolute magnitude is only based only on the values of the
nodes of trees. % This corresponds to the $L^1$ norm on the tree space.
Note that each node in a tree can only contribute a non-negative
quantity to the absolute value of the tree, it is obvious that
\(\nabs{\node{u}} \geq 0\)\ for all \(\node{u} \in \DOM\)\ and that
equality only occurs if the value of each node in the tree \tnode{u}
is zero.
%\end{remark}

\begin{proposition}\label{absolutehomogeneity}
  For \(a \in \FIELD\) and \(\node{u} \in \DOM, \abs{a}\nabs{\node{u}} =
  \nabs{a \node{v}}\).
\begin{proof}
  The magnitude of the empty tree is trivially zero, so \(\abs{a}\nabs{\zerotree} =
  \nabs{a\zerotree} = 0\).

  Consider simple nodes in $\DOM$:
  \begin{align*}
      \abs{a}\nabs{\node{u}} &= \abs{a}(\abs{\nv{u}} + 0) \\
      &= \abs{a}\abs{\nv{u}} \\
      &= \nabs{a \node{u}}.
  \end{align*}

  Now suppose that there is \(n \ge 1\) such that the proposition is true for
  all trees with a depth of \(n\) or less. Then, taking \(\node{u} \in
  \DOM\) where \(\depth(\node{u}) = n+1\), we have
  \begin{align*}
      \abs{a}\nabs{\node{u}} &= \abs{a}\bigl((\abs{\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}})\bigr) \\
      &= \abs{a}\abs{\nv{u}} + \sum_{\node{e}\in\child{u}}\abs{a}\nabs{\node{e}}\\
      \intertext{but all the elements in \(\child{u}\) have a depth of \(k\) or less}
      &= \abs{\abs{a}\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{\abs{a}\node{e}} \\
      &= \abs{a\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{a \node{e}} \\
      &= \nabs{a \node{u}}.
  \end{align*}

  By induction, the proposition must be true for all \(n \geq 0\).
\end{proof}
\end{proposition}


\begin{proposition}\label{triangle1}
  For \(\node{u} \mand \node{v} \in \DOM, \nabs{\node{u} + \node{v}}
  \leq \nabs{\node{u}} + \nabs{\node{v}}\).

\begin{proof}
  We start by considering trees of depths zero and one. The case for null trees is trivial: \(\nabs{\zerotree +
    \zerotree} = \abs{0 + 0} = 0\), and if only one of the trees has a depth of one, we get either \(\nabs{\node{u} +
    \zerotree} = \nabs{\node{u}}\) or \(\nabs{\zerotree + \node{u}} = \nabs{\node{u}}\).

  For \(\node{u} \mand \node{v}\)  with depths of one, \[\nabs{\node{u} + \node{v}} = \nabs{(\nv{u}+\nv{v}, \nlabel{u}, \emptyset)}= \abs{\nv{u}+\nv{v}}\].
  Since \tnv{u} and \tnv{v} are scalars in $\FIELD$, we must have
  \(\abs{\nv{u} + \nv{v}} \leq \abs{\nv{u}}+\abs{\nv{v}}\),
  so \[\abs{\nv{u}+\nv{v}} \leq \abs{\nv{u}}+\abs{\nv{v}} = \nabs{\node{u}} + \nabs{\node{v}}.\]

  We will now proceed by induction; let \(n\) be a positive integer for which the triangle inequality holds for all
  trees with a depth of \(k\) or less.  Let's consider compatible trees, \tnode{u} and \tnode{v} whose depths are less
  than or equal to \(n+1\). Then
  \begin{align*}
      \nabs{\node{u} + \node{v}} &= \nabs{(\nv{u} + \nv{v}, \nlabel{u}, \child{u}\stplus\child{v})} \\
      &= \Bigl[\abs{\nv{u} + \nv{v}} + \mstsum{\node{e}\in{\child{u}\stplus\child{v}}}\nabs{\node{e}}\Bigr]. \\
  \end{align*}
  
  Observe that \(\abs{\nv{u} + \nv{v}} \leq \abs{\nv{u}} + \abs{\nv{v}}\), and that each 
  of the addends in \[\sum_{\node{e}\in{\child{u}\stplus\child{v}}}\nabs{\node{e}}\] has a depth of \(n\) or
  less, so 
\begin{align*}
  \sum_{\node{e}\in{\child{u}\stplus\child{v}}}\nabs{\node{e}} &\leq \sum_{\node{e}\in{\child{u}}}\nabs{\node{e}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}.\\
  \intertext{ This implies that}
   \nabs{\node{u} + \node{v}} &\leq \Bigl[\abs{\nv{u}} + \abs{\nv{v}} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}\Bigr];\\
   \intertext{rearranging we get}
   \nabs{\node{u} + \node{v}}  &\leq \Bigl[\abs{\nv{u}} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}}\Bigr] + \Bigl[\abs{\nv{v}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}\Bigr] \\
   \intertext{and hence}
   \nabs{\node{u} + \node{v}} \leq \nabs{\node{u}}  + \nabs{\node{v}}.
\end{align*}
\end{proof}
\end{proposition}

\begin{corollary}\label{gseminorm}
  The absolute value forms a seminorm on $\DOM$.
  \begin{proof}  
    Propositions, \ref{absolutehomogeneity} and \ref{triangle1}, are 
    sufficient for the absolute value to be a seminorm on
    $\DOM$.
  \end{proof}
\end{corollary}

At this point we should consider the elements
$\node{o} \in \DOM$
which are analogues of zero. We define the set
$\nullspace =\{\node{o}\in\DOM : \nabs{\node{o}} = 0\}$,
and observe that for any
$\node{e} \in \DOM, \mand \node{o} \in \nullspace$
the equation
$\nabs{\node{e} + \node{o}} = \nabs{\node{e}}$
must hold. 

Since $\DOM$ is a seminormed vector space, it is also a pseudometric
space and we can induce a fully fledged metric space over the quotient
space $\DOMQ = \DOM / \nullspace$.

For simplicity, we identify the coset of $\nullspace$ with respect to
$\zerotree$ with $\rzerotree$, and we take the induced metric on the
normed vector space $\DOMQ$, to be
\[\dist(\qnode{u},\qnode{v}) =
\nabs{\qnode{u} - \qnode{v}} \text{ for all }\qnode{u}, \qnode{v} \in
\DOMQ\].  We will continue to use \(\nabs{\rnode{u}}\) to denote the
the induced absolute value of \(\rnode{u}\in\DOMR\).

%% \subsection{Multiplication of elements in $\DOMQ$}
%% \begin{definition}\label{treemultiplication}
%%   The product of two elements $qnode{u}, \qnode{v}\in \DOMQ$
%%     is defined by
%%   \begin{align*}
%%     \qnode{u} \qnode{v} = \begin{cases}
%%       \zerotree & \text{ if either factor is } \zerotree \\



\section{Element multiplication in $\DOMR$ and establishing the
  properites of a ring}

In this section, we will define a multiplicative operator for trees, and
demonstrate that there is a multiplicative identity.  My motivation for establising
these properties is twofold; most importantly, it broadens the set of
mathematical tools we have at our disposal to analyse sets of trees
(clustering, classification, interpolation, extrapolation...), but
also because we never know just what else we might discover along the
way!

\begin{definition}\label{rtreemult}
  We define the multiplication of two trees (or nodes) to be
  \[
  \rnode{u} \tdot \rnode{v} = \begin{cases}
     \rzerotree & \text{ if } \rnode{u} = \rzerotree \mor \rnode{v} = \rzerotree \\
     (\rv{u} \rv{v}, \rlabel{u} \rlabel{v}, \rlabel{u} \rchild{v} \stplus \rlabel{v} \rchild{u}) & \text{  otherwise}
  \end{cases}
  \].
  
\end{definition}    

where the notation $\rlabel{u} \rchild{v}$or $\rchild{v} \rlabel{u}$ corresponds to the set
obtained by multiplying each label in the root node of the set
$\rchild{v}$ by the label $\rlabel{u}$. Clearly, if the set in the
operation (on either side) is null, then the result is null.

\begin{proposition}
  $\iota = (1, 1, \emptyset)$ commutes with all other nodes, is the
  multiplicative identity, and it is unique, 
  \begin{proof}
    Let $\rnode{v}$ be some arbitrary tree, then
    \begin{align}
      (\rv{v},\rlabel{v},\rchild{v})\tdot \iota &= (\rv{v}  1, \rlabel{v} 1, \rchild{v} 1 \stplus \emptyset \rlabel{v}) \\
      &= (1 \rv{v}, 1 \rlabel{v}, 1 \rchild{v} \stplus \rv{v} \emptyset) \\
      &= (1 \rv{v}, 1 \rlabel{v}, \rv{v} \emptyset \stplus 1 \rchild{v}) \\
      &= (1 \rv{v}, 1 \rlabel{v}, 1 \rchild{v}) \\
      &= \iota\tdot(\rv{v}, \rlabel{v}, \rchild{v}) \\
      &= (\rv{v}, \rlabel{v}, \rchild{v}) \\
    \end{align}
  \end{proof}

  We can see that, since both the weight and label are members of a
  field, the only possible value for both the weight
  and the label of the identity is one.  This leaves us to consider our
  options for the set of children. Suppose we have an alternative
  identity, $I$, with a non-empty set of children; then the set of children in
  the product must be $\rchild{v} 1 \stplus \rchild{I} \rlabel{v}$. For
  this to be the identity, $\rchild{v} \stplus \rchild{I} \rlabel{v}$ must
  equal $\rchild{v}$. This means, however that $\rchild{I}
  \rlabel{v}$ contributes only trees which are members of $\nullspace$,
  but this implies that $\rv{I} = 0$ which contradicts our observation
  that it must be 1.
\end{proposition}

Now we must prove that the necessary multiplicative properties so that
we can be confident that arithmetic involving trees works in the
``normal'' way.\footnote{Ideally, we would have inverses for trees
  (and hence a multiplicative identity), but, like matrices, this may
  only be possible (if it is at all) for a comparatively small part of
  $\DOMR$.} 

\begin{proposition}\label{TMcommutativity}
Multiplication of trees in $\DOMR$ is commutative.
\begin{proof}
  Suppose there is a number $n$ such that multiplication is
  commutative for all trees $\rnode{u}, \rnode{v}$ such that
  $\depth(\rnode{u}), \depth(\rnode{v}) \le n$.

  Multiplication involving nodes with a depth of zero clearly
  commutes, so $n$ may reasonably take the value 0.

  In the case where both nodes are simple, it is evident that
  they must commute, since scalar multiplication commutes, and the
  multiplication of \polytypes\ is commutative.

  Suppose that one or both of the nodes has a depth of $n+1$. The
  children of the nodes all have depths of $n$ or less, so the
  elements of the children of the product must be independent of
  the order of the operators in the multiplication, and both scalar
  multiplication and multiplication in the \polytypes\  commute.  Hence the
  multiplication of nodes with a depth of $n+1$ must commute.  By
  induction, we can say that trees of arbitrary depth commute with
  this definition of multiplication in $\DOMR$.
  \end{proof}
\end{proposition}

\begin{proposition}\label{TMassociativity}
Multiplication of trees in $\DOMR$ is associative.
\begin{proof}
  Let $\rnode{u}$, $\rnode{v}$, and $\rnode{w}$ be nodes in $\DOMR$. Then, 
  \begin{align*}
    \rnode{u} \tdot (\rnode{v} \tdot \rnode{w}) &=  \SNode{{u}}\tdot\Node{\rv{v}\rv{w}}{\rlabel{v}\rlabel{w}}{\rlabel{w}\rchild{v}\stplus\rlabel{v}\rchild{w}} \\
    &= \Node{\rv{u}\rv{v}\rv{w}}{\rlabel{u}\rlabel{v}\rlabel{w}}{\rlabel{u}(\rlabel{w}\rchild{v}\stplus\rlabel{v}\rchild{w})\stplus\rlabel{v}\rlabel{w}\rchild{u}} \\
    \intertext{but tree addition is both commutative and associative, and multiplication in the \polytypes\ also commutes, so}
    &= \Node{\rv{u}\rv{v}\rv{w}}{\rlabel{u}\rlabel{v}\rlabel{w}}{\rlabel{u}\rlabel{w}\rchild{v}\stplus\rlabel{u}\rlabel{v}\rchild{w}\stplus\rlabel{v}\rlabel{w}\rchild{u}}\\
    &= \Node{\rv{u}\rv{v}\rv{w}}{\rlabel{u}\rlabel{v}\rlabel{w}}{\rlabel{w}(\rlabel{u}\rchild{v}\stplus\rlabel{v}\rchild{u})\stplus\rlabel{u}\rlabel{v}\rchild{w}}\\
    &= \Node{\rv{u}\rv{v}}{\rlabel{u}\rlabel{v}}{\rlabel{u}\rchild{v}\stplus\rlabel{v}\rchild{u}}\tdot\SNode{w}\\
    &= (\rnode{u} \tdot \rnode{v})\tdot\rnode{w}
  \end{align*}
\end{proof}
\end{proposition}

\begin{proposition}\label{TMdistrib}
  Tree-multiplication distributes over tree-addition in $\DOMR$.
  \begin{proof}
    We want to show that for $\rnode{u}, \rnode{v}$, and $\rnode{w} \in
    \DOMR$, where nodes $\rnode{v} \mand \rnode{w}$ are compatible, 
    $\rnode{u}\tdot(\rnode{v}+\rnode{w}) = \rnode{u}\tdot\rnode{v}+\rnode{u}\tdot\rnode{w}$
    is true.
  
    Let us first consider multiplication of a sum by a node with a depth of one, $\rnode{u}$,
    over the the sum $\rnode{v}+\rnode{w}$,
    \begin{align*}
      \rnode{u}\tdot(\rnode{v}+\rnode{w}) &=
      \Node{\rv{u}}{\rlabel{u}}{\emptyset}\tdot\SNode{v}+\SNode{w}\\
      &=\Node{\rv{u}}{\rlabel{u}}{\emptyset}\tdot\Node{\rv{v}+\rv{w}}{\rlabel{v}}{\rchild{v}\stplus\rchild{w}}\\
      &=\Node{\rv{u}(\rv{v} + \rv{w})}{\rlabel{u}\rlabel{v}}{\rlabel{u}(\rchild{v}\stplus\rchild{w})\stplus(\rlabel{v}\emptyset)}\\
      &=\Node{\rv{u}(\rv{v} + \rv{w})}{\rlabel{u}\rlabel{v}}{\rlabel{u}(\rchild{v}\stplus\rchild{w})}\\
      &=\Node{\rv{u}\rv{v} + \rv{u}\rv{w}}{\rlabel{u}\rlabel{v}}{\rlabel{u}\rchild{v}\stplus\rlabel{u}\rchild{w}}\\
      &=\rnode{u}\tdot\rnode{v} + \rnode{u}\tdot\rnode{w}
    \end{align*}
    Note that this is independent of the depths of nodes $\rnode{v}$ and $\rnode{w}$.

    Suppose then that there is an integer $n$ such that multiplication
    of nodes with a depth of $n$ or less distributes over
    addition, and we consider the case where our factor, $\rnode{u}$, has 
    a depth of $n+1$ or less. Then
    \begin{align*}
      \rnode{u}\tdot(\rnode{v}+\rnode{w})&=\SNode{u}\tdot\Bigl(\SNode{v}+\SNode{w}\Bigr)\\
      &=\SNode{u}\tdot\Node{\rv{v}+\rv{w}}{\rlabel{v}}{\rchild{v}\stplus\rchild{w}}\\
      &=\Node{\rv{u}(\rv{v}+\rv{w})}{\rlabel{u}\rlabel{v}}{\rlabel{v}\child{u}\stplus\rlabel{u}(\rchild{v}\stplus\rchild{w})}\\
      \intertext{but since $\rlabel{u}\in\PLY{A}$ and polynomial multiplication distributes over addtion}
      &=\Node{\rv{u}\rv{v}+\rv{u}\rv{w}}{\rlabel{u}\rlabel{v}}{\rlabel{v}\child{u}\stplus(\rlabel{u}\rchild{v}\stplus\rlabel{u}\rchild{w})}\\
      &=\SNode{u}\tdot\SNode{v} + \SNode{u}\tdot\SNode{w}\\
      &=\rnode{u}\tdot\rnode{v}+\rnode{u}\tdot\rnode{w}.
    \end{align*}
\end{proof}
\end{proposition}

\begin{corollary}\label{ItsARingHarry}
$\DOMR$ with tree addition and tree multiplication is a commutative \ring.
\begin{proof}
  Propositions \ref{TMcommutativity}, \ref{TMassociativity}, and
  \ref{TMdistrib} are sufficient to establish that it is a commutative
  \ring.
\end{proof}
\end{corollary}


% \begin{proposition}\label{complete}
%   $\DOMR$ is a complete metric space if $\FIELD$ is a complete metric
%   space.
  
%   \begin{proof}
%     We know that trivial Cauchy sequences exist, since constant
%     sequences must be Cauchy sequences. Suppose we have an arbitrary
%     Cauchy sequence, $\{u_i\}$, which converges to a tree $\rnode{u}$.  Observe
%     that members of the sequence need not be compatible, but there
%     \emph{must} be an infinite subsequence of $\{u_i\}$ which is
%     compatible since for every $\epsilon$ there exists an $N$ such
%     that $\nabs{\rnode{u_n} - \rnode{\u_m}} < \epsilon$ for all $m, n >
%     N$.  In effect, for any Cauchy sequence of trees there must be a
%     $K\leqN$ such that all $\{u_i\}$ with $i > K$ are compatible.

%     So let us take an arbitrary value of $\epsilon$ and $\N$, and
%     consider what the condition $\epsilon > \nabs{\rnode{u_m} -
%       \rnode{u_n}}$ means. The only contributions either $\rnode{u_m}$
%     and $\rnode{u_n}$ make to the difference are those which are part
%     of the trees' overlaps. If we then consider the subsequence 
    
 



%% are all compatible, but there must be a subsequence of
%%     compatible trees since the generating set for $\PLY{A}$ is finite.

    
%%   \end{proof}
%% \end{proposition}


%% A more explicit discussion of the construction of $\DOMR$ and the
%% induced operations can be found in the appendix for those who are
%% unfamiliar with quotient sets.



%% \marginnote{\Defn\ norm.}
%% % Norm: triangle inequality, a|v| = |av|, |a| = 0 iff a = 0

%% \begin{definition}
%%   \label{def-tree-norm} For a node \(\mathbf{u} \in \DOMR\), we define the
%%   value, \(\treeval{u}\), \begin{align*} \label{tree-value-eq}
%%     \treeval{u} = \begin{cases} \abs{\nv{u}} & \text{ if } \child{u} = \emptyset
%%       \\
%%       \treeval{u} = \abs{\nv{u}} + \frac{1}{\card{\child{u}}} \sum\limits_{\node{e} \in \child{u}}
%%       \treeval{\node{e}} & \text{otherwise} \\ \end{cases} \end{align*}
%% \end{definition}

\section{Discussion}

This \ring\ arose from attempts to capture the nuanced associations in survey
questions like \emph{``Thinking about the weather forecast, how would you rate
  the chances of your favourite sporting team in the coming match?''} and to be
able to incorporate the sorts of conflicting data that respondents may provide
into simulation models. Initially, the trees were no more than data structures
with a rough and ready ``distance'' function; as work progressed, the the
underlying mathematical structure began to emerge, and a path to applying it in
controlling model configurations started to appear.

The loosely defined structure was defined and converted into a vector
space so that I could then construct ``model-spaces'' from a set of basis
elements corresponding to submodels. Extending this structure to the
assessment of configurations required a metric space.

In the example model developed later, the states of the model as a
whole, subdomains of the model and the components within the model are
represented by representative trees.  There is also a set of trees
which are identified by ``known-good'' configurations, and the
mechanism which handles switching within the model uses the metric in
its assessment.  Like the model in Chapter \ref{modelefficiency}, the
approach is quite shallow, but the hope is that, having established
the ring-theoretic properties, more advanced clustering and
discrimination techniques can be brought to bear.

In Chapter \ref{adaptiveselection} the model developed is concerned with
demonstrating the adaptive selection of models using abstracted
representations of the model's components and of the model's
configuration. These representations are in the form of trees in $\DOMR$.


%% In this context, the difference between a conditional assessment and
%% an unconditional assessment may be central to the behaviour we want
%% from simulated entities.  The labels of nodes in a tree could be
%% associated with particular preconditions, and perturbations of a
%% tree---perhaps by summation, multiplication, restriction, or
%% children---might provide appropriate ways of altering the perceptual
%% and attitudinal orientation of the modelled entities.  Alas this
%% project did not continue, but the unfolding mathematics converged with
%% the desire to control the mix of submodels as discussed in


%% \subsection{semantic coherence in the children}
%% The way the children of a node influence the value of a node can be
%% perverse if the data in these nodes aren't appropriate.  The
%% overriding rule is that children to a node \emph{must be relevant to
%%   that node}. For extrapolation from surveys this is a matter
%% associated with the coding of data, for simulation models (like MSE
%% models or evaluating climate adaptation strategies) it is a matter of
%% keeping track of influences and connections appropriately.  I don't
%% believe that this is entirely a trivial matter, but I also don't
%% believe it is a complex one.

%% Example\ldots

%% \section{Example model}

%% \section{Possible domains}
%% MSE models incorporating public opinion (surveys)

%% Relationship to Bayesian reasoning, Adaptive decision making (Baysian net?)

%% Adaptive behaviour (things can learn by adjusting weightings or
%% adding new branches)

%% Constructing or assessing phylogenetic trees? 

%% \appendix
%% \section{Appendix}

%% \subsection{Quotient sets}

%% \textbf{Is this necessary?}

%% An equivalence relation is function which takes elements from a set, say \tset{U}, 
%% and identifies them with a particular subset of some other set, \tqset{U}, so that every element of \tset{U}\ is
%% identified with an element of \tqset{U}. Members of a given subset of \tset{U} which are identified with the same
%% element in \tqset{U}\ are said to be \emph{equivalent}. We do this with even and odd integers -- from the point of view
%% of splitting a block of chocolate between two friends, a block with only two partitions is equivalent to a block with
%% thirty partitions.

%% In the context of $\DOM$, we wish to partition the set into sets whose
%% members are essentially the same from the point of view of addition
%% and scalar multiplication.  We do this by picking out all of the
%% elements which behave like ``zero'' and making them one of the
%% equivalence classes (which is a technical name for the elements of the
%% quotient space). Elements of $\DOM$ which have only zero values in
%% their constituent nodes behave essentially like zero: multiplication
%% by a scalar does not change them at all, and adding them to another
%% node doesn't alter its magnitude in any discernable way, nor is the
%% result of such an addition going to influence addition or scalar
%% multiplication in any way different from from the original.

%% \begin{example}
%%   Let us consider the sets \[\set{F}_i = \{e \in \mB{Z}: e = 12 n + i, for some n \in \mB{Z}\}\].  Can an integer be in
%%   more than one of these sets?  Suppose we pick a number, say 14;  this is clearly in \(F_2\), since \(14 = 12\times1\ + 2\). What happens if we multiply by three?
%% \begin{align*}
%%     3\times14 &= 42 \\
%%     &= 36 + 6 \\
%%     &= 3\times12 + 6 \\
%% \end{align*}    
%% so \(3\times14\) is in \(F_6\) \ldots which is just what \(3\times2\) is in.  It doesn't take much experimentation to
%% discover that addition and scalar multiplication work in the \(F_n\) sets in the way we might hope: \(F_3(F_4 + F_9)\)
%% corresponds to \(3*(4 + 9)\) \ldots \emph{and to} \(75*(888+81)\).  The number 75 is clearly in \(F_{75}\), but this
%% isn't much use to us; looking at the definition of the \{F\} sets, we can see that 75 is also in \(F_3\), so perhaps
%% we can only consider the non-negative indices which are less than 12..  The reason is that the sets are analogous to the
%% remainder on division by 12.

%% \end{example}


%% %\bibliography{biblio}
%% %\bibliographystyle{harvard}
%% %\biboptions{}

%% %% The influence of a node contributes to the assessment of the
%% %% weighted distance between two attitudes: the distance between them
%% %% incorporates the influence as a multiplicative term



%% %%  The ``inertia'', \(r\)\ will typically be propagated from the root
%% %% node (though it can be different and may change with interactions)


%% %% We need a dereferencing function which takes a path comprised of
%% %% symbols and returns the subtree, as well as the excision operator
%% %% (which we can use \setminus for).  Pruning a limb  that doesn't exist
%% %% returns the tree, pruning the null tree returns the null tree. 

%% %% \(\node{a} \setminus \subtree(\node{a},(\nlabel{a}))  = \zerotree.

%% %%\begin{definition}
%% %% In a similar vein, we define, the domain \TPDOM\ whose elements are
%% %% finite sequences \(\lbrace s_i \rbrace\) where \(s_i \in \PLY\), and
%% %% the function \(\prune(\node{u},s): (\DOM, \PDOM) \mapsto \DOM)\).
%% %% \[
%% %%    \prune(\node{u}) = \begin{cases}
%% %%      \zerotree & \text{ if } \node{u} = \zerotree \\
%% %%      \zerotree & \text{ if } \nlabel{u} 
%% %%      (\nv{u}, \nlabel{u}, \lbrace \prune(\node{e}):
%% %%      \node{e}\in\child{u} \rbrace) & otherwise \\
%% %% \end{cases}
%% %% \].
%% %% \end{definition}
