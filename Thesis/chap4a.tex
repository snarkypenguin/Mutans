\chapter[A \CRING\ WITH TREE ELEMENTS] {A \cring\ with tree elements}\label{treering}
\typeout{Chapter 4: Introduction}\WeAreOn{\cfour}
\section{Introduction}
The project which triggered the development of the structure in this
chapter was a project which considered modeling the social dynamics
associated with climate change -- a significant change from previous
representations of ``public'' participants, such as recreational
fishers, tourists, accomodation and other small businesses, which were
modelled in fairly simple ways (\cite{Fulton2011ningaloo,Gray2014}).
The specific goal was to be able to incorporate a simulation of the
way public opinion changes in response to policy actions and changes
in the economy and environment.  The starting point for this was a
corpus of responses to a survey on attitudes associated with the topic
of climate change (\cite{boschetti2012}). The data consisted of
(largely) numeric answers to individual questions which could
represented as either distinct items, or as an aggregation of symbolic
elements.  Questions like ``How much do trust the following
individuals or organisations to tell you the truth about changing
climate?'' might be encoded in a symbolic way by aggregating the
symbols \textsf{climate\_change, trust, information\_source, AustPeng}
for the trustworthiness of the \emph{Australian Penguins} as a source
of information. The actual value marked could be encoded as a scalar,
giving us an expression like ``\textsf{4/5 + climate\_change +
information\_source + trust + AustPeng}''---expressing it in this way
suggested that working with more intricate relationships might be
possible.

While my involvement in the project was shortlived, the problem the
data posed was engaging, and slowly it became evident how the the
mathematical structures I was trying to construct could represent
configurations of models, and that it might be able to incorporate
the interdependencies between models and other information in a very
simple way.  My hope was to be able to construct example
configurations which were reasonable for particular conditions and to
assess how close to ``known-good'' configurations the system was
at any given point.  It also seemed possible that it might allow
strategies which were able to interpolate between ``good'' 
configurations making intermediate transitions between configurations
feasible. 

The first successful representation was the ring of trees described in
Chapter \ref{adaptiveselection}.  There were aspects of this
representation which were unsatisfying -- while its notion of the
``weight'' of a node had a direct analogue to the survey questions
which inpired it, the separation of the weight from the label seemed
artificial, and there seemed no clear way to generalise the
structure. If at all possible, I wanted the structure to be less
reliant on awkward operations when multiplying trees together.  The
structure described in this chapter is a simpler construction with a
more natural way of dealing with leaf nodes in the operations on
trees. While it doesn't really go as far as I would like, it makes a
number of operations more straightforward.

In this discussion, each node now consists of a polynomial and a
(possibly empty) set of leaf nodes; as before, the symbolic components
of the labels are the indeterminants in the polynomial, but we now
take the scalar part of the polynomial to be the ``weight'' of the
node in the sense of Chapter \ref{adaptiveselection}.  We might be
able to base our labels on the set of rational functions as an avenue
to encreasing the utility of the structure, but this exploration is
beyond the scope of this thesis. 

\typeout{Chapter 4: Conventions and preliminary definitions}
\section{Conventions and preliminary definitions}

Generally, we will use lower case, boldfaced symbols to denote a node
(or tree), and upper case, boldfaced symbols to denote sets and
multisets.  Other symbols (such as $x$) will typically refer to
numbers or \polyrat\ \polyforms. Elements of a node, \tnode{u} will be
identified using an appropriate subscript, such as \tnlabel{u} for a
node's label and \tchild{u}, for its children. Initially, the children
of a node were thought of as refinements or extensions of an attitude,
so the children of $\node{u}$ were its extensions (as in the paper of
Chapter \ref{adaptiveselection}); now they are simply referred to as
the children or its set of children.  Another change from Chapter
\ref{adaptiveselection} is that a node's set of children has become a
multiset.

We will take $\PLY{A}$ to be the \polytypes\ over the elements of a finite set of
symbols $\set{A}$.  Here $\FIELD$\ would usually be some numeric field such as $\mB{Q,
  R}$ or $\mB{C}$, for example.

\begin{definition}\label{def-of-dom}\typeout{...def-of-dom}
We define $\DOM$ to be a set of finite (acyclic) trees where each node is of the form
$(\nlabel{u}, \child{u})$ where it's label, $\nlabel{u}$ is a member of $\PLY{A}$ and
the multiset of children, $\child{u}$, contains leaf nodes of the same form.

Nodes or trees with no children will be called \emph{simple nodes, simple trees}, or
\emph{leaf nodes}, and simple nodes which also have scalar polynomials as their labels
may be referred to as \emph{scalar nodes} or \emph{scalar trees}. The domain of trees,
$\DOM$, is the collection of only those trees with a finite number of nodes.  form.  We
will make use of two special elements in $\DOM$, $\zerotree = (0, \emptyset)$, an analogue
of zero which we will call the \emph{zerotree}, and $\onetree = (1, \emptyset)$, which
will turn out to be the multiplicative identity. For convenience, we
will denote the special subsets  of $\DOM$ which consists of 
trees with constant labels as $\DOM_c$, and take $\DOM_v$, to be $\DOM
\setminus \DOM_c$.  %The subset of $\DOM_c$ consisting of scalar trees is $\DOM_s$.
\end{definition}

Note that the choice to use elements of the \polytypes\  for labels is, in a
sense, arbitrary: elements of any commutative ring will serve, though
we will see that if we use a commutative ring, $\DOM$ and the derived
domains are also commutative rings; here, the \polytypes\ provide a
simple example which is easily manipulated and printed. Similarly,
$\FIELD$ could be any scalar field.

First, the definitions for some basic tools for manipulating these trees.
\begin{definition}
  For $\node{u} \in \DOM$\ we define the function
  \begin{align*}
    \depth(\node{u}) = \begin{cases}
      0 & \text{ if } \node{u} = \Zerotree = \zerotree \\
      1 & \text{ if } \node{u} \text{ is a simple node} \\
      1 + \max(\lbrace\depth(\node{v}):\forall \node{v} \in \child{u}\rbrace) & otherwise
    \end{cases}
  \end{align*}
  which gives us the depth of the tree.
\end{definition}

\begin{definition}
  We will also define for $\node{u} \in \DOM$,
  \begin{align*}
    \trim(\node{u}) = \begin{cases}
      \zerotree & \text{ if } \node{u} = \zerotree \\
      \zerotree & \text{ if } \node{u} \text{ is simple} \\
      (\nlabel{u}, \lbrace \trim(\node{e}): \forall\node{e}\in\child{u} \rbrace \setminus \{\zerotree\}) & otherwise.
    \end{cases}
  \end{align*}
\end{definition}

Obviously the $\depth$ is an indication of how many levels of nodes
the tree possesses.

Trimming essentially removes all simple nodes from the tree.
of trimming will be denoted $\trim_{k}$, indicating that the tree
\tnode{u} will be trimmed $k$\ times. Note that
$\trim_{\depth(\node{u})}{\node{u}} = 0$\ and
$\depth(\trim_{\depth{\node{u}}-1}{\node{u}}) = 1$.

\begin{definition}
  The cardinality of a tree is the number of nodes it contains. We define it formally as
  \begin{align*}
    \Tcard{\node{u}} = \begin{cases}
      0 & \text{ if } \node{u} = \zerotree\\
      1 + \sum_{\node{e}\in\child{u}} \Tcard{\node{e}}.
    \end{cases}
  \end{align*}
  %% and the content of a tree is the number of non-zerotree nodes,
  %% \begin{align*}
  %%   \content{u} = \begin{cases}
  %%     0 & \text{ if } \node{u} = \zerotree\\
  %%     \sum_{\node{e}\in\child{u}} \content{\node{e}}.
  %%   \end{cases}
  %% \end{align*}

  Simple nodes are the only nodes which have a cardinality of one, and \tzerotree\ is the only node or tree with a
  cardinality of zero.
\end{definition}

\begin{definition}\label{absolute-mag}\typeout{...absolute-mag}
  Let the function $\scalar(p)$ be a function from $\PLY{A}$ which
  maps a polynomial to its scalar term. Then the absolute magnitude of
  a tree is given by
  \begin{align*}
    \nabs{\node{u}} = \begin{cases}
      0 & \text{ if } \node{u} = \zerotree \\
      \abs{\scalar(\nlabel{u})} & \text{ if }\child{u} = \emptyset \\
      \abs{\scalar(\nlabel{u})} + \sum_{\node{e}\in\child{u}}\nabs{\node{e}} & \text{ otherwise.}
    \end{cases}
  \end{align*}
\end{definition}
%\begin{remark}
The absolute magnitude is only based only on the values of the
nodes of trees. % This corresponds to the $L^1$ norm on the tree space.
Note that each node in a tree can only contribute a non-negative
quantity to the absolute value of the tree, it is obvious that
$\nabs{\node{u}} \geq 0$\ for all $\node{u} \in \DOM$\ and that
equality only occurs if the value of each node in the tree \tnode{u}
is zero.
%\end{remark}

\begin{definition}
  The \emph{overlap} between two trees is defined
  \[
  \overlap(\node{u},\node{v}) = \begin{cases}
    0 & \text{ if } \node{u} = \zerotree \mor \node{v} = \zerotree \mor \node{u}\nsim\node{v} \\
    1 + \displaystyle\sum_{\substack{\node{e}\in\child{u} \\ \node{f}\in\child{v}}} \overlap(\node{e},\node{f}) & \text{otherwise}
  \end{cases}
  \]

  Two trees will be said to \emph{completely overlap} if
  $\Tcard{\node{u}} = \Tcard{\node{v}} = \overlap(\node{u},\node{v})$.
  %We may also make use of the relative overlap of two nodes, \tnode{u} and \tnode{v}, given by \[\overlap_{r}(\node{u},\node{v})
  %= \frac{2 \overlap(\node{u},\node{v})}{\Tcard{\node{u}}+\Tcard{\node{v}}}.\] The relative overlap of  \tzerotree\ with itself is
  %not defined.
\end{definition}


%% \begin{definition}
%%   \label{delta-function}
%%   The degree of deviation between two trees, \tnode{u} and \tnode{v} is given  by the expression

%%    \begin{equation}
%%      \delta{\node{u}}{\node{v}} = (1+\nabs{\node{u} - \node{v}})\frac{\Tcard{\node{u}}\Tcard{\node{v}}}{\overlap{\node{u},\node{v})^2} - 1 
%%    \end{equation}

%%   The rationale behind this definition is that if trees \tnode{u} and \tnode{v} are identical, then
%%   $\delta{\node{u}}{\node{v}}$ will be zero. We also want nodes that aren't common to both trees to
%%   count as differences.
%% \end{definition}

\typeout{Chapter 4: Addition and Scalar Multiplication}
\section{Addition and Scalar Multiplication}

My aim was to be able to compare trees in a robust way and to
manipulate them like they were vectors in a standard way.  I felt that
it would be nice to be able to merely add a branch to a tree
representing a new agent to an existing state tree, or to see how
close a given configuration was to other example configurations so
that configurations that were---somehow---optimal could be selected as
the system moved through its modelled state space.

We will start by defining scalar multiplication of the trees in
$\DOM$, and then we will define a few useful mappings which will help
keep the expressions simple. Our aim, in this section, is to define
addition, and to show that the defined scalar multiplication and
addition make this a vector space. When there is no risk of ambiguity,
we will use the same symbol to refer to both the set and
a vector space based on that set.

\begin{definition}\label{scalarmultiplication}\typeout{...scalarmultiplication}
  Given $a \in \FIELD$\ and $\node{u} \in \DOM$, we
  define
  \begin{align*}
    a \node{u} = \begin{cases}
      \zerotree  & \text{ if } a = 0 \mor \node{u} = \zerotree \\
      (a \nlabel{u}, a\child{u}) & \text{ otherwise }
    \end{cases}
  \end{align*}
  where \[a\child{u} = \{a \node{v}: \node{v}\in\child{u}\}\] is
  element-wise multiplication; fortunately,  $-1 \node{u} \equiv
  -\node{u}$\ turns out to be consistent with common use.
\end{definition}

%% \begin{definition}\label{useful-set-functions}\typeout{...useful-set-functions}
%%   We will define a few useful notation or relations on multisets of nodes
%%   in $\DOM$. Take $\multiset{U}$ and $\multiset{V}$ be such multisets and
%%   \tnode{a} be a node in $\DOM$; then 
%%   \begin{align*}
%%       \nlabels{U} &= \{\nlabel{e}: \forall \node{e} \in \multiset{U}\} \notag\\
%%       a \multiset{U} &= \{a \node{u}: \forall \node{u} \in \multiset{U}\} \notag
%%   \end{align*}
%% \end{definition}


%% \begin{definition}\label{useful-node-functions}\typeout{...useful-node-functions}
%%   For convenience, we define an analogues of $\nlabels{}$ for us to
%%   refer to the labels of a node's children.

%%   Let \tnode{u} and \tnode{v} be arbitrary nodes in $\DOM$.  Then we
%%   define the following
%%   \begin{align*}
%%       \nlabels{u} &\equiv \nlabels{\child{u}}\\
%%       %% \restrictedto{u}{v} &\equiv \restrictedto{\child{u}}{\child{v}}\\
%%       %% \nrestrictedto{u}{v} &\equiv \nrestrictedto{\child{u}}{\child{v}}
%%   \end{align*}
%% \end{definition}

\begin{definition}
  We want to be able to ``collect terms'' when we add or multiply
  trees, so we want to establish an equivalence relation on the set of
  all possible labels. We will construct special equivalence classes
  for elements of $\DOM$ which correspond to the additive and
  multiplicative units, $\zerotree$ and $\onetree$ and for other
  members with constant labels in their root nodes, where
  $\nlabel{u}\in\DOM_c$.  For the rest, the trees with non-constant
  polynomial labels with terms containing symbols from the set
  $\PLY{A}$, we define a relation between polynomial labels
  $\nlabel{\lambda},$ where
  \begin{equation}
    \lambda\Bigl(a_0 + \sum_{j=1}^k a_j \bigl(\Pi_{i=1}^n
    x_{i\/j}^{e_{i\/j}}\bigr)\Bigr)
    = \{x_{i\/j}^{e_{i\/j}}: a_j \neq 0, j\in[1,k], i\in[1,n]\}.
  \end{equation}
  If $\lambda(p) = \emptyset$, then the polynomial $p$ must be
  constant. 
  
  Using this relation, we define our equivalence relation on $\DOM$,
  \begin{equation}
    \eqc{\node{u}} = \begin{cases}
      \{\node{v} \in \DOM: \nabs{\node{v}} = 0\} & \text{ if } \nabs{\node{u}} = 0 \\
      \{\node{v} \in \DOM: \nlabel{v} = 1 \mand\ \nabs{\node{u}} = 1\} & \text{ if } \nlabel{u} = 1 \mand\ \nabs{\node{u}} = 1\\
      \DOM_c\setminus(\eqc{\zerotree} \cup \eqc{\onetree}) & \text{if } \nlabel{u}\in\DOM_c \setminus(\eqc{\zerotree} \cup \eqc{\onetree})\\
      &\text{previous two classes apply}\\
      \text{\hfill and } & \\
      \{\node{v} \in \DOM: \nlabel{\lambda}({\node{v}}) = \nlabel{\lambda}({\node{u}})\} & \text{otherwise}
    \end{cases}
  \end{equation}

  Two polynomials, $p$ and $q$, are similar ($p \sim q$) if
  $\lambda(p) = \lambda(q)$ and, analogously, we take
  $\node{r}\sim\node{s}$ to indicate that $\lambda(\nlabel{r}) \sim
  \lambda(\nlabel{s})$.  For a multiset of trees $\multiset{U}$ and a
  tree $\node{s}$,
  \[\eqc{\node{s}}_{\multiset{U}} = \{\node{r}: \node{r}\in\multiset{U} \mand \node{r}\sim\node{s}\} \]
  is the class of members of $\multiset{U}$ which are similar to
  $\node{s}$.  We can denote an equivalence class associated with a
  particular polynomial label analogously, $\eqc{p}_{\multiset{U}}$.
  The set of unique equivalence classes which comprise $\multiset{U}$
  is
  \begin{equation}
    %%\Lambda(\multiset{U}) = \{\eqc{\node{r}}_{\multiset{U}}: \node{r}\in\multiset{U}\}
    \Lambda(\multiset{U}) = \{\eqc{\node{r}}_{\multiset{U}}: \node{r}\in\multiset{U} \mand\ \nabs{\node{r}} \neq 0\}
  \end{equation}
  Note that for polynomials $p$ and $q$;
  $p \sim q$ does \emph{not} imply $r + p \sim r + q$; $(x^2 + 2x + 1)
  + (x^2 - 2x) \nsim (x^2 + 2x + 1) + (x^2 + 2x)$, for example.
\end{definition}


\begin{definition}
  \label{sumsimilars}\typeout{...sumsimilars}
  The tree \[\eqc{\node{r}}_{\multiset{U}}^{\Sigma} =
  \sum_{\node{s}\in\eqc{\node{r}}_{\multiset{U}}} \node{s}\] is the sum
  of all the members of $\multiset{U}$ which are similar to
  $\node{r}$,  and
  \begin{equation}
    \LS(\multiset{U}) = \begin{cases} 
      \emptyset &  \text{ if } \multiset{U} = \emptyset \text{ or } \stsum{\node{r}\in\multiset{U}}\nabs{\node{r}} = 0\\
      \{\node{s}: \node{s} = \eqc{\node{r}}^{\Sigma}_{\multiset{U}}: \forall \eqc{\node{r}}_{\multiset{U}} \in \Lambda(\multiset{U}) \} & \text{otherwise}\\
     \end{cases}
  \end{equation}
  is the \emph{set} which contains the sums of the elements of each of
  the constituent equivalence classes of $\multiset{U}$. 
\end{definition}

\begin{proposition}\label{sLambda}\typeout{...sLambda}
  For $a \in \FIELD$, $a \Lambda(\multiset{U}) = \Lambda(a\multiset{U})$ where $a\multiset{U}$ denotes element-wise
  multiplication.
  \begin{proof}
    The proposition is trivially true for nodes with a depth of zero.

    \begin{align*}
      a\Lambda(\multiset{U}) &= a \{\eqc{\node{r}}_{\multiset{U}}: \node{r}\in\multiset{U}\}\\ 
      &= \{a\eqc{\node{r}}_{\multiset{U}}: \node{r}\in\multiset{U}\}\\ 
      &= \{\eqc{a\node{r}}_{\multiset{U}}: \node{r}\in\multiset{U}\}\\
      &= \{\eqc{\node{s}}_{a\multiset{U}}: \node{s}\in a \multiset{U}\}\\
      &= \Lambda(a\set{U})
    \end{align*}
  \end{proof}   
\end{proposition}

%% \begin{proposition}\label{wildconjecture}\typeout{...wildconjecture}
%%   While it is true that similarity is not preserved over addition, it is true that $\LS(\multiset{U} \uplus \multiset{V}) =
%%   \LS(\multiset{U} \uplus \LS(\multiset{V}))$.
  
%%   {\Huge HERE: Write code to test this wild conjecture}

%%   \begin{proof}
%%     The proposition is clearly true if one or both multisets are empty. Let's consider the case when they both contain elements.
%%     \begin{align*}
%%       \LS(\multiset{U} \uplus \LS(\multiset{V}))
%%       &= \LS(\multiset{U} \uplus \{\eqc{\node{r}}^{\Sigma}_{\multiset{U}}: \forall \eqc{\node{r}}_{\multiset{U}} \in \Lambda(\multiset{U})\} \setminus \{\emptyset, \zerotree\}) \\
%%       \intertext{but the previous proposition shows that $p \Lambda(\multiset{U}) = \Lambda(p \multiset{U})$, so}
%%       &= \LS()
%%     \end{align*}
%%   \end{proof}
%% \end{proposition}

Now we define the addition of two trees,
\begin{definition}
  \label{treeaddition}\typeout{...treeaddition}
  When we add two trees, we add their labels and we add their children
  to similar children (when there are similar children).  

  For nodes \tnode{u} and $\node{v} \in \DOM$ we define their additive operation,
  \begin{align*}
    \node{u} + \node{v} &= \begin{cases}
      \node{u} &\text{ if } \node{v} = \zerotree \\
      \node{v} &\text{ if } \node{u} = \zerotree \\
      \bigl(\nlabel{u} + \nlabel{v}, \LS(\child{u} \uplus \child{v})\bigr) & \text{ otherwise}
    \end{cases}
  \end{align*}
  where the operator $\uplus$ is the standard multiset summing union operator
  which adds the multiplicities of elements in its argument multisets rather than taking
  the maximum multiplicity.

  This recursive evaluation is guaranteed to terminate, since we restrict
  ourselves to acyclic, finite trees.
\end{definition}

\typeout{Chapter 4: Vector space}
\section{Vector space}
In this section we prove that the defined elements and operations give
us a vector space.  

\begin{proposition}\label{vspace}\typeout{...vspace} $\DOM,$ with scalar multiplication and addition is a vector space.
  \begin{proof}
    We will assume that  $\node{p}, \node{q}, \node{u},\node{v},\node{w} \in \DOM$\ and $a, b \in  \FIELD,$ and that
    $\node{u} \sim \node{v} \sim \node{w}$ (they are all similar).

    \begin{description} 
    \item[Additive identity element --- ]\typeout{...additive identity}

      This is explicit in the definition of addition between elements
      of $\DOM$.

    \item[Inverse elements with respect to addition --- ]\typeout{...zero}

      The additive inverse of a node $\node{u}$ is $-1\node{u}$. It is easy to see that
      this must be the case for $\zerotree$ and simple nodes, this is a
      straightforward result, so we'll just go to the inductive step.

      \goodbreak
      So let's consider a tree, \tnode{u}, with a depth of $n+1$.
      \begin{align*}
        \NodeR{\nlabel{u}}{\child{u}} + -\NodeR{\nlabel{u}}{\child{u}}&=\NodeR{0}{\LS(\child{u}\uplus(-\child{u}))}\\
        \intertext{since -1 is scalar, each element of $\child{u}$ has a corresponding
          element in $-\child{u}$, and both have depths of $n$ or less, so}
        &= \NodeR{0}{\LS([\zerotree])}\\
        &=\NodeR{0}{\emptyset} \\
        &= \zerotree,
      \end{align*}
      and, inductively, we can see that the inverse must exist for all $n\in\BBNO$.

      %% The element $\zerotree$ is its own inverse, since $\zerotree
      %% + \zerotree = \zerotree$ by definition.

      %% So, we consider the case of $\node{u}$, where $\depth(\node{u})
      %% = 1$, then
      %% \begin{align*}
      %%     \node{u} + -\node{u} &= \NodeR{\nlabel{u}}{\emptyset} + \NodeR{-1\nlabel{u}}{\emptyset} \\
      %%     \intertext{but since the labels are polynomials}
      %%     &= \NodeR{\nlabel{u} + -\nlabel{u}}{\emptyset} \\
      %%     &= \Zerotree \\
      %%     &= \zerotree
      %% \end{align*}
      %% so for any simple node, $\node{u}$, $-\node{u}$\ is its
      %% inverse.

      %% Let \tnode{v} be a non-null node which is not simple, but has
      %% simple child  nodes, that is to say $\depth(\node{v}) = 2)$.  Then 
      %% \begin{align*}
      %%     \node{v} + -\node{v} &= \NodeR{\nlabel{v}-\nlabel{v}}{\LS(\lbrace \node{e} + -\node{e}: \forall \node{e} \in \child{v}\rbrace) \setminus\{\zerotree\}} \\
      %%     &= \NodeR{0}{\lbrace \zerotree\rbrace) \setminus\{\zerotree\}} \\
      %%     &= \Zerotree \\
      %%     &= \zerotree
      %% \end{align*}
      %% since the simple leaf nodes are all added to their own additive
      %% inverse.

      %% Having established this, we can generalise to trees with a depth
      %% greater than two. Assuming that the proposition holds for
      %% elements of $\DOM$ with depth $n$ or less, we consider an
      %% element, \tnode{u}, where $\depth(\node{u}) = n+1$ added to
      %% the element $-\node{u}$.
      %% \begin{align*}
      %%     \node{u} + -\node{u} &= \NodeR{\nlabel{u}-\nlabel{u}}{\lbrace \node{e} + -\node{e}: \forall \node{e} \in \child{u}\rbrace}
      %% \end{align*}

    \item[Multiplicative identity element --- ]\typeout{...one}

      This property is inherited from $\FIELD$ and $\PLY{A}$.

    \item[Commutativity --- ]\typeout{...commutativity}

      This property is inherited from polynomial addition in $\PLY{A}$
      and the commutativity of the $\uplus$ operator. 

      %% Let us consider similar nodes \tnode{u} and \tnode{v}.

      %% The commutativity of addition involving \tzerotree\ is
      %% guaranteed by the definition of addition. so we first address
      %% the case where both addends are simple.

      %% Take \tnode{u} and \tnode{v} to be simple nodes; then
      %% \begin{align*}
      %%   \node{u} + \node{v} &= \NodeR{\nlabel{u}}{\emptyset} + \NodeR{\nlabel{v}}{\emptyset} \notag\\
      %%   &= \NodeR{\nlabel{u} + \nlabel{v}}{\emptyset} \notag\\
      %%   &= \node{v} + \node{u}.
      %% \end{align*}

      %% Now suppose that there is some number $n$ for which
      %% $\depth(\node{u}) \leq n \mand \depth(\node{v}) \leq n
      %% \implies \node{u} + \node{v} = \node{v} + \node{u}$.

      %% Then if we take \tnode{u} and \tnode{v} to be nodes with depths
      %% of $n+1$ or less,
      %% \begin{align*}
      %%   \node{u} + \node{v} &= \NodeR{\nlabel{u}}{\child{u}} + \NodeR{\nlabel{v}}{\child{v}} \notag\\
      %%   &= \NodeR{\nlabel{u} + \nlabel{v}}{\child{u} \uplus \child{v}} \notag\\
      %%   &=
      %% \end{align*}

      %% %% &= \Bigl(\nlabel{u} + \nlabel{v}, \bigl(\{\node{r}+\node{s} : \node{r} \in \restrictedto{u}{v} \mand \node{s} \in \restrictedto{v}{u}\mand\node{r} \sim \node{s}\} \notag\\
      %% %%       & \qquad \qquad \qquad \qquad \uplus \{\node{r} : \node{r} \in \child{u}\mand \nexists \node{g}\in\child{v} \mst \node{r} \sim\node{g}\}\\
      %% %%       & \qquad \qquad \qquad \qquad \uplus \{\node{s} : \node{s} \in \child{v}\mand \nexists \node{g}\in\child{u} \mst \node{s} \sim\node{g}\}\bigr) \setminus \{\zerotree\}\Bigr) \notag\\
      %% %%       &= \Bigl(\nlabel{u} + \nlabel{v}, \bigl(\{\node{r}+\node{s} : \node{r} \in \child{u} \mand \nlabel{r} \in \nlabels{v} \mand \node{s} \in \child{v}\mand\nlabel{s} \in \nlabels{u}\} \notag\\
      %% %%       & \qquad \qquad \qquad \qquad         \uplus \nrestrictedto{\node{u}}{v} \uplus \nrestrictedto{v}{u}\bigr) \setminus \{\zerotree\}

      %% So,
      %% %% \begin{align*}
      %% %%     \node{u} + \node{v} &= \Bigl(\nlabel{v} + \nlabel{u}, \bigl(\{\node{r}+\node{s} : \node{r} \in \child{u} \mand \nlabel{r} \in \nlabels{v} \mand \node{s} \in \child{v}\mand\nlabel{s} \in \nlabels{u}\} \notag\\
      %% %%     & \qquad \qquad \qquad \qquad \uplus \nrestrictedto{\node{u}}{v} \uplus \nrestrictedto{v}{u}\bigr) \setminus \{\zerotree\}
      %% %% \end{align*}

      %% since addition in $\DOM$ is commutative. If we can demonstrate
      %% that the expression for the multiset of children is independent of
      %% order, then it must be the case that sum of the addends,
      %% \tnode{u}\ and \tnode{v}, must also be order independent.

      %% The multiset
      %% $\{\node{r}+\node{s}:\node{r}\in\child{u}\mand\nlabel{r}\in\nlabels{v}\mand\node{s}\in\child{v}\mand\nlabel{s}\in\nlabels{u}\}$
      %% must be order independent since each of the candidate
      %% \tnode{r}\ and \tnode{s}\ addends must have a depth of $n$ or
      %% less.
      %% %% Since set and multiset union is commutative, the order of
      %% %% $\nrestrictedto{u}{v}$ and $\nrestrictedto{v}{u}$ doesn't
      %% %% affect the result, thus, addition must be commutative for all
      %% %% $\node{u} \text{ where } \depth({\node{u}}) \leq n+1$.  By
      %% %% induction, this must be true for all $n \in \BBNO$.

    \item[Associativity --- ]\typeout{...associativity}

      This property follows directly from the associativity of
      polynomial arithmetic and the associativity of $\uplus$.

      %% Let us consider similar nodes $\node{u}, \node{v}$ and
      %% $\node{w}$ in $\DOM$. 

      %% First consider the situation where the depths of $\node{u}, \node{v}$ and
      %% $\node{w}$ are all less than or equal to one. If they all have
      %% a depth of zero, the sum is almost trivially the null
      %% tree. Similarly, if only one is the null tree, it rapidly
      %% degenerates to simple addition. So we take \tnode{u}, \tnode{v},
      %% and \tnode{w} to be simple. Then
      %% \begin{align*}
      %%   (\node{u}+\node{v})+\node{w} &= \bigl(\NodeR{\nlabel{u}}{\emptyset} + \NodeR{\nlabel{v}}{\emptyset}\bigr) + \NodeR{\nlabel{w}}{\emptyset} \\
      %%   &= \Bigr(\NodeR{\nlabel{u} + \nlabel{v}}{\emptyset} + \NodeR{\nlabel{w}}{\emptyset} \\
      %%   &= \NodeR{(\nlabel{u} + \nlabel{v}) + \nlabel{w}}{\emptyset} \\
      %%   &= \NodeR{\nlabel{u} + (\nlabel{v}) + \nlabel{w})}{\emptyset} \\
      %%   &= \node{u} + (\node{v} + \node{w}).
      %% \end{align*}

      %% Let us consider the case where these may be non-simple
      %% trees. Suppose there is an integer $n$ such that associativity
      %% holds for any three trees $\node{u}, \node{v} \mand \node{w}$,
      %% whose depth is less than or equal to $n$, that is if
      %% $\depth(\node{u}) \leq n, \depth(\node{v}) \leq n \mand
      %% \depth(\node{w}) \leq n$,
      %% then it must be the case that \[(\node{u} + \node{v}) + \node{w} = \node{u} + (\node{v} + \node{w}).\]

      %% Now suppose one or more of these trees has a depth of $n+1$. Then
      %% \begin{align*}
      %%   (\node{u}+\node{v})+\node{w} &= \bigl(\NodeR{\nlabel{u}}{\child{u}} + \NodeR{\nlabel{v}}{\child{v}}\bigr) + \NodeR{\nlabel{w}}{\child{w}} \\
      %%   &= \NodeR{\nlabel{u}+\nlabel{v}}{\child{u}\uplus\child{v}} + \NodeR{\nlabel{w}}{\child{w}}.
      %% \end{align*}

      %% %%      \HERE I need to fix \uplus or convert to simply using a union of both children....

      %% Recall that 
      %% %% \begin{align*}
      %% %%     \child{u}\uplus\child{v} &=
      %% %%     \nrestrictedto{u}{v}\uplus\nrestrictedto{v}{u}\uplus\{\node{p}+\node{q}:\node{p}\in\restrictedto{u}{v}\mand\\
      %% %%       {}& \qquad\qquad\node{q}\in\restrictedto{v}{u}\mand \node{p}\sim\node{q}\}\\
      %% %%     \intertext{so, letting}
      %% %%     \set{B} &= \child{u}\uplus\child{v} \\
      %% %%     \intertext{we get}
      %% %%     (\node{u}+\node{v})+\node{w} &=\NNNodeR{(\nlabel{u} + \nlabel{v}) + \nlabel{w}}{\bigl(\nsrestrictedto{B}{w}\uplus\nrestrictedto{w}{B} \uplus \set{B}\uplus\child{w}\bigr)\setminus\{\zerotree\}} \\
      %% %%     &=\NNNodeR{\nlabel{u} + (\nlabel{v} + \nlabel{w})}{\bigl(\nsrestrictedto{B}{w}\uplus\nrestrictedto{w}{B}\uplus \set{B}\uplus\child{w}\bigr)\setminus\{\zerotree\}} \\
      %% %%     \intertext{since addition in $\DOM$ is associative.}
      %% %% \end{align*}

      %% Notice that the elements of all the multisets which comprise the multiset
      %% of children, those in $\multiset{B}$ and in \tchild{w},
      %% must have a depth of $n$ or less; any addition which occurs amongst the elements of these multisets must be
      %% associative by our inductive assumption. Hence
      %% \begin{align*}
      %%   (\node{u}+\node{v})+\node{w} = \node{u}+(\node{v}+\node{w}).
      %% \end{align*}

    \item[Compatibility of scalar multiplication and multiplication in
      $\FIELD$ --- ]\typeout{...compatibility of scalar mult}

      Observe first that $a \zerotree = \zerotree, \forall a \in
      \FIELD$. We also dispose with the case of simple nodes:
      \begin{align*}
        a(b \node{u}) &= (a(b \nlabel{u}, \emptyset)) \\
        &= (a b \nlabel{u}, \emptyset) \\
        &= ((a b) \nlabel{u}, \emptyset) \\
        &= (a b) \node{u};
      \end{align*}

      So assuming that multiplication is compatible with nodes with
      depths of $n$ or less, we consider \tnode{u}, where $\depth(\node{u})
      = n+1$,
      \begin{align*}
        a (b \node{u}) &= a (b  \nlabel{u}, b\child{u}) \\
        \intertext{since $\depth(\node{e}) \leq n \forall \node{e}\in \child{u},$ multiplication of these elements is compatible, and }
        &= (a b\/ \nlabel{u}, a(b\child{u})) \\
        \intertext{becomes}
        &= ((a b) \nlabel{u}, (a b)\child{u}) \\
        &= (a b) \node{u}
      \end{align*}

      Thus the scalar and field multiplication operators are compatible.

    \item[Distribution of scalar multiplication with respect to vector addition --- ]\typeout{...distribution}

      Let us consider trees, \tnode{u}\ and \tnode{v}.

      First, note that \[\forall \node{u} \in \DOM, a(\zerotree + \node{u}) = a \node{u} = a\zerotree + a \node{u},\]
      and that \[\forall \node{u},\node{v}\in\DOM, 0 (\node{u} + \node{v}) = \zerotree = 0 \node{u} + 0 \node{v}.\]

      The property holds for simple nodes, 
      \begin{align*}
        a(\node{u} + \node{v}) &= a (\NodeR{\nlabel{u}}{\emptyset} + \NodeR{\nlabel{v}}{\emptyset})\\ 
        &= a \NodeR{\nlabel{u} + \nlabel{v}}{\emptyset} \\
        &= \NodeR{a(\nlabel{u} + \nlabel{v})}{\emptyset} \\
        &= \NodeR{a\nlabel{u} + a\nlabel{v}}{\emptyset} \\
        &= \NodeR{a\nlabel{u}}{\emptyset} + \NodeR{a\nlabel{v}}{\emptyset} \\
        &= a \node{u} + a \node{v}.
      \end{align*}

      So, suppose that the equation $a ( \node{p} + \node{q}) =
      a \node{p} + a \node{q}$ holds for all nodes \tnode{p} and
      \tnode{q} such that $depth(\node{p}) \leq k$, and
      $\depth(\node{q}) \leq j$.

      Take $n = \min(j, k)$, $a\in\FIELD$, and nodes \tnode{u} and \tnode{v} such that
      $\depth(\node{u}) = n+1$, and $\depth(\node{v}) = n+1$.
      Note that $n$ must be greater than zero since the property holds for simple
      nodes.  Then
      \begin{align*}
        a \left(\node{u} + \node{v}\right) &= a \NodeR{\nlabel{u}}{\child{u}} + \NodeR{\nlabel{v}}{\child{v}}\\
        &= a\NodeR{\nlabel{u}}{\child{u}} + a\NodeR{\nlabel{v}}{\child{v}}\\        
        &= \NodeR{a \nlabel{u}}{a \child{u}} + \NodeR{a \nlabel{v}}{a \child{v}}\\
        &= \NodeR{a \nlabel{u} + a \nlabel{v}}{\LS(a \child{u} \uplus a \child{v})}\\
        \intertext{Proposition \ref{sLambda} gives us}
        &= \NodeR{a \nlabel{u} + a \nlabel{v}}{\LS(a(\child{u} \uplus \child{v}))}\\
        \intertext{and }
        &= \NodeR{a \nlabel{u} + a \nlabel{v}}{a \LS(\child{u} \uplus \child{v})}\\
        &= a\node{u} + a\node{v}
      \end{align*}

    \item[Distribution of scalar multiplication with respect to addition in $\FIELD$  --- ]\typeout{...distrib +}

      The property is clearly true when $\node{u} = \zerotree$,
      since $(a+b)\zerotree = \zerotree = a\zerotree+b\zerotree$.

      We first consider simple nodes:
      \begin{align*}
        (a + b)\node{u} &= (a + b) ((a + b)\nlabel{u}, \emptyset) \\
        &= ((a + b)\nlabel{u}, \emptyset) \\
        &= (a\nlabel{u}, \emptyset) + (b\nlabel{u}, \emptyset) \\
        &= a \node{u} + b \node{u}.
      \end{align*}

      Nodes with a depth of two are slightly more complicated, 
      \begin{align*}
        (a + b)\node{u} &= (a + b) ((a + b)\nlabel{u}, (a + b)\child{u}) \\
        &= (a\nlabel{u} + b\nlabel{u}, \{(a + b)\node{e}:\node{e}\in\child{u}\}) \\
        \intertext{but $\child{u}$ is composed of simple nodes, so,}
        &= (a\nlabel{u} + b\nlabel{u}, \{a \node{e} + b \node{e}:\node{e}\in\child{u}\}) \\
        &= (a\nlabel{u} + b\nlabel{u}, a\child{u} + b\child{u}) \\
        &= a \node{u} + b\node{u}.
      \end{align*}

      Now suppose the property holds for nodes with a depth of $n$.
      Then we consider node $\node{u}$ with a depth of $n+1$:
      \begin{align*}
        (a + b)\node{u} &= (a + b) (\nlabel{u}, \child{u}) \\
        &= ((a + b)\nlabel{u}, (a + b)\child{u}), \\
        &= (a\nlabel{u} + b\nlabel{u}, \{a \node{e} + b \node{e}:\node{e}\in\child{u}\}) \\
        \intertext{since $\depth(\node{e}) = n$}
        &= a \node{u} + b \node{u}.
      \end{align*}

    \end{description}
    By induction, the property must hold for all $n \in\BBNO$
  \end{proof}
\end{proposition}

\typeout{Chapter 4: Seminorms, norms and metrics} %
\section{Seminorms, norms and metrics} %

Now that we have a vector space, we can construct model configurations
as linear combinations of basis configurations. In the context of
models which change their configuration, we need a way for the model
itself to combine basis configuration trees by choosing from a set of
configurations that are known to exhibit suitable properties.  To this
end, we need a mechanism for judging how close or far a given
configuration is from where it needs to be -- we need a way to
decompose an extant, running configuration into its basis elements,
and then possibly map these to other configurations which are
justifiably more suitable.  To do this, we need to add some additional
structure to convert our vector space into a metric space.

% Seminorm: triangle inequality, |a|||v|| = ||av|| ... note |a| = 0
We will now construct a seminorm on the vector space
$\DOM$. This will induce a norm on a quotient space of $\DOM$ which we
can use as a tool for assessing the similarity of trees and,
ultimately, provide both a means of clustering trees and selecting
trees with particular properties.

\subsection{$\DOM$ and its seminorm}

\begin{proposition}\label{absolutehomogeneity}\typeout{...absolutehomogeneity}
  For $a \in \FIELD$ and $\node{u} \in \DOM, \abs{a}\nabs{\node{u}} =
  \nabs{a \node{v}}$.
  \begin{proof}
    The magnitude of the empty tree is trivially zero, so $\abs{a}\nabs{\zerotree} =
    \nabs{a\zerotree} = 0$.

    Consider simple nodes in $\DOM$:
    \begin{align*}
      \abs{a}\nabs{\node{u}} &= \abs{a}(\abs{\scalar(\nlabel{u})} + 0) \\
      &= \abs{a}\abs{\scalar(\nlabel{u})} \\
      &= \abs{a\scalar(\nlabel{u})} \\
      &= \abs{\scalar(a\nlabel{u})} \\
      &= \nabs{a \node{u}}.
    \end{align*}

    Now suppose that there is $n \in \BBNI$ such that the proposition is true for
    all trees with a depth of $n$ or less. Then, taking $\node{u} \in
    \DOM$ where $\depth(\node{u}) = n+1$, we have
    \begin{align*}
      \abs{a}\nabs{\node{u}} &= \abs{a}\bigl(\abs{\scalar(\nlabel{u}) + \sum_{\node{e}\in\child{u}}\nabs{\node{e}}}\bigr) \\
      &= \abs{a}\abs{\scalar(\nlabel{u})} + \abs{a}\sum_{\node{e}\in\child{u}}\nabs{\node{e}}\\
      &= \abs{a}\abs{\scalar(\nlabel{u})} + \sum_{\node{e}\in\child{u}}\abs{a}\nabs{\node{e}}\\
      \intertext{but all the elements in $\child{u}$ have a depth of $n$ or less}
      &= \abs{\abs{a}\scalar(\nlabel{u})} + \sum_{\node{e}\in\child{u}}\nabs{\abs{a}\node{e}} \\
      &= \abs{\scalar(a\nlabel{u})} + \sum_{\node{e}\in\child{u}}\nabs{a \node{e}} \\
      &= \nabs{a \node{u}}.
    \end{align*}

    By induction, the proposition must be true for all $n \in \BBNO$.
  \end{proof}
\end{proposition}

\begin{proposition}\label{triangle1}\typeout{...triangle1}
  For $\node{u} \mand \node{v} \in \DOM, \nabs{\node{u} + \node{v}}
  \leq \nabs{\node{u}} + \nabs{\node{v}}$.

  \begin{proof}
    We start by considering trees of depths zero and one. The case for null trees is trivial: $\nabs{\zerotree +
      \zerotree} = \abs{0 + 0} = 0$, and if only one of the trees has a depth of one, we get either $\nabs{\node{u} +
      \zerotree} = \nabs{\node{u}}$ or $\nabs{\zerotree + \node{u}} = \nabs{\node{u}}.$

    For $\node{u} \mand \node{v}$  with depths of one, \[\nabs{\node{u} + \node{v}} = \nabs{(\nlabel{u}+\nlabel{v}, \emptyset)}= \abs{\nlabel{u}+\nlabel{v}}.\]
    Since $\scalar(\nlabel{u})$ and $\scalar(\nlabel{v})$ are scalars in $\FIELD$, we must have
    \[\abs{\sv{u} + \sv{v}} \leq \abs{\sv{u}}+\abs{\sv{v}},\]
    so \[\abs{\sv{u}+\sv{v}} \leq \abs{\sv{u}}+\abs{\sv{v}} = \nabs{\node{u}} + \nabs{\node{v}}.\]

    So, let $n\in\BBNO$ be an integer for which the triangle inequality holds for all
    trees with a depth of $n$ or less.  Let's consider similar trees, \tnode{u} and \tnode{v} whose depths are less
    than or equal to $n+1$. Then
    \begin{align*}
      \nabs{\node{u} + \node{v}} &= \nabs{(\nlabel{u} + \nlabel{v}, \child{u}\uplus\child{v})} \\
      &= \abs{\sv{u} + \sv{v}} + \sum_{\node{e},\in{\child{u}\uplus\child{v}}}\nabs{\node{e}}.
    \end{align*}

    Observe that $\abs{\sv{u} + \sv{v}} \leq \abs{\sv{u}} + \abs{\sv{v}}$, and that each 
    of the addends in \[\sum_{\node{e},\in{\child{u}\uplus\child{v}}}\nabs{\node{e}}\] has a depth of $n$ or
    less, so 
    \begin{align*}
      \sum_{\node{e}\in{\child{u}\uplus\child{v}}}\nabs{\node{e}} &\leq \sum_{\node{e}\,in{\child{u}}}\nabs{\node{e}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}.\\
      \intertext{ This implies that}
      \nabs{\node{u} + \node{v}} &\leq \Bigl[\abs{\sv{u}} + \abs{\sv{v}} + \sum_{\node{e},\in\child{u}}\nabs{\node{e}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}\Bigr];\\
      \intertext{rearranging we get}
      \nabs{\node{u} + \node{v}}  &\leq \Bigl[\abs{\sv{u}} + \sum_{\node{e},\in\child{u}}\nabs{\node{e}}\Bigr] + \Bigl[\abs{\sv{v}} + \sum_{\node{e}\in\child{v}}\nabs{\node{e}}\Bigr] \\
      \intertext{and hence}
      \nabs{\node{u} + \node{v}} \leq \nabs{\node{u}} + \nabs{\node{v}}.
    \end{align*}
    By induction the result must hold for all $n\in\BBNO$.
  \end{proof}
\end{proposition}

\begin{corollary}\label{gseminorm}\typeout{...gseminorm}
  The absolute value forms a seminorm on $\DOM$.
  \begin{proof}  
    Propositions \ref{absolutehomogeneity} and \ref{triangle1} are 
    sufficient for the absolute value to be a seminorm on
    $\DOM$.
  \end{proof}
\end{corollary}

\section{Ring}\label{Ring}\typeout{...Ring}

At this point we should consider the elements $\node{o}\in\DOM$
which are analogues of zero. We define the set $\nullspace =
\{\node{o}\in\DOM : \nabs{\node{o}} = 0\}$, and observe that for any
$\node{e} \in \DOM, \mand \node{o} \in \nullspace$ the equation
$\nabs{\node{e} + \node{o}} = \nabs{\node{e}}$ must hold. 

Since $\DOM$ is a seminormed vector space, it is also a pseudometric
space and we can induce a fully fledged metric space over the quotient
space $\DOMQ = \DOM / \nullspace$.
%%We note that for any element
%%$\qnode{e}\in\DOMQ$ there must be a tree $\node{f}\in\qnode{e}$ with a
%%minimum number of nodes and that this tree is the generating element for
%%the coset $\qnode{e} \in\DOMQ$. With this in mind we define the
%%interior function:
%%\begin{definition}
%%  For $\node{e} \in \DOM$ we define its interior to be,
%%  \[
%%  \interior(\node{e}) = \begin{cases}
%%    \zerotree & \text{if } \nabs{e} = 0\\
%%    (\sv{e}, \nlabel{e}, \{\interior(\node{r}): \forall \node{r} \in \child{e} \text{ s.t. }\nabs{\node{r}} > 0\}\setminus\zerotree) & otherwise.
%%  \end{cases}
%%  \]
%%
%%This is really the tree \tnode{e} stripped of all the peripheral
%%branches or nodes which have an absolute value of zero. This, of
%%course, may discard symbolic information encoded by the labels within
%%the tree.
%%\end{definition}
For simplicity, we identify the coset of $\nullspace$ with respect to
$\zerotree$ with $\rzerotree$, and we take the induced metric on the
normed vector space $\DOMQ$, to be \[\dist(\qnode{u},\qnode{v}) =
\nabs{\qnode{u} - \qnode{v}} \text{ for all }\qnode{u}, \qnode{v} \in
\DOMQ.\]  We will continue to use $\nabs{\rnode{u}}$ to denote the absolute
value of $\rnode{u}\in\DOMR$.

%% \subsection{Multiplication of elements in $\DOMQ$}
%% \begin{definition}\label{treemultiplication}\typeout{...treemultiplication}
%%   The product of two elements $qnode{u}, \qnode{v}\in \DOMQ$
%%     is defined by
%%   \begin{align*}
%%     \qnode{u} \qnode{v} = \begin{cases}
%%       \zerotree & \text{ if either factor is } \zerotree \\


\subsection{Multiplication}\label{Multiplication}\typeout{...Multiplication}
Now we define the multiplicative operator on the elements of $\DOMR$.
This operator is modelled on polynomial multiplication, and it inherits many of its
properties from the ring of polynomials.

\begin{definition}\label{treemultiplication1} \typeout{...treemultiplication}
  For nodes $\rnode{u}, \rnode{v} \in \DOMR$, we define their product,
  $\rnode{u} \tdot \rnode{v}$, by
  \begin{equation}
    \rnode{u} \tdot \rnode{v} = \begin{cases}
      \rzerotree & \text{if either of the nodes is } \rzerotree \\
      \Bigl(\rlabel{u}\rlabel{v},\LS\bigl(

      \{\rnode{r} \tdot \rnode{s}: \rnode{r}\in\rchild{u},\rnode{s}\in\rchild{v}\}\bigl)\Bigr) & \text{ otherwise} \\
    \end{cases}
  \end{equation}

  Like the process of multiplying polynomials, we generate all of the pairwise
  products, and then collect similar children, here using the $\Lambda^\Sigma$
  function.  
\end{definition}

Now we must prove that the necessary multiplicative properties so that
we can be confident that arithmetic involving trees works in the
``normal'' way.

\begin{proposition}\label{TMcommutativity}\typeout{...TMcommutativity}
  Multiplication of trees in $\DOMR$ is commutative.
  \begin{proof}
    Suppose there is a number $n\in\BBNO$ such that multiplication is
    commutative for all trees $\rnode{u}, \rnode{v}$ such that
    $\depth(\rnode{u}), \depth(\rnode{v}) \le n$.

    Multiplications involving nodes with a depth of zero clearly
    commute.  In the case where both nodes are simple, it is evident
    that they must commute, since the multiplication of elements in
    $\PLY{A}$ is commutative.

    Suppose that one or both of the nodes, $\rnode{u} \mand \rnode{v}$,
    has a depth of $n+1$, then
    \begin{align*}
      \rnode{u}\tdot\rnode{v} &= \NodeR{\rlabel{u}\rlabel{v}}{\LS(\{\rnode{r} \tdot \rnode{s}: \rnode{r}\in\rchild{u},\rnode{s}\in\rchild{v}\})}\\
      \intertext{and because polynomial mutiplication commutes,}
      &= \NodeR{\rlabel{v}\rlabel{u}}{\LS({\rnode{r} \tdot\rnode{s}: \rnode{r}\in\rchild{u},\rnode{s}\in\rchild{v}\}})}\\
        \intertext{but the addition of nodes commutes and all the terms in child are of depth $n$, so ,}
      &= \NodeR{\rlabel{v}\rlabel{u}}{\LS({\rnode{s} \tdot\rnode{r}: \rnode{r}\in\rchild{u},\rnode{s}\in\rchild{v}\}})}\\
      &=\rnode{v}\tdot\rnode{u}\,
    \end{align*}  
    and so the multiplication of nodes with a depth of $n+1$ must commute.  By
    induction, we can say that trees of arbitrary depth commute with
    this definition of multiplication in $\DOMR$.
  \end{proof}
\end{proposition}

\begin{lemma}
  Let $\set{H}, \set{I}$ and $\set{J}$ be sets of polynomials in $\PLY{A}$.  Then if we
  take $\set{H} \cross \set{I}$ to denote the set of products $\{h i: h \in \set{H}, i
  \in \set{i}\}$, then we can see that this set has $\vert\set{H}\vert
  \vert\set{I}\vert$ elements, and then if we consider $(\set{H} \set{I}) \set{J}$, we
  find that its cardinality is the product of the cardinality of the three sets
  $\set{H}, \set{I}$ and $\set{J}$, and the result is identical to $\set{H} (\set{I}
  \set{J})$ because polynomial multiplication is associative.  The question becomes
\end{lemma}  

\begin{proposition}\label{TMassociativity}\typeout{...TMassociativity}
  Multiplication of trees in $\DOMR$ is associative.
  \begin{proof}
    Suppose there is a number $n$ such that multiplication is
    associative for all trees $\rnode{u}, \mand \rnode{v}, \rnode{w}$ such that
    $\depth(\rnode{u}), \depth(\rnode{v}), \mand  \depth(\rnode{w}) \le n$.
    In the case where all of the nodes are simple, it is obvious that
    they must be associative, since scalar multiplication is associative, and the
    multiplication of elements in $\PLY{A}$ is associative.

    $\rchild{r}\tdot\rchild{s}$ to represent $\{\rnode{f}\tdot\rnode{g}: \rnode{f}\in\rchild{r},
    \rnode{g}\in\rchild{s}\}$, th

    Suppose that one or more of the nodes has a depth of $n+1$ or
    less. 
    \begin{align*}
      \rnode{u} \tdot (\rnode{v} \tdot \rnode{w}) &= (\rlabel{u},\rchild{u}) \tdot (\rlabel{v}\rlabel{w},\LS(\rchild{v}\tdot\rchild{w}))\\
      \intertext{so, recalling that $\LS(\rchild{v}\tdot\rchild{w})$ is
        merely a set of nodes, we can write}
      &= (\rlabel{u}\rlabel{v}\rlabel{w},\LS(\rchild{u} \tdot \LS(\rchild{v}\tdot\rchild{w})))\\
      &= \bigl(\rlabel{u} (\rlabel{v}\rlabel{w}), \LS(v(wu))\bigr)
      \intertext{but associativity holds in both the $\PLY{A}$-product and the  multiset-$\uplus$ operation, so}
      &= \bigl((\rlabel{u} \rlabel{v})\rlabel{w}, \LS((vw)u)\bigr)
    \end{align*}
    Again, the elements in the multisets of children are all of depth $n$ or less, so associativity and commutativity hold in the children; since both
    associativity and commutativity also hold in both the multiset-$\uplus$ operation and the multiplication of polynomials in $\PLY{A}$, they hold
    for multiples with a depth of $n+1$. Induction then gives us the rest.
  \end{proof}
\end{proposition}

\begin{proposition}\label{TMdistrib}\typeout{...TMdistrib}
  Tree-multiplication distributes over tree-addition in $\DOMR$.

  Intuitively, the properties of operations on the scalar values and
  polynomial labels of each node suggests that this must be
  true. 

  \begin{proof}
    We want to show that for $\rnode{u}, \rnode{v}$, and $\rnode{w} \in
    \DOMR$, $\rnode{u}\tdot(\rnode{v}+\rnode{w}) = \rnode{u}\tdot\rnode{v}+\rnode{u}\tdot\rnode{w}$
    is true.

    Multiplication by nodes which have a depth less than two clearly distributes over addition, since the multiplication of scalars and of polynomials distributes over
    tree addition and there are no children to complicate matters. 

    Let us consider the cases  involving a node, $\rnode{u},$ with a depth
    of two, that is to say that $\rnode{u}$ has simple children.
    Then for summands with depths of two or less,

    \begin{align*}
      \rnode{u}\tdot(\rnode{v}+\rnode{w}) &=
      (\rlabel{u},\emptyset)\tdot((\rlabel{v},\rchild{v})+(\rlabel{w},\rchild{w}))\\
      &=(\rlabel{u},\emptyset)\tdot(\rlabel{v} + \rlabel{w},\rchild{v}\uplus\rchild{w})\\
      \intertext{\Large{HERE}}
      &=\Bigl(\rlabel{u}\rlabel{v} + \rlabel{u}\rlabel{w},  \LS\big(l(\rlabel{v}+\rlabel{w})\child{u}\uplus\rlabel{u}(\rchild{v}\uplus\rchild{w})\bigr)\Bigr)\\
%      &=(\rv{u}\rv{v} + \rv{u}\rv{w},\rlabel{u}\rlabel{w},\rchild{v}\uplus\rchild{w})\\
%      &=(\rv{u}\rv{v},\rlabel{u}\rlabel{v},\rchild{v})+(\rv{u}\rv{w},\rlabel{u}\rlabel{w},\child{w})\\
      &=\rnode{u}\tdot\rnode{v} + \rnode{u}\tdot\rnode{w}
    \end{align*}
    Note that this is independent of the depths of nodes $\rnode{v}$ and $\rnode{w}$.

    Suppose then that there is an integer $n \in \BBNI$ such that multiplication
    of nodes with a depth of $n$ or less distributes over
    addition, and we consider the case where our factors, $\rnode{u}$, have 
    depths of $n+1$ or less. Then
    \begin{align*}
      \rnode{u}\tdot(\rnode{v}+\rnode{w})&=(\rv{u},\rlabel{u},\rchild{u})\tdot((\rv{v},\rlabel{v},\rchild{v})+(\rv{w},\rlabel{w},\rchild{w}))\\
      &=(\rv{u}(\rv{v}+\rv{w}),\rlabel{u}\rlabel{v},\LS(\rchild{u}\uplus\LS(\rchild{v}\uplus\rchild{w})))\\
      &\intertext{\Large{HERE}}
      &\intertext{all of the nodes in the expression for the multiset
        of children
        are of depth less than or equal to n, so}
      &= \rnode{u}\tdot(\rnode{w}+\rnode{v})
    \end{align*}

  \end{proof}
\end{proposition}

\begin{corollary}\label{ItsARingHarry}\typeout{...ItsARingHarry}
  $\DOMR$ with tree addition and tree multiplication is a commutative \rng.
  \begin{proof}
    Propositions \ref{TMcommutativity}, \ref{TMassociativity}, and
    \ref{TMdistrib} are sufficient to establish that it is a commutative
    \rng.
  \end{proof}
\end{corollary}









% \begin{proposition}\label{complete}\typeout{...complete}
%   $\DOMR$ is a complete metric space if $\FIELD$ is a complete metric
%   space.

%   \begin{proof}
%     We know that trivial Cauchy sequences exist, since constant
%     sequences must be Cauchy sequences. Suppose we have an arbitrary
%     Cauchy sequence, $\{u_i\}$, which converges to a tree $\rnode{u}$.  Observe
%     that members of the sequence need not be similar, but there
%     \emph{must} be an infinite subsequence of $\{u_i\}$ which is
%     similar since for every $\epsilon$ there exists an $N$ such
%     that $\nabs{\rnode{u_n} - \rnode{\u_m}} < \epsilon$ for all $m, n >
%     N$.  In effect, for any Cauchy sequence of trees there must be a
%     $K\leqN$ such that all $\{u_i\}$ with $i > K$ are similar.

%     So let us take an arbitrary value of $\epsilon$ and $\N$, and
%     consider what the condition $\epsilon > \nabs{\rnode{u_m} -
%       \rnode{u_n}}$ means. The only contributions either $\rnode{u_m}$
%     and $\rnode{u_n}$ make to the difference are those which are part
%     of the trees' overlaps. If we then consider the subsequence 





%% are all similar, but there must be a subsequence of
%%     similar trees since the generating set for $\PLY{A}$ is finite.


%%   \end{proof}
%% \end{proposition}


%% A more explicit discussion of the construction of $\DOMR$ and the
%% induced operations can be found in the appendix for those who are
%% unfamiliar with quotient sets.



%% \marginnote{\Defn\ norm.}
%% % Norm: triangle inequality, a|v| = |av|, |a| = 0 iff a = 0

%% \begin{definition}
%%   \label{def-tree-norm} For a node $\mathbf{u} \in \DOMR$, we define the
%%   value, $\treeval{u}$, \begin{align*} \label{tree-value-eq}
%%     \treeval{u} = \begin{cases} \abs{\nv{u}} & \text{ if } \child{u} = \emptyset
%%       \\
%%       \treeval{u} = \abs{\nv{u}} + \frac{1}{\card{\child{u}}} \sum\limits_{\node{e} \in \child{u}}
%%       \treeval{\node{e}} & \text{otherwise} \\ \end{cases} \end{align*}
%% \end{definition}




\typeout{Chapter 4: Discussion}
\section{Discussion}\typeout{...Discussion}

This \rng\ arose from attempts to capture the nuanced associations in
survey questions like \emph{``Thinking about the weather forecast, how
would you rate the chances of your favourite sporting team in the
coming match?''} and to be able to incorporate the sorts of
conflicting data that respondents may provide into simulation
models. Initially, the trees were no more that data structures with a
rough and ready ``distance'' function, but as the body of work became
more coherent, the underlying mathematical structure began to emerge,
and the realisation that the trees might be useful for representing
more than survey responses came about.  Applying trees in this manner,
in a program which might conceivably take weeks to run or be the basis
of management decisions, would require more robust foundations than a
heuristic function.

The loosely defined structure was defined and converted into a vector
space so that I could then construct ``model-spaces'' from a set of basis
elements corresponding to submodels. Extending this structure to the
assessment of configurations required a metric space.

In the example model developed later, the states of the model as a
whole, subdomains of the model and the components within the model are
represented by representative trees.  There is also a set of trees
which are identified by ``known-good'' configurations, and the
mechanism which handles switching within the model uses the metric in
its assessment.  Like the model in Chapter \ref{modelefficiency}, the
approach is quite shallow, but the hope is that, having established
the ring-theoretic properties, more advanced clustering and
discrimination techniques can be brought to bear.

In Chapter \ref{adaptiveselection} the model developed is concerned with
demonstrating the adaptive selection of models using abstracted
representations of the model's components and of the model's
configuration. These representations are in the form of trees in
$\DOMR$ with particular forms.


%% In this context, the difference between a conditional assessment and
%% an unconditional assessment may be central to the behaviour we want
%% from simulated entities.  The labels of nodes in a tree could be
%% associated with particular preconditions, and perturbations of a
%% tree---perhaps by summation, multiplication, restriction, or
%% extension---might provide appropriate ways of altering the perceptual
%% and attitudinal orientation of the modelled entities.  Alas this
%% project did not continue, but the unfolding mathematics converged with
%% the desire to control the mix of submodels as discussed in


%% \subsection{semantic coherence in the extensions}
%% The way the extensions of a node influence the value of a node can be
%% perverse if the data in these nodes aren't appropriate.  The
%% overriding rule is that extensions to a node \emph{must be relevant to
%%   that node}. For extrapolation from surveys this is a matter
%% associated with the coding of data, for simulation models (like MSE
%% models or evaluating climate adaptation strategies) it is a matter of
%% keeping track of influences and connections appropriately.  I don't
%% believe that this is entirely a trivial matter, but I also don't
%% believe it is a complex one.

%% Example\ldots

%% \section{Example model}

%% \section{Possible domains}
%% MSE models incorporating public opinion (surveys)

%% Relationship to Bayesian reasoning, Adaptive decision making (Baysian net?)

%% Adaptive behaviour (things can learn by adjusting weightings or
%% adding new branches)

%% Constructing or assessing phylogenetic trees? 

%% \appendix
%% \section{Appendix}

%% \subsection{Quotient sets}

%% \textbf{Is this necessary?}

%% An equivalence relation is function which takes elements from a set, say \tset{U}, 
%% and identifies them with a particular subset of some other set, \tqset{U}, so that every element of \tset{U}\ is
%% identified with an element of \tqset{U}. Members of a given subset of \tset{U} which are identified with the same
%% element in \tqset{U}\ are said to be \emph{equivalent}. We do this with even and odd integers -- from the point of view
%% of splitting a block of chocolate between two friends, a block with only two partitions is equivalent to a block with
%% thirty partitions.

%% In the context of $\DOM$, we wish to partition the set into sets whose
%% members are essentially the same from the point of view of addition
%% and scalar multiplication.  We do this by picking out all of the
%% elements which behave like ``zero'' and making them one of the
%% equivalence classes (which is a technical name for the elements of the
%% quotient space). Elements of $\DOM$ which have only zero values in
%% their constituent nodes behave essentially like zero: multiplication
%% by a scalar does not change them at all, and adding them to another
%% node doesn't alter its magnitude in any discernable way, nor is the
%% result of such an addition going to influence addition or scalar
%% multiplication in any way different from from the original.

%% \begin{example}
%%   Let us consider the sets \[\set{F}_i = \{e \in \mB{Z}: e = 12 n + i, for some n \in \mB{Z}\}\].  Can an integer be in
%%   more than one of these sets?  Suppose we pick a number, say 14;  this is clearly in $F_2$, since $14 = 12\times1\ + 2$. What happens if we multiply by three?
%% \begin{align*}
%%     3\times14 &= 42 \\
%%     &= 36 + 6 \\
%%     &= 3\times12 + 6 \\
%% \end{align*}    
%% so $3\times14$ is in $F_6$ \ldots which is just what $3\times2$ is in.  It doesn't take much experimentation to
%% discover that addition and scalar multiplication work in the $F_n$ sets in the way we might hope: $F_3(F_4 + F_9)$
%% corresponds to $3*(4 + 9)$ \ldots \emph{and to} $75*(888+81)$.  The number 75 is clearly in $F_{75}$, but this
%% isn't much use to us; looking at the definition of the \{F\} sets, we can see that 75 is also in $F_3$, so perhaps
%% we can only consider the non-negative indices which are less than 12..  The reason is that the sets are analogous to the
%% remainder on division by 12.

%% \end{example}


%% %\bibliography{biblio}
%% %\bibliographystyle{harvard}
%% %\biboptions{}

%% %% The influence of a node contributes to the assessment of the
%% %% weighted distance between two attitudes: the distance between them
%% %% incorporates the influence as a multiplicative term



%% %%  The ``inertia'', $r$\ will typically be propagated from the root
%% %% node (though it can be different and may change with interactions)


%% %% We need a dereferencing function which takes a path comprised of
%% %% symbols and returns the subtree, as well as the excision operator
%% %% (which we can use \setminus for).  Pruning a limb  that doesn't exist
%% %% returns the tree, pruning the null tree returns the null tree. 

%% %% $\node{a} \setminus \subtree(\node{a},(\nlabel{a}))  = \zerotree.

%% %%\begin{definition}
%% %% In a similar vein, we define, the domain \TPDOM\ whose elements are
%% %% finite sequences $\lbrace s_i \rbrace$ where $s_i \in \PLY$, and
%% %% the function $\prune(\node{u},s): (\DOM, \PDOM) \mapsto \DOM)$.
%% %% \[
%% %%    \prune(\node{u}) = \begin{cases}
%% %%      \zerotree & \text{ if } \node{u} = \zerotree \\
%% %%      \zerotree & \text{ if } \nlabel{u} 
%% %%      (\nv{u}, \nlabel{u}, \lbrace \prune(\node{e}):
%% %%      \node{e}\in\child{u} \rbrace) & otherwise \\
%% %% \end{cases}
%% %% \].
%% %% \end{definition}

